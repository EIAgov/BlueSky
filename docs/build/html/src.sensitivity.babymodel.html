

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>src.sensitivity.babymodel &mdash; BlueSky Prototype Model v1.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=e59714d7" />

  
      <script src="_static/jquery.js?v=5d32c60e"></script>
      <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="_static/documentation_options.js?v=45183d27"></script>
      <script src="_static/doctools.js?v=9bcbadda"></script>
      <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
      <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="src.sensitivity.faster_sensitivity" href="src.sensitivity.faster_sensitivity.html" />
    <link rel="prev" title="src.sensitivity" href="src.sensitivity.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            BlueSky Prototype Model
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="src.models.html">src.models</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="src.html">src</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="src.common.html">src.common</a></li>
<li class="toctree-l2"><a class="reference internal" href="src.integrator.html">src.integrator</a></li>
<li class="toctree-l2"><a class="reference internal" href="src.models.html">src.models</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="src.sensitivity.html">src.sensitivity</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">src.sensitivity.babymodel</a></li>
<li class="toctree-l3"><a class="reference internal" href="src.sensitivity.faster_sensitivity.html">src.sensitivity.faster_sensitivity</a></li>
<li class="toctree-l3"><a class="reference internal" href="src.sensitivity.sensitivity_tools.html">src.sensitivity.sensitivity_tools</a></li>
<li class="toctree-l3"><a class="reference internal" href="src.sensitivity.speed_test.html">src.sensitivity.speed_test</a></li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">BlueSky Prototype Model</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="src.html">src</a></li>
          <li class="breadcrumb-item"><a href="src.sensitivity.html">src.sensitivity</a></li>
      <li class="breadcrumb-item active">src.sensitivity.babymodel</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/src.sensitivity.babymodel.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-src.sensitivity.babymodel">
<span id="src-sensitivity-babymodel"></span><h1>src.sensitivity.babymodel<a class="headerlink" href="#module-src.sensitivity.babymodel" title="Link to this heading"></a></h1>
<p>Baby Model
This file contains the TestBabyModel class, which is a subclass of ConcreteModel, along with scripts that
help generate the model parameters and structure.</p>
<p>The model structure is randomly generated through the functions generate and connect_subregions, with
model parameters as input.</p>
<p class="rubric">Functions</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">E1</span></code>(z)</p></td>
<td><p>Classical case of the generalized exponential integral.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Eijk</span></code>(*args, **kwargs)</p></td>
<td><p>Represent the Levi-Civita symbol.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">GramSchmidt</span></code>(vlist[, orthonormal])</p></td>
<td><p>Apply the Gram-Schmidt process to a set of vectors.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">LC</span></code>(f, *gens, **args)</p></td>
<td><p>Return the leading coefficient of <code class="docutils literal notranslate"><span class="pre">f</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">LM</span></code>(f, *gens, **args)</p></td>
<td><p>Return the leading monomial of <code class="docutils literal notranslate"><span class="pre">f</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">LT</span></code>(f, *gens, **args)</p></td>
<td><p>Return the leading term of <code class="docutils literal notranslate"><span class="pre">f</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">N</span></code>(x[, n])</p></td>
<td><p>Calls x.evalf(n, **options).</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">POSform</span></code>(variables, minterms[, dontcares])</p></td>
<td><p>The POSform function uses simplified_pairs and a redundant-group eliminating algorithm to convert the list of all input combinations that generate '1' (the minterms) into the smallest product-of-sums form.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">SOPform</span></code>(variables, minterms[, dontcares])</p></td>
<td><p>The SOPform function uses simplified_pairs and a redundant group- eliminating algorithm to convert the list of all input combos that generate '1' (the minterms) into the smallest sum-of-products form.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Ynm_c</span></code>(n, m, theta, phi)</p></td>
<td><p>Conjugate spherical harmonics defined as</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">abundance</span></code>(n)</p></td>
<td><p>Returns the difference between the sum of the positive proper divisors of a number and the number.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">apart</span></code>(f[, x, full])</p></td>
<td><p>Compute partial fraction decomposition of a rational function.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">apart_list</span></code>(f[, x, dummies])</p></td>
<td><p>Compute partial fraction decomposition of a rational function and return the result in structured form.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_finite_diff</span></code>(order, x_list, y_list[, x0])</p></td>
<td><p>Calculates the finite difference approximation of the derivative of requested order at <code class="docutils literal notranslate"><span class="pre">x0</span></code> from points provided in <code class="docutils literal notranslate"><span class="pre">x_list</span></code> and <code class="docutils literal notranslate"><span class="pre">y_list</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">approximants</span></code>(l[, X, simplify])</p></td>
<td><p>Return a generator for consecutive Pade approximants for a series.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">are_similar</span></code>(e1, e2)</p></td>
<td><p>Are two geometrical entities similar.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">arity</span></code>(cls)</p></td>
<td><p>Return the arity of the function if it is known, else None.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">ask</span></code>(proposition[, assumptions, context])</p></td>
<td><p>Function to evaluate the proposition with assumptions.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">assemble_partfrac_list</span></code>(partial_list)</p></td>
<td><p>Reassemble a full partial fraction decomposition from a structured result obtained by the function <code class="docutils literal notranslate"><span class="pre">apart_list</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">assuming</span></code>(*assumptions)</p></td>
<td><p>Context manager for assumptions.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">banded</span></code>(*args, **kwargs)</p></td>
<td><p>Returns a SparseMatrix from the given dictionary describing the diagonals of the matrix.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">besselsimp</span></code>(expr)</p></td>
<td><p>Simplify bessel-type functions.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">binomial_coefficients</span></code>(n)</p></td>
<td><p>Return a dictionary containing pairs <span class="math notranslate nohighlight">\({(k1,k2) : C_kn}\)</span> where <span class="math notranslate nohighlight">\(C_kn\)</span> are binomial coefficients and <span class="math notranslate nohighlight">\(n=k1+k2\)</span>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">binomial_coefficients_list</span></code>(n)</p></td>
<td><p>Return a list of binomial coefficients as rows of the Pascal's triangle.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">block_collapse</span></code>(expr)</p></td>
<td><p>Evaluates a block matrix expression</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">blockcut</span></code>(expr, rowsizes, colsizes)</p></td>
<td><p>Cut a matrix expression into Blocks</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">bool_map</span></code>(bool1, bool2)</p></td>
<td><p>Return the simplified version of <em>bool1</em>, and the mapping of variables that makes the two expressions <em>bool1</em> and <em>bool2</em> represent the same logical behaviour for some correspondence between the variables of each.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">bottom_up</span></code>(rv, F[, atoms, nonbasic])</p></td>
<td><p>Apply <code class="docutils literal notranslate"><span class="pre">F</span></code> to all expressions in an expression tree from the bottom up.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">bspline_basis</span></code>(d, knots, n, x)</p></td>
<td><p>The $n$-th B-spline at $x$ of degree $d$ with knots.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">bspline_basis_set</span></code>(d, knots, x)</p></td>
<td><p>Return the <code class="docutils literal notranslate"><span class="pre">len(knots)-d-1</span></code> B-splines at <em>x</em> of degree <em>d</em> with <em>knots</em>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cacheit</span></code>(func)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cancel</span></code>(f, *gens[, _signsimp])</p></td>
<td><p>Cancel common factors in a rational function <code class="docutils literal notranslate"><span class="pre">f</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">capture</span></code>(func)</p></td>
<td><p>Return the printed output of func().</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">casoratian</span></code>(seqs, n[, zero])</p></td>
<td><p>Given linear difference operator L of order 'k' and homogeneous equation Ly = 0 we want to compute kernel of L, which is a set of 'k' sequences: a(n), b(n), .</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cbrt</span></code>(arg[, evaluate])</p></td>
<td><p>Returns the principal cube root.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">ccode</span></code>(expr[, assign_to, standard])</p></td>
<td><p>Converts an expr to a string of c code</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">centroid</span></code>(*args)</p></td>
<td><p>Find the centroid (center of mass) of the collection containing only Points, Segments or Polygons.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">chebyshevt_poly</span></code>(n[, x, polys])</p></td>
<td><p>Generates the Chebyshev polynomial of the first kind <cite>T_n(x)</cite>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">chebyshevu_poly</span></code>(n[, x, polys])</p></td>
<td><p>Generates the Chebyshev polynomial of the second kind <cite>U_n(x)</cite>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">check_assumptions</span></code>(expr[, against])</p></td>
<td><p>Checks whether assumptions of <code class="docutils literal notranslate"><span class="pre">expr</span></code> match the T/F assumptions given (or possessed by <code class="docutils literal notranslate"><span class="pre">against</span></code>).</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">checkodesol</span></code>(ode, sol[, func, order, ...])</p></td>
<td><p>Substitutes <code class="docutils literal notranslate"><span class="pre">sol</span></code> into <code class="docutils literal notranslate"><span class="pre">ode</span></code> and checks that the result is <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">checkpdesol</span></code>(pde, sol[, func, solve_for_func])</p></td>
<td><p>Checks if the given solution satisfies the partial differential equation.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">checksol</span></code>(f, symbol[, sol])</p></td>
<td><p>Checks whether sol is a solution of equation f == 0.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">classify_ode</span></code>(eq[, func, dict, ics, prep, ...])</p></td>
<td><p>Returns a tuple of possible <code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code> classifications for an ODE.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">classify_pde</span></code>(eq[, func, dict, prep])</p></td>
<td><p>Returns a tuple of possible pdsolve() classifications for a PDE.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">closest_points</span></code>(*args)</p></td>
<td><p>Return the subset of points from a set of points that were the closest to each other in the 2D plane.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cofactors</span></code>(f, g, *gens, **args)</p></td>
<td><p>Compute GCD and cofactors of <code class="docutils literal notranslate"><span class="pre">f</span></code> and <code class="docutils literal notranslate"><span class="pre">g</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">collect</span></code>(expr, syms[, func, evaluate, exact, ...])</p></td>
<td><p>Collect additive terms of an expression.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">collect_const</span></code>(expr, *vars[, Numbers])</p></td>
<td><p>A non-greedy collection of terms with similar number coefficients in an Add expr.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">combsimp</span></code>(expr)</p></td>
<td><p>Simplify combinatorial expressions.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">comp</span></code>(z1, z2[, tol])</p></td>
<td><p>Return a bool indicating whether the error between z1 and z2 is $le$ <code class="docutils literal notranslate"><span class="pre">tol</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">compose</span></code>(f, g, *gens, **args)</p></td>
<td><p>Compute functional composition <code class="docutils literal notranslate"><span class="pre">f(g)</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">composite</span></code>(nth)</p></td>
<td><p>Return the nth composite number, with the composite numbers indexed as composite(1) = 4, composite(2) = 6, etc....</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">compositepi</span></code>(n)</p></td>
<td><p>Return the number of positive composite numbers less than or equal to n.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#src.sensitivity.babymodel.connect_regions" title="src.sensitivity.babymodel.connect_regions"><code class="xref py py-obj docutils literal notranslate"><span class="pre">connect_regions</span></code></a>(region_map, hubmap, ...)</p></td>
<td><p>given a mapping of regions to lists of hubs, and hubs to regions, creates a set of arcs between hubs such that:</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">construct_domain</span></code>(obj, **args)</p></td>
<td><p>Construct a minimal domain for a list of expressions.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">content</span></code>(f, *gens, **args)</p></td>
<td><p>Compute GCD of coefficients of <code class="docutils literal notranslate"><span class="pre">f</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">continued_fraction</span></code>(a)</p></td>
<td><p>Return the continued fraction representation of a Rational or quadratic irrational.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">continued_fraction_convergents</span></code>(cf)</p></td>
<td><p>Return an iterator over the convergents of a continued fraction (cf).</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">continued_fraction_iterator</span></code>(x)</p></td>
<td><p>Return continued fraction expansion of x as iterator.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">continued_fraction_periodic</span></code>(p, q[, d, s])</p></td>
<td><p>Find the periodic continued fraction expansion of a quadratic irrational.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">continued_fraction_reduce</span></code>(cf)</p></td>
<td><p>Reduce a continued fraction to a rational or quadratic irrational.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">convex_hull</span></code>(*args[, polygon])</p></td>
<td><p>The convex hull surrounding the Points contained in the list of entities.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">convolution</span></code>(a, b[, cycle, dps, prime, ...])</p></td>
<td><p>Performs convolution by determining the type of desired convolution using hints.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cosine_transform</span></code>(f, x, k, **hints)</p></td>
<td><p>Compute the unitary, ordinary-frequency cosine transform of <cite>f</cite>, defined as</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">count_ops</span></code>(expr[, visual])</p></td>
<td><p>Return a representation (integer or expression) of the operations in expr.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">count_roots</span></code>(f[, inf, sup])</p></td>
<td><p>Return the number of roots of <code class="docutils literal notranslate"><span class="pre">f</span></code> in <code class="docutils literal notranslate"><span class="pre">[inf,</span> <span class="pre">sup]</span></code> interval.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">covering_product</span></code>(a, b)</p></td>
<td><p>Returns the covering product of given sequences.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cse</span></code>(exprs[, symbols, optimizations, ...])</p></td>
<td><p>Perform common subexpression elimination on an expression.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cxxcode</span></code>(expr[, assign_to, standard])</p></td>
<td><p>C++ equivalent of <code class="xref py py-func docutils literal notranslate"><span class="pre">ccode()</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cycle_length</span></code>(f, x0[, nmax, values])</p></td>
<td><p>For a given iterated sequence, return a generator that gives the length of the iterated cycle (lambda) and the length of terms before the cycle begins (mu); if <code class="docutils literal notranslate"><span class="pre">values</span></code> is True then the terms of the sequence will be returned instead.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cyclotomic_poly</span></code>(n[, x, polys])</p></td>
<td><p>Generates cyclotomic polynomial of order <cite>n</cite> in <cite>x</cite>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">decompogen</span></code>(f, symbol)</p></td>
<td><p>Computes General functional decomposition of <code class="docutils literal notranslate"><span class="pre">f</span></code>. Given an expression <code class="docutils literal notranslate"><span class="pre">f</span></code>, returns a list <code class="docutils literal notranslate"><span class="pre">[f_1,</span> <span class="pre">f_2,</span> <span class="pre">...,</span> <span class="pre">f_n]</span></code>, where::           f = f_1 o f_2 o ... f_n = f_1(f_2(... f_n)).</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">decompose</span></code>(f, *gens, **args)</p></td>
<td><p>Compute functional decomposition of <code class="docutils literal notranslate"><span class="pre">f</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">default_sort_key</span></code>(item[, order])</p></td>
<td><p>Return a key that can be used for sorting.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">deg</span></code>(r)</p></td>
<td><p>Return the degree value for the given radians (pi = 180 degrees).</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">degree</span></code>(f[, gen])</p></td>
<td><p>Return the degree of <code class="docutils literal notranslate"><span class="pre">f</span></code> in the given variable.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">degree_list</span></code>(f, *gens, **args)</p></td>
<td><p>Return a list of degrees of <code class="docutils literal notranslate"><span class="pre">f</span></code> in all variables.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">denom</span></code>(expr)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">derive_by_array</span></code>(expr, dx)</p></td>
<td><p>Derivative by arrays.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">det</span></code>(matexpr)</p></td>
<td><p>Matrix Determinant</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">det_quick</span></code>(M[, method])</p></td>
<td><p>Return <code class="docutils literal notranslate"><span class="pre">det(M)</span></code> assuming that either there are lots of zeros or the size of the matrix is small.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">diag</span></code>(*values[, strict, unpack])</p></td>
<td><p>Returns a matrix with the provided values placed on the diagonal.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">diagonalize_vector</span></code>(vector)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">dict_merge</span></code>(*dicts)</p></td>
<td><p>Merge dictionaries into a single dictionary.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">diff</span></code>(f, *symbols, **kwargs)</p></td>
<td><p>Differentiate f with respect to symbols.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">difference_delta</span></code>(expr[, n, step])</p></td>
<td><p>Difference Operator.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">differentiate_finite</span></code>(expr, *symbols[, ...])</p></td>
<td><p>Differentiate expr and replace Derivatives with finite differences.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">diophantine</span></code>(eq[, param, syms, permute])</p></td>
<td><p>Simplify the solution procedure of diophantine equation <code class="docutils literal notranslate"><span class="pre">eq</span></code> by converting it into a product of terms which should equal zero.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">discrete_log</span></code>(n, a, b[, order, prime_order])</p></td>
<td><p>Compute the discrete logarithm of <code class="docutils literal notranslate"><span class="pre">a</span></code> to the base <code class="docutils literal notranslate"><span class="pre">b</span></code> modulo <code class="docutils literal notranslate"><span class="pre">n</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">discriminant</span></code>(f, *gens, **args)</p></td>
<td><p>Compute discriminant of <code class="docutils literal notranslate"><span class="pre">f</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">div</span></code>(f, g, *gens, **args)</p></td>
<td><p>Compute polynomial division of <code class="docutils literal notranslate"><span class="pre">f</span></code> and <code class="docutils literal notranslate"><span class="pre">g</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">divisor_count</span></code>(n[, modulus, proper])</p></td>
<td><p>Return the number of divisors of <code class="docutils literal notranslate"><span class="pre">n</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">divisors</span></code>(n[, generator, proper])</p></td>
<td><p>Return all divisors of n sorted from 1..n by default.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">dotprint</span></code>(expr[, styles, atom, maxdepth, ...])</p></td>
<td><p>DOT description of a SymPy expression tree</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">dsolve</span></code>(eq[, func, hint, simplify, ics, xi, ...])</p></td>
<td><p>Solves any (supported) kind of ordinary differential equation and system of ordinary differential equations.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">egyptian_fraction</span></code>(r[, algorithm])</p></td>
<td><p>Return the list of denominators of an Egyptian fraction expansion <a href="#id8"><span class="problematic" id="id1">[1]_</span></a> of the said rational <cite>r</cite>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">epath</span></code>(path[, expr, func, args, kwargs])</p></td>
<td><p>Manipulate parts of an expression selected by a path.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">euler_equations</span></code>(L[, funcs, vars])</p></td>
<td><p>Find the Euler-Lagrange equations <a href="#id9"><span class="problematic" id="id2">[1]_</span></a> for a given Lagrangian.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">evaluate</span></code>(x)</p></td>
<td><p>Control automatic evaluation</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">expand</span></code>(e[, deep, modulus, power_base, ...])</p></td>
<td><p>Expand an expression using methods given as hints.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">expand_complex</span></code>(expr[, deep])</p></td>
<td><p>Wrapper around expand that only uses the complex hint.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">expand_func</span></code>(expr[, deep])</p></td>
<td><p>Wrapper around expand that only uses the func hint.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">expand_log</span></code>(expr[, deep, force, factor])</p></td>
<td><p>Wrapper around expand that only uses the log hint.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">expand_mul</span></code>(expr[, deep])</p></td>
<td><p>Wrapper around expand that only uses the mul hint.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">expand_multinomial</span></code>(expr[, deep])</p></td>
<td><p>Wrapper around expand that only uses the multinomial hint.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">expand_power_base</span></code>(expr[, deep, force])</p></td>
<td><p>Wrapper around expand that only uses the power_base hint.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">expand_power_exp</span></code>(expr[, deep])</p></td>
<td><p>Wrapper around expand that only uses the power_exp hint.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">expand_trig</span></code>(expr[, deep])</p></td>
<td><p>Wrapper around expand that only uses the trig hint.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">exptrigsimp</span></code>(expr)</p></td>
<td><p>Simplifies exponential / trigonometric / hyperbolic functions.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">exquo</span></code>(f, g, *gens, **args)</p></td>
<td><p>Compute polynomial exact quotient of <code class="docutils literal notranslate"><span class="pre">f</span></code> and <code class="docutils literal notranslate"><span class="pre">g</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">eye</span></code>(*args, **kwargs)</p></td>
<td><p>Create square identity matrix n x n</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">factor</span></code>(f, *gens[, deep])</p></td>
<td><p>Compute the factorization of expression, <code class="docutils literal notranslate"><span class="pre">f</span></code>, into irreducibles.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">factor_list</span></code>(f, *gens, **args)</p></td>
<td><p>Compute a list of irreducible factors of <code class="docutils literal notranslate"><span class="pre">f</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">factor_nc</span></code>(expr)</p></td>
<td><p>Return the factored form of <code class="docutils literal notranslate"><span class="pre">expr</span></code> while handling non-commutative expressions.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">factor_terms</span></code>(expr[, radical, clear, ...])</p></td>
<td><p>Remove common factors from terms in all arguments without changing the underlying structure of the expr.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">factorint</span></code>(n[, limit, use_trial, use_rho, ...])</p></td>
<td><p>Given a positive integer <code class="docutils literal notranslate"><span class="pre">n</span></code>, <code class="docutils literal notranslate"><span class="pre">factorint(n)</span></code> returns a dict containing the prime factors of <code class="docutils literal notranslate"><span class="pre">n</span></code> as keys and their respective multiplicities as values.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">factorrat</span></code>(rat[, limit, use_trial, use_rho, ...])</p></td>
<td><p>Given a Rational <code class="docutils literal notranslate"><span class="pre">r</span></code>, <code class="docutils literal notranslate"><span class="pre">factorrat(r)</span></code> returns a dict containing the prime factors of <code class="docutils literal notranslate"><span class="pre">r</span></code> as keys and their respective multiplicities as values.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">failing_assumptions</span></code>(expr, **assumptions)</p></td>
<td><p>Return a dictionary containing assumptions with values not matching those of the passed assumptions.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">farthest_points</span></code>(*args)</p></td>
<td><p>Return the subset of points from a set of points that were the furthest apart from each other in the 2D plane.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">fcode</span></code>(expr[, assign_to])</p></td>
<td><p>Converts an expr to a string of fortran code</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">fft</span></code>(seq[, dps])</p></td>
<td><p>Performs the Discrete Fourier Transform (<strong>DFT</strong>) in the complex domain.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">field</span></code>(symbols, domain[, order])</p></td>
<td><p>Construct new rational function field returning (field, x1, ..., xn).</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">field_isomorphism</span></code>(a, b, *[, fast])</p></td>
<td><p>Find an embedding of one number field into another.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">filldedent</span></code>(s[, w])</p></td>
<td><p>Strips leading and trailing empty lines from a copy of <code class="docutils literal notranslate"><span class="pre">s</span></code>, then dedents, fills and returns it.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">finite_diff_weights</span></code>(order, x_list[, x0])</p></td>
<td><p>Calculates the finite difference weights for an arbitrarily spaced one-dimensional grid (<code class="docutils literal notranslate"><span class="pre">x_list</span></code>) for derivatives at <code class="docutils literal notranslate"><span class="pre">x0</span></code> of order 0, 1, ..., up to <code class="docutils literal notranslate"><span class="pre">order</span></code> using a recursive formula.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">flatten</span></code>(iterable[, levels, cls])</p></td>
<td><p>Recursively denest iterable containers.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">fourier_series</span></code>(f[, limits, finite])</p></td>
<td><p>Computes the Fourier trigonometric series expansion.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">fourier_transform</span></code>(f, x, k, **hints)</p></td>
<td><p>Compute the unitary, ordinary-frequency Fourier transform of <code class="docutils literal notranslate"><span class="pre">f</span></code>, defined as</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">fps</span></code>(f[, x, x0, dir, hyper, order, rational, ...])</p></td>
<td><p>Generates Formal Power Series of <code class="docutils literal notranslate"><span class="pre">f</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">fraction</span></code>(expr[, exact])</p></td>
<td><p>Returns a pair with expression's numerator and denominator.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">fu</span></code>(rv[, measure])</p></td>
<td><p>Attempt to simplify expression by using transformation rules given in the algorithm by Fu et al.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">fwht</span></code>(seq)</p></td>
<td><p>Performs the Walsh Hadamard Transform (<strong>WHT</strong>), and uses Hadamard ordering for the sequence.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">galois_group</span></code>(f, *gens[, by_name, max_tries, ...])</p></td>
<td><p>Compute the Galois group for polynomials <em>f</em> up to degree 6.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">gammasimp</span></code>(expr)</p></td>
<td><p>Simplify expressions with gamma functions.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">gcd</span></code>(f[, g])</p></td>
<td><p>Compute GCD of <code class="docutils literal notranslate"><span class="pre">f</span></code> and <code class="docutils literal notranslate"><span class="pre">g</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">gcd_list</span></code>(seq, *gens, **args)</p></td>
<td><p>Compute GCD of a list of polynomials.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">gcd_terms</span></code>(terms[, isprimitive, clear, fraction])</p></td>
<td><p>Compute the GCD of <code class="docutils literal notranslate"><span class="pre">terms</span></code> and put them together.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">gcdex</span></code>(f, g, *gens, **args)</p></td>
<td><p>Extended Euclidean algorithm of <code class="docutils literal notranslate"><span class="pre">f</span></code> and <code class="docutils literal notranslate"><span class="pre">g</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#src.sensitivity.babymodel.generate" title="src.sensitivity.babymodel.generate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">generate</span></code></a>([num_regions, hubs_per_region, ...])</p></td>
<td><p>generates a random network with all parameters required to initialize a ToyBabyModel</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">getLogger</span></code>([name])</p></td>
<td><p>Return a logger with the specified name, creating it if necessary.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_contraction_structure</span></code>(expr)</p></td>
<td><p>Determine dummy indices of <code class="docutils literal notranslate"><span class="pre">expr</span></code> and describe its structure</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_indices</span></code>(expr)</p></td>
<td><p>Determine the outer indices of expression <code class="docutils literal notranslate"><span class="pre">expr</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">gff</span></code>(f, *gens, **args)</p></td>
<td><p>Compute greatest factorial factorization of <code class="docutils literal notranslate"><span class="pre">f</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">gff_list</span></code>(f, *gens, **args)</p></td>
<td><p>Compute a list of greatest factorial factors of <code class="docutils literal notranslate"><span class="pre">f</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">glsl_code</span></code>(expr[, assign_to])</p></td>
<td><p>Converts an expr to a string of GLSL code</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">groebner</span></code>(F, *gens, **args)</p></td>
<td><p>Computes the reduced Groebner basis for a set of polynomials.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">ground_roots</span></code>(f, *gens, **args)</p></td>
<td><p>Compute roots of <code class="docutils literal notranslate"><span class="pre">f</span></code> by factorization in the ground domain.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">group</span></code>(seq[, multiple])</p></td>
<td><p>Splits a sequence into a list of lists of equal, adjacent elements.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">gruntz</span></code>(e, z, z0[, dir])</p></td>
<td><p>Compute the limit of e(z) at the point z0 using the Gruntz algorithm.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">hadamard_product</span></code>(*matrices)</p></td>
<td><p>Return the elementwise (aka Hadamard) product of matrices.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">half_gcdex</span></code>(f, g, *gens, **args)</p></td>
<td><p>Half extended Euclidean algorithm of <code class="docutils literal notranslate"><span class="pre">f</span></code> and <code class="docutils literal notranslate"><span class="pre">g</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">hankel_transform</span></code>(f, r, k, nu, **hints)</p></td>
<td><p>Compute the Hankel transform of <cite>f</cite>, defined as</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">has_dups</span></code>(seq)</p></td>
<td><p>Return True if there are any duplicate elements in <code class="docutils literal notranslate"><span class="pre">seq</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">has_variety</span></code>(seq)</p></td>
<td><p>Return True if there are any different elements in <code class="docutils literal notranslate"><span class="pre">seq</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">hermite_poly</span></code>(n[, x, polys])</p></td>
<td><p>Generates the Hermite polynomial <cite>H_n(x)</cite>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">hermite_prob_poly</span></code>(n[, x, polys])</p></td>
<td><p>Generates the probabilist's Hermite polynomial <cite>He_n(x)</cite>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">hessian</span></code>(f, varlist[, constraints])</p></td>
<td><p>Compute Hessian matrix for a function f wrt parameters in varlist which may be given as a sequence or a row/column vector.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">homogeneous_order</span></code>(eq, *symbols)</p></td>
<td><p>Returns the order <cite>n</cite> if <cite>g</cite> is homogeneous and <code class="docutils literal notranslate"><span class="pre">None</span></code> if it is not homogeneous.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">horner</span></code>(f, *gens, **args)</p></td>
<td><p>Rewrite a polynomial in Horner form.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">hyperexpand</span></code>(f[, allow_hyper, rewrite, place])</p></td>
<td><p>Expand hypergeometric functions.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">hypersimilar</span></code>(f, g, k)</p></td>
<td><p>Returns True if <code class="docutils literal notranslate"><span class="pre">f</span></code> and <code class="docutils literal notranslate"><span class="pre">g</span></code> are hyper-similar.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">hypersimp</span></code>(f, k)</p></td>
<td><p>Given combinatorial term f(k) simplify its consecutive term ratio i.e. f(k+1)/f(k).</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">idiff</span></code>(eq, y, x[, n])</p></td>
<td><p>Return <code class="docutils literal notranslate"><span class="pre">dy/dx</span></code> assuming that <code class="docutils literal notranslate"><span class="pre">eq</span> <span class="pre">==</span> <span class="pre">0</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">ifft</span></code>(seq[, dps])</p></td>
<td><p>Performs the Discrete Fourier Transform (<strong>DFT</strong>) in the complex domain.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">ifwht</span></code>(seq)</p></td>
<td><p>Performs the Walsh Hadamard Transform (<strong>WHT</strong>), and uses Hadamard ordering for the sequence.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">igcd</span></code>(*args)</p></td>
<td><p>Computes nonnegative integer greatest common divisor.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">ilcm</span></code>(*args)</p></td>
<td><p>Computes integer least common multiple.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">imageset</span></code>(*args)</p></td>
<td><p>Return an image of the set under transformation <code class="docutils literal notranslate"><span class="pre">f</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">init_printing</span></code>([pretty_print, order, ...])</p></td>
<td><p>Initializes pretty-printer depending on the environment.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">init_session</span></code>([ipython, pretty_print, order, ...])</p></td>
<td><p>Initialize an embedded IPython or Python session.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">integer_log</span></code>(y, x)</p></td>
<td><p>Returns <code class="docutils literal notranslate"><span class="pre">(e,</span> <span class="pre">bool)</span></code> where e is the largest nonnegative integer such that <span class="math notranslate nohighlight">\(|y| \geq |x^e|\)</span> and <code class="docutils literal notranslate"><span class="pre">bool</span></code> is True if $y = x^e$.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">integer_nthroot</span></code>(y, n)</p></td>
<td><p>Return a tuple containing x = floor(y**(1/n)) and a boolean indicating whether the result is exact (that is, whether x**n == y).</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">integrate</span></code>(f, var, ...)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">interactive_traversal</span></code>(expr)</p></td>
<td><p>Traverse a tree asking a user which branch to choose.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">interpolate</span></code>(data, x)</p></td>
<td><p>Construct an interpolating polynomial for the data points evaluated at point x (which can be symbolic or numeric).</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">interpolating_poly</span></code>(n, x[, X, Y])</p></td>
<td><p>Construct Lagrange interpolating polynomial for <code class="docutils literal notranslate"><span class="pre">n</span></code> data points.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">interpolating_spline</span></code>(d, x, X, Y)</p></td>
<td><p>Return spline of degree <em>d</em>, passing through the given <em>X</em> and <em>Y</em> values.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">intersecting_product</span></code>(a, b)</p></td>
<td><p>Returns the intersecting product of given sequences.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">intersection</span></code>(*entities[, pairwise])</p></td>
<td><p>The intersection of a collection of GeometryEntity instances.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">intervals</span></code>(F[, all, eps, inf, sup, strict, ...])</p></td>
<td><p>Compute isolating intervals for roots of <code class="docutils literal notranslate"><span class="pre">f</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">intt</span></code>(seq, prime)</p></td>
<td><p>Performs the Number Theoretic Transform (<strong>NTT</strong>), which specializes the Discrete Fourier Transform (<strong>DFT</strong>) over quotient ring <cite>Z/pZ</cite> for prime <cite>p</cite> instead of complex numbers <cite>C</cite>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">inv_quick</span></code>(M)</p></td>
<td><p>Return the inverse of <code class="docutils literal notranslate"><span class="pre">M</span></code>, assuming that either there are lots of zeros or the size of the matrix is small.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">inverse_cosine_transform</span></code>(F, k, x, **hints)</p></td>
<td><p>Compute the unitary, ordinary-frequency inverse cosine transform of <cite>F</cite>, defined as</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">inverse_fourier_transform</span></code>(F, k, x, **hints)</p></td>
<td><p>Compute the unitary, ordinary-frequency inverse Fourier transform of <cite>F</cite>, defined as</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">inverse_hankel_transform</span></code>(F, k, r, nu, **hints)</p></td>
<td><p>Compute the inverse Hankel transform of <cite>F</cite> defined as</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">inverse_laplace_transform</span></code>(F, s, t[, plane])</p></td>
<td><p>Compute the inverse Laplace transform of <cite>F(s)</cite>, defined as</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">inverse_mellin_transform</span></code>(F, s, x, strip, **hints)</p></td>
<td><p>Compute the inverse Mellin transform of <cite>F(s)</cite> over the fundamental strip given by <code class="docutils literal notranslate"><span class="pre">strip=(a,</span> <span class="pre">b)</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">inverse_mobius_transform</span></code>(seq[, subset])</p></td>
<td><p>Performs the Mobius Transform for subset lattice with indices of sequence as bitmasks.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">inverse_sine_transform</span></code>(F, k, x, **hints)</p></td>
<td><p>Compute the unitary, ordinary-frequency inverse sine transform of <cite>F</cite>, defined as</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">invert</span></code>(f, g, *gens, **args)</p></td>
<td><p>Invert <code class="docutils literal notranslate"><span class="pre">f</span></code> modulo <code class="docutils literal notranslate"><span class="pre">g</span></code> when possible.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_abundant</span></code>(n)</p></td>
<td><p>Returns True if <code class="docutils literal notranslate"><span class="pre">n</span></code> is an abundant number, else False.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_amicable</span></code>(m, n)</p></td>
<td><p>Returns True if the numbers <cite>m</cite> and <cite>n</cite> are &quot;amicable&quot;, else False.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_convex</span></code>(f, *syms[, domain])</p></td>
<td><p>Determines the  convexity of the function passed in the argument.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_decreasing</span></code>(expression[, interval, symbol])</p></td>
<td><p>Return whether the function is decreasing in the given interval.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_deficient</span></code>(n)</p></td>
<td><p>Returns True if <code class="docutils literal notranslate"><span class="pre">n</span></code> is a deficient number, else False.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_increasing</span></code>(expression[, interval, symbol])</p></td>
<td><p>Return whether the function is increasing in the given interval.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_mersenne_prime</span></code>(n)</p></td>
<td><p>Returns True if  <code class="docutils literal notranslate"><span class="pre">n</span></code> is a Mersenne prime, else False.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_monotonic</span></code>(expression[, interval, symbol])</p></td>
<td><p>Return whether the function is monotonic in the given interval.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_nthpow_residue</span></code>(a, n, m)</p></td>
<td><p>Returns True if <code class="docutils literal notranslate"><span class="pre">x**n</span> <span class="pre">==</span> <span class="pre">a</span> <span class="pre">(mod</span> <span class="pre">m)</span></code> has solutions.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_perfect</span></code>(n)</p></td>
<td><p>Returns True if <code class="docutils literal notranslate"><span class="pre">n</span></code> is a perfect number, else False.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_primitive_root</span></code>(a, p)</p></td>
<td><p>Returns True if <code class="docutils literal notranslate"><span class="pre">a</span></code> is a primitive root of <code class="docutils literal notranslate"><span class="pre">p</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_quad_residue</span></code>(a, p)</p></td>
<td><p>Returns True if <code class="docutils literal notranslate"><span class="pre">a</span></code> (mod <code class="docutils literal notranslate"><span class="pre">p</span></code>) is in the set of squares mod <code class="docutils literal notranslate"><span class="pre">p</span></code>, i.e a % p in set([i**2 % p for i in range(p)]).</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_strictly_decreasing</span></code>(expression[, ...])</p></td>
<td><p>Return whether the function is strictly decreasing in the given interval.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_strictly_increasing</span></code>(expression[, ...])</p></td>
<td><p>Return whether the function is strictly increasing in the given interval.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_zero_dimensional</span></code>(F, *gens, **args)</p></td>
<td><p>Checks if the ideal generated by a Groebner basis is zero-dimensional.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">isolate</span></code>(alg[, eps, fast])</p></td>
<td><p>Find a rational isolating interval for a real algebraic number.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">isprime</span></code>(n)</p></td>
<td><p>Test if n is a prime number (True) or not (False).</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">itermonomials</span></code>(variables, max_degrees[, ...])</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">max_degrees</span></code> and <code class="docutils literal notranslate"><span class="pre">min_degrees</span></code> are either both integers or both lists.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">jacobi_normalized</span></code>(n, a, b, x)</p></td>
<td><p>Jacobi polynomial $P_n^{left(alpha, betaright)}(x)$.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">jacobi_poly</span></code>(n, a, b[, x, polys])</p></td>
<td><p>Generates the Jacobi polynomial <cite>P_n^{(a,b)}(x)</cite>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">jacobi_symbol</span></code>(m, n)</p></td>
<td><p>Returns the Jacobi symbol <cite>(m / n)</cite>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">jn_zeros</span></code>(n, k[, method, dps])</p></td>
<td><p>Zeros of the spherical Bessel function of the first kind.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">jordan_cell</span></code>(eigenval, n)</p></td>
<td><p>Create a Jordan block:</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">jscode</span></code>(expr[, assign_to])</p></td>
<td><p>Converts an expr to a string of javascript code</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">julia_code</span></code>(expr[, assign_to])</p></td>
<td><p>Converts <cite>expr</cite> to a string of Julia code.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">kronecker_product</span></code>(*matrices)</p></td>
<td><p>The Kronecker product of two or more arguments.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">kroneckersimp</span></code>(expr)</p></td>
<td><p>Simplify expressions with KroneckerDelta.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">laguerre_poly</span></code>(n[, x, alpha, polys])</p></td>
<td><p>Generates the Laguerre polynomial <cite>L_n^{(alpha)}(x)</cite>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">lambdify</span></code>(args, expr[, modules, printer, ...])</p></td>
<td><p>Convert a SymPy expression into a function that allows for fast numeric evaluation.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">laplace_transform</span></code>(f, t, s[, legacy_matrix])</p></td>
<td><p>Compute the Laplace Transform <cite>F(s)</cite> of <cite>f(t)</cite>,</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">lcm</span></code>(f[, g])</p></td>
<td><p>Compute LCM of <code class="docutils literal notranslate"><span class="pre">f</span></code> and <code class="docutils literal notranslate"><span class="pre">g</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">lcm_list</span></code>(seq, *gens, **args)</p></td>
<td><p>Compute LCM of a list of polynomials.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">legendre_poly</span></code>(n[, x, polys])</p></td>
<td><p>Generates the Legendre polynomial <cite>P_n(x)</cite>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">legendre_symbol</span></code>(a, p)</p></td>
<td><p>Returns the Legendre symbol <cite>(a / p)</cite>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">limit</span></code>(e, z, z0[, dir])</p></td>
<td><p>Computes the limit of <code class="docutils literal notranslate"><span class="pre">e(z)</span></code> at the point <code class="docutils literal notranslate"><span class="pre">z0</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">limit_seq</span></code>(expr[, n, trials])</p></td>
<td><p>Finds the limit of a sequence as index <code class="docutils literal notranslate"><span class="pre">n</span></code> tends to infinity.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">line_integrate</span></code>(field, Curve, variables)</p></td>
<td><p>Compute the line integral.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">linear_eq_to_matrix</span></code>(equations, *symbols)</p></td>
<td><p>Converts a given System of Equations into Matrix form.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">linsolve</span></code>(system, *symbols)</p></td>
<td><p>Solve system of $N$ linear equations with $M$ variables; both underdetermined and overdetermined systems are supported.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">list2numpy</span></code>(l[, dtype])</p></td>
<td><p>Converts Python list of SymPy expressions to a NumPy array.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">logcombine</span></code>(expr[, force])</p></td>
<td><p>Takes logarithms and combines them using the following rules:</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">maple_code</span></code>(expr[, assign_to])</p></td>
<td><p>Converts <code class="docutils literal notranslate"><span class="pre">expr</span></code> to a string of Maple code.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">mathematica_code</span></code>(expr, **settings)</p></td>
<td><p>Converts an expr to a string of the Wolfram Mathematica code</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">matrix2numpy</span></code>(m[, dtype])</p></td>
<td><p>Converts SymPy's matrix to a NumPy array.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">matrix_multiply_elementwise</span></code>(A, B)</p></td>
<td><p>Return the Hadamard product (elementwise product) of A and B</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">matrix_symbols</span></code>(expr)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">maximum</span></code>(f, symbol[, domain])</p></td>
<td><p>Returns the maximum value of a function in the given domain.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">mellin_transform</span></code>(f, x, s, **hints)</p></td>
<td><p>Compute the Mellin transform <cite>F(s)</cite> of <cite>f(x)</cite>,</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">memoize_property</span></code>(propfunc)</p></td>
<td><p>Property decorator that caches the value of potentially expensive <cite>propfunc</cite> after the first evaluation.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">mersenne_prime_exponent</span></code>(nth)</p></td>
<td><p>Returns the exponent <code class="docutils literal notranslate"><span class="pre">i</span></code> for the nth Mersenne prime (which has the form <cite>2^i - 1</cite>).</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">minimal_polynomial</span></code>(ex[, x, compose, polys, ...])</p></td>
<td><p>Computes the minimal polynomial of an algebraic element.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">minimum</span></code>(f, symbol[, domain])</p></td>
<td><p>Returns the minimum value of a function in the given domain.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">minpoly</span></code>(ex[, x, compose, polys, domain])</p></td>
<td><p>This is a synonym for <code class="xref py py-func docutils literal notranslate"><span class="pre">minimal_polynomial()</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">mobius_transform</span></code>(seq[, subset])</p></td>
<td><p>Performs the Mobius Transform for subset lattice with indices of sequence as bitmasks.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">mod_inverse</span></code>(a, m)</p></td>
<td><p>Return the number $c$ such that, $a times c = 1 pmod{m}$ where $c$ has the same sign as $m$.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">monic</span></code>(f, *gens, **args)</p></td>
<td><p>Divide all coefficients of <code class="docutils literal notranslate"><span class="pre">f</span></code> by <code class="docutils literal notranslate"><span class="pre">LC(f)</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">multiline_latex</span></code>(lhs, rhs[, terms_per_line, ...])</p></td>
<td><p>This function generates a LaTeX equation with a multiline right-hand side in an <code class="docutils literal notranslate"><span class="pre">align*</span></code>, <code class="docutils literal notranslate"><span class="pre">eqnarray</span></code> or <code class="docutils literal notranslate"><span class="pre">IEEEeqnarray</span></code> environment.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">multinomial_coefficients</span></code>(m, n)</p></td>
<td><p>Return a dictionary containing pairs <code class="docutils literal notranslate"><span class="pre">{(k1,k2,..,km)</span> <span class="pre">:</span> <span class="pre">C_kn}</span></code> where <code class="docutils literal notranslate"><span class="pre">C_kn</span></code> are multinomial coefficients such that <code class="docutils literal notranslate"><span class="pre">n=k1+k2+..+km</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">multiplicity</span></code>(p, n)</p></td>
<td><p>Find the greatest integer m such that p**m divides n.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">n_order</span></code>(a, n)</p></td>
<td><p>Returns the order of <code class="docutils literal notranslate"><span class="pre">a</span></code> modulo <code class="docutils literal notranslate"><span class="pre">n</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">nextprime</span></code>(n[, ith])</p></td>
<td><p>Return the ith prime greater than n.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">nfloat</span></code>(expr[, n, exponent, dkeys])</p></td>
<td><p>Make all Rationals in expr Floats except those in exponents (unless the exponents flag is set to True) and those in undefined functions.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">nonlinsolve</span></code>(system, *symbols)</p></td>
<td><p>Solve system of $N$ nonlinear equations with $M$ variables, which means both under and overdetermined systems are supported.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">not_empty_in</span></code>(finset_intersection, *syms)</p></td>
<td><p>Finds the domain of the functions in <code class="docutils literal notranslate"><span class="pre">finset_intersection</span></code> in which the <code class="docutils literal notranslate"><span class="pre">finite_set</span></code> is not-empty.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">npartitions</span></code>(n[, verbose])</p></td>
<td><p>Calculate the partition function P(n), i.e. the number of ways that n can be written as a sum of positive integers.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">nroots</span></code>(f[, n, maxsteps, cleanup])</p></td>
<td><p>Compute numerical approximations of roots of <code class="docutils literal notranslate"><span class="pre">f</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">nsimplify</span></code>(expr[, constants, tolerance, ...])</p></td>
<td><p>Find a simple representation for a number or, if there are free symbols or if <code class="docutils literal notranslate"><span class="pre">rational=True</span></code>, then replace Floats with their Rational equivalents.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">nsolve</span></code>(*args[, dict])</p></td>
<td><p>Solve a nonlinear equation system numerically: <code class="docutils literal notranslate"><span class="pre">nsolve(f,</span> <span class="pre">[args,]</span> <span class="pre">x0,</span> <span class="pre">modules=['mpmath'],</span> <span class="pre">**kwargs)</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">nth_power_roots_poly</span></code>(f, n, *gens, **args)</p></td>
<td><p>Construct a polynomial with n-th powers of roots of <code class="docutils literal notranslate"><span class="pre">f</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">nthroot_mod</span></code>(a, n, p[, all_roots])</p></td>
<td><p>Find the solutions to <code class="docutils literal notranslate"><span class="pre">x**n</span> <span class="pre">=</span> <span class="pre">a</span> <span class="pre">mod</span> <span class="pre">p</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">ntt</span></code>(seq, prime)</p></td>
<td><p>Performs the Number Theoretic Transform (<strong>NTT</strong>), which specializes the Discrete Fourier Transform (<strong>DFT</strong>) over quotient ring <cite>Z/pZ</cite> for prime <cite>p</cite> instead of complex numbers <cite>C</cite>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">numbered_symbols</span></code>([prefix, cls, start, exclude])</p></td>
<td><p>Generate an infinite stream of Symbols consisting of a prefix and increasing subscripts provided that they do not occur in <code class="docutils literal notranslate"><span class="pre">exclude</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">numer</span></code>(expr)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">octave_code</span></code>(expr[, assign_to])</p></td>
<td><p>Converts <cite>expr</cite> to a string of Octave (or Matlab) code.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">ode_order</span></code>(expr, func)</p></td>
<td><p>Returns the order of a given differential equation with respect to func.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">ones</span></code>(*args, **kwargs)</p></td>
<td><p>Returns a matrix of ones with <code class="docutils literal notranslate"><span class="pre">rows</span></code> rows and <code class="docutils literal notranslate"><span class="pre">cols</span></code> columns; if <code class="docutils literal notranslate"><span class="pre">cols</span></code> is omitted a square matrix will be returned.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">ordered</span></code>(seq[, keys, default, warn])</p></td>
<td><p>Return an iterator of the seq where keys are used to break ties in a conservative fashion: if, after applying a key, there are no ties then no other keys will be computed.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">pager_print</span></code>(expr, **settings)</p></td>
<td><p>Prints expr using the pager, in pretty form.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">parallel_poly_from_expr</span></code>(exprs, *gens, **args)</p></td>
<td><p>Construct polynomials from expressions.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">parse_expr</span></code>(s[, local_dict, transformations, ...])</p></td>
<td><p>Converts the string <code class="docutils literal notranslate"><span class="pre">s</span></code> to a SymPy expression, in <code class="docutils literal notranslate"><span class="pre">local_dict</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">pde_separate</span></code>(eq, fun, sep[, strategy])</p></td>
<td><p>Separate variables in partial differential equation either by additive or multiplicative separation approach.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">pde_separate_add</span></code>(eq, fun, sep)</p></td>
<td><p>Helper function for searching additive separable solutions.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">pde_separate_mul</span></code>(eq, fun, sep)</p></td>
<td><p>Helper function for searching multiplicative separable solutions.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">pdiv</span></code>(f, g, *gens, **args)</p></td>
<td><p>Compute polynomial pseudo-division of <code class="docutils literal notranslate"><span class="pre">f</span></code> and <code class="docutils literal notranslate"><span class="pre">g</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">pdsolve</span></code>(eq[, func, hint, dict, solvefun])</p></td>
<td><p>Solves any (supported) kind of partial differential equation.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">per</span></code>(matexpr)</p></td>
<td><p>Matrix Permanent</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">perfect_power</span></code>(n[, candidates, big, factor])</p></td>
<td><p>Return <code class="docutils literal notranslate"><span class="pre">(b,</span> <span class="pre">e)</span></code> such that <code class="docutils literal notranslate"><span class="pre">n</span></code> == <code class="docutils literal notranslate"><span class="pre">b**e</span></code> if <code class="docutils literal notranslate"><span class="pre">n</span></code> is a unique perfect power with <code class="docutils literal notranslate"><span class="pre">e</span> <span class="pre">&gt;</span> <span class="pre">1</span></code>, else <code class="docutils literal notranslate"><span class="pre">False</span></code> (e.g. 1 is not a perfect power).</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">periodicity</span></code>(f, symbol[, check])</p></td>
<td><p>Tests the given function for periodicity in the given symbol.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">permutedims</span></code>(expr[, perm, index_order_old, ...])</p></td>
<td><p>Permutes the indices of an array.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">pexquo</span></code>(f, g, *gens, **args)</p></td>
<td><p>Compute polynomial exact pseudo-quotient of <code class="docutils literal notranslate"><span class="pre">f</span></code> and <code class="docutils literal notranslate"><span class="pre">g</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">piecewise_exclusive</span></code>(expr, *[, skip_nan, deep])</p></td>
<td><p>Rewrite <code class="xref py py-class docutils literal notranslate"><span class="pre">Piecewise</span></code> with mutually exclusive conditions.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">piecewise_fold</span></code>(expr[, evaluate])</p></td>
<td><p>Takes an expression containing a piecewise function and returns the expression in piecewise form.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot</span></code>(*args[, show])</p></td>
<td><p>Plots a function of a single variable as a curve.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_implicit</span></code>(expr[, x_var, y_var, ...])</p></td>
<td><p>A plot function to plot implicit equations / inequalities.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_parametric</span></code>(*args[, show])</p></td>
<td><p>Plots a 2D parametric curve.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">polarify</span></code>(eq[, subs, lift])</p></td>
<td><p>Turn all numbers in eq into their polar equivalents (under the standard choice of argument).</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">pollard_pm1</span></code>(n[, B, a, retries, seed])</p></td>
<td><p>Use Pollard's p-1 method to try to extract a nontrivial factor of <code class="docutils literal notranslate"><span class="pre">n</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">pollard_rho</span></code>(n[, s, a, retries, seed, ...])</p></td>
<td><p>Use Pollard's rho method to try to extract a nontrivial factor of <code class="docutils literal notranslate"><span class="pre">n</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">poly</span></code>(expr, *gens, **args)</p></td>
<td><p>Efficiently transform an expression into a polynomial.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">poly_from_expr</span></code>(expr, *gens, **args)</p></td>
<td><p>Construct a polynomial from an expression.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">posify</span></code>(eq)</p></td>
<td><p>Return <code class="docutils literal notranslate"><span class="pre">eq</span></code> (with generic symbols made positive) and a dictionary containing the mapping between the old and new symbols.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">postfixes</span></code>(seq)</p></td>
<td><p>Generate all postfixes of a sequence.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">postorder_traversal</span></code>(node[, keys])</p></td>
<td><p>Do a postorder traversal of a tree.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">powdenest</span></code>(eq[, force, polar])</p></td>
<td><p>Collect exponents on powers as assumptions allow.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">powsimp</span></code>(expr[, deep, combine, force, measure])</p></td>
<td><p>Reduce expression by combining powers with similar bases and exponents.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">pprint</span></code>(expr, **kwargs)</p></td>
<td><p>Prints expr in pretty form.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">pprint_try_use_unicode</span></code>()</p></td>
<td><p>See if unicode output is available and leverage it if possible</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">pprint_use_unicode</span></code>([flag])</p></td>
<td><p>Set whether pretty-printer should use unicode by default</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">pquo</span></code>(f, g, *gens, **args)</p></td>
<td><p>Compute polynomial pseudo-quotient of <code class="docutils literal notranslate"><span class="pre">f</span></code> and <code class="docutils literal notranslate"><span class="pre">g</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">prefixes</span></code>(seq)</p></td>
<td><p>Generate all prefixes of a sequence.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">prem</span></code>(f, g, *gens, **args)</p></td>
<td><p>Compute polynomial pseudo-remainder of <code class="docutils literal notranslate"><span class="pre">f</span></code> and <code class="docutils literal notranslate"><span class="pre">g</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">pretty_print</span></code>(expr, **kwargs)</p></td>
<td><p>Prints expr in pretty form.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">preview</span></code>(expr[, output, viewer, euler, ...])</p></td>
<td><p>View expression or LaTeX markup in PNG, DVI, PostScript or PDF form.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">prevprime</span></code>(n)</p></td>
<td><p>Return the largest prime smaller than n.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">prime</span></code>(nth)</p></td>
<td><p>Return the nth prime, with the primes indexed as prime(1) = 2, prime(2) = 3, etc.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">prime_decomp</span></code>(p[, T, ZK, dK, radical])</p></td>
<td><p>Compute the decomposition of rational prime <em>p</em> in a number field.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">prime_valuation</span></code>(I, P)</p></td>
<td><p>Compute the <em>P</em>-adic valuation for an integral ideal <em>I</em>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">primefactors</span></code>(n[, limit, verbose])</p></td>
<td><p>Return a sorted list of n's prime factors, ignoring multiplicity and any composite factor that remains if the limit was set too low for complete factorization.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">primerange</span></code>(a[, b])</p></td>
<td><p>Generate a list of all prime numbers in the range [2, a), or [a, b).</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">primitive</span></code>(f, *gens, **args)</p></td>
<td><p>Compute content and the primitive form of <code class="docutils literal notranslate"><span class="pre">f</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">primitive_element</span></code>(extension[, x, ex, polys])</p></td>
<td><p>Find a single generator for a number field given by several generators.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">primitive_root</span></code>(p)</p></td>
<td><p>Returns the smallest primitive root or None.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">primorial</span></code>(n[, nth])</p></td>
<td><p>Returns the product of the first n primes (default) or the primes less than or equal to n (when <code class="docutils literal notranslate"><span class="pre">nth=False</span></code>).</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">print_ccode</span></code>(expr, **settings)</p></td>
<td><p>Prints C representation of the given expression.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">print_fcode</span></code>(expr, **settings)</p></td>
<td><p>Prints the Fortran representation of the given expression.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">print_glsl</span></code>(expr, **settings)</p></td>
<td><p>Prints the GLSL representation of the given expression.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">print_gtk</span></code>(x[, start_viewer])</p></td>
<td><p>Print to Gtkmathview, a gtk widget capable of rendering MathML.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">print_jscode</span></code>(expr, **settings)</p></td>
<td><p>Prints the Javascript representation of the given expression.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">print_latex</span></code>(expr, **settings)</p></td>
<td><p>Prints LaTeX representation of the given expression.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">print_maple_code</span></code>(expr, **settings)</p></td>
<td><p>Prints the Maple representation of the given expression.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">print_mathml</span></code>(expr[, printer])</p></td>
<td><p>Prints a pretty representation of the MathML code for expr.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">print_python</span></code>(expr, **settings)</p></td>
<td><p>Print output of python() function</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">print_rcode</span></code>(expr, **settings)</p></td>
<td><p>Prints R representation of the given expression.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">print_tree</span></code>(node[, assumptions])</p></td>
<td><p>Prints a tree representation of &quot;node&quot;.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">prod</span></code>(a[, start])</p></td>
<td><p>Return product of elements of a. Start with int 1 so if only</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">product</span></code>(*args, **kwargs)</p></td>
<td><p>Compute the product.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">proper_divisor_count</span></code>(n[, modulus])</p></td>
<td><p>Return the number of proper divisors of <code class="docutils literal notranslate"><span class="pre">n</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">proper_divisors</span></code>(n[, generator])</p></td>
<td><p>Return all divisors of n except n, sorted by default.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">public</span></code>(obj)</p></td>
<td><p>Append <code class="docutils literal notranslate"><span class="pre">obj</span></code>'s name to global <code class="docutils literal notranslate"><span class="pre">__all__</span></code> variable (call site).</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">pycode</span></code>(expr, **settings)</p></td>
<td><p>Converts an expr to a string of Python code</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">python</span></code>(expr, **settings)</p></td>
<td><p>Return Python interpretation of passed expression (can be passed to the exec() function without any modifications)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">quadratic_congruence</span></code>(a, b, c, p)</p></td>
<td><p>Find the solutions to <a href="#id3"><span class="problematic" id="id4">``</span></a>a x**2 + b x + c = 0 mod p.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">quadratic_residues</span></code>(p)</p></td>
<td><p>Returns the list of quadratic residues.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">quo</span></code>(f, g, *gens, **args)</p></td>
<td><p>Compute polynomial quotient of <code class="docutils literal notranslate"><span class="pre">f</span></code> and <code class="docutils literal notranslate"><span class="pre">g</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">rad</span></code>(d)</p></td>
<td><p>Return the radian value for the given degrees (pi = 180 degrees).</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">radsimp</span></code>(expr[, symbolic, max_terms])</p></td>
<td><p>Rationalize the denominator by removing square roots.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">randMatrix</span></code>(r[, c, min, max, seed, ...])</p></td>
<td><p>Create random matrix with dimensions <code class="docutils literal notranslate"><span class="pre">r</span></code> x <code class="docutils literal notranslate"><span class="pre">c</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">random_poly</span></code>(x, n, inf, sup[, domain, polys])</p></td>
<td><p>Generates a polynomial of degree <code class="docutils literal notranslate"><span class="pre">n</span></code> with coefficients in <code class="docutils literal notranslate"><span class="pre">[inf,</span> <span class="pre">sup]</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">randprime</span></code>(a, b)</p></td>
<td><p>Return a random prime number in the range [a, b).</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">rational_interpolate</span></code>(data, degnum[, X])</p></td>
<td><p>Returns a rational interpolation, where the data points are element of any integral domain.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">ratsimp</span></code>(expr)</p></td>
<td><p>Put an expression over a common denominator, cancel and reduce.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">ratsimpmodprime</span></code>(expr, G, *gens[, quick, ...])</p></td>
<td><p>Simplifies a rational expression <code class="docutils literal notranslate"><span class="pre">expr</span></code> modulo the prime ideal generated by <code class="docutils literal notranslate"><span class="pre">G</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">rcode</span></code>(expr[, assign_to])</p></td>
<td><p>Converts an expr to a string of r code</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">rcollect</span></code>(expr, *vars)</p></td>
<td><p>Recursively collect sums in an expression.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">real_root</span></code>(arg[, n, evaluate])</p></td>
<td><p>Return the real <em>n</em>'th-root of <em>arg</em> if possible.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">real_roots</span></code>(f[, multiple])</p></td>
<td><p>Return a list of real roots with multiplicities of <code class="docutils literal notranslate"><span class="pre">f</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">reduce_abs_inequalities</span></code>(exprs, gen)</p></td>
<td><p>Reduce a system of inequalities with nested absolute values.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">reduce_abs_inequality</span></code>(expr, rel, gen)</p></td>
<td><p>Reduce an inequality with nested absolute values.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">reduce_inequalities</span></code>(inequalities[, symbols])</p></td>
<td><p>Reduce a system of inequalities with rational coefficients.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">reduced</span></code>(f, G, *gens, **args)</p></td>
<td><p>Reduces a polynomial <code class="docutils literal notranslate"><span class="pre">f</span></code> modulo a set of polynomials <code class="docutils literal notranslate"><span class="pre">G</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">refine</span></code>(expr[, assumptions])</p></td>
<td><p>Simplify an expression using assumptions.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">refine_root</span></code>(f, s, t[, eps, steps, fast, ...])</p></td>
<td><p>Refine an isolating interval of a root to the given precision.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">register_handler</span></code>(key, handler)</p></td>
<td><p>Register a handler in the ask system.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">rem</span></code>(f, g, *gens, **args)</p></td>
<td><p>Compute polynomial remainder of <code class="docutils literal notranslate"><span class="pre">f</span></code> and <code class="docutils literal notranslate"><span class="pre">g</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_handler</span></code>(key, handler)</p></td>
<td><p>Removes a handler from the ask system.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">reshape</span></code>(seq, how)</p></td>
<td><p>Reshape the sequence according to the template in <code class="docutils literal notranslate"><span class="pre">how</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">residue</span></code>(expr, x, x0)</p></td>
<td><p>Finds the residue of <code class="docutils literal notranslate"><span class="pre">expr</span></code> at the point x=x0.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">resultant</span></code>(f, g, *gens[, includePRS])</p></td>
<td><p>Compute resultant of <code class="docutils literal notranslate"><span class="pre">f</span></code> and <code class="docutils literal notranslate"><span class="pre">g</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">ring</span></code>(symbols, domain[, order])</p></td>
<td><p>Construct a polynomial ring returning <code class="docutils literal notranslate"><span class="pre">(ring,</span> <span class="pre">x_1,</span> <span class="pre">...,</span> <span class="pre">x_n)</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">root</span></code>(arg, n[, k, evaluate])</p></td>
<td><p>Returns the <em>k</em>-th <em>n</em>-th root of <code class="docutils literal notranslate"><span class="pre">arg</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">rootof</span></code>(f, x[, index, radicals, expand])</p></td>
<td><p>An indexed root of a univariate polynomial.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">roots</span></code>(f, *gens[, auto, cubics, trig, ...])</p></td>
<td><p>Computes symbolic roots of a univariate polynomial.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">rot_axis1</span></code>(theta)</p></td>
<td><p>Returns a rotation matrix for a rotation of theta (in radians) about the 1-axis.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">rot_axis2</span></code>(theta)</p></td>
<td><p>Returns a rotation matrix for a rotation of theta (in radians) about the 2-axis.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">rot_axis3</span></code>(theta)</p></td>
<td><p>Returns a rotation matrix for a rotation of theta (in radians) about the 3-axis.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">rot_ccw_axis1</span></code>(theta)</p></td>
<td><p>Returns a rotation matrix for a rotation of theta (in radians) about the 1-axis.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">rot_ccw_axis2</span></code>(theta)</p></td>
<td><p>Returns a rotation matrix for a rotation of theta (in radians) about the 2-axis.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">rot_ccw_axis3</span></code>(theta)</p></td>
<td><p>Returns a rotation matrix for a rotation of theta (in radians) about the 3-axis.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">rot_givens</span></code>(i, j, theta[, dim])</p></td>
<td><p>Returns a a Givens rotation matrix, a a rotation in the plane spanned by two coordinates axes.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">rotations</span></code>(s[, dir])</p></td>
<td><p>Return a generator giving the items in s as list where each subsequent list has the items rotated to the left (default) or right (<code class="docutils literal notranslate"><span class="pre">dir=-1</span></code>) relative to the previous list.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">round_two</span></code>(T[, radicals])</p></td>
<td><p>Zassenhaus's &quot;Round 2&quot; algorithm.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">rsolve</span></code>(f, y[, init])</p></td>
<td><p>Solve univariate recurrence with rational coefficients.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">rsolve_hyper</span></code>(coeffs, f, n, **hints)</p></td>
<td><p>Given linear recurrence operator <cite>operatorname{L}</cite> of order <cite>k</cite> with polynomial coefficients and inhomogeneous equation <cite>operatorname{L} y = f</cite> we seek for all hypergeometric solutions over field <cite>K</cite> of characteristic zero.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">rsolve_poly</span></code>(coeffs, f, n[, shift])</p></td>
<td><p>Given linear recurrence operator <cite>operatorname{L}</cite> of order <cite>k</cite> with polynomial coefficients and inhomogeneous equation <cite>operatorname{L} y = f</cite>, where <cite>f</cite> is a polynomial, we seek for all polynomial solutions over field <cite>K</cite> of characteristic zero.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">rsolve_ratio</span></code>(coeffs, f, n, **hints)</p></td>
<td><p>Given linear recurrence operator <cite>operatorname{L}</cite> of order <cite>k</cite> with polynomial coefficients and inhomogeneous equation <cite>operatorname{L} y = f</cite>, where <cite>f</cite> is a polynomial, we seek for all rational solutions over field <cite>K</cite> of characteristic zero.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">rust_code</span></code>(expr[, assign_to])</p></td>
<td><p>Converts an expr to a string of Rust code</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">satisfiable</span></code>(expr[, algorithm, all_models, ...])</p></td>
<td><p>Check satisfiability of a propositional sentence.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">separatevars</span></code>(expr[, symbols, dict, force])</p></td>
<td><p>Separates variables in an expression, if possible.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">sequence</span></code>(seq[, limits])</p></td>
<td><p>Returns appropriate sequence object.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">series</span></code>(expr[, x, x0, n, dir])</p></td>
<td><p>Series expansion of expr around point <cite>x = x0</cite>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">seterr</span></code>([divide])</p></td>
<td><p>Should SymPy raise an exception on 0/0 or return a nan?</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">sfield</span></code>(exprs, *symbols, **options)</p></td>
<td><p>Construct a field deriving generators and domain from options and input expressions.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">shape</span></code>()</p></td>
<td><p>Return the shape of the <em>expr</em> as a tuple.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">sift</span></code>(seq, keyfunc[, binary])</p></td>
<td><p>Sift the sequence, <code class="docutils literal notranslate"><span class="pre">seq</span></code> according to <code class="docutils literal notranslate"><span class="pre">keyfunc</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">signsimp</span></code>(expr[, evaluate])</p></td>
<td><p>Make all Add sub-expressions canonical wrt sign.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">simplify</span></code>(expr[, ratio, measure, rational, ...])</p></td>
<td><p>Simplifies the given expression.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">simplify_logic</span></code>(expr[, form, deep, force, ...])</p></td>
<td><p>This function simplifies a boolean function to its simplified version in SOP or POS form.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">sine_transform</span></code>(f, x, k, **hints)</p></td>
<td><p>Compute the unitary, ordinary-frequency sine transform of <cite>f</cite>, defined as</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">singularities</span></code>(expression, symbol[, domain])</p></td>
<td><p>Find singularities of a given function.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">singularityintegrate</span></code>(f, x)</p></td>
<td><p>This function handles the indefinite integrations of Singularity functions.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">smtlib_code</span></code>(expr[, auto_assert, ...])</p></td>
<td><p>Converts <code class="docutils literal notranslate"><span class="pre">expr</span></code> to a string of smtlib code.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">solve</span></code>(f, *symbols, **flags)</p></td>
<td><p>Algebraically solves equations and systems of equations.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">solve_linear</span></code>(lhs[, rhs, symbols, exclude])</p></td>
<td><p>Return a tuple derived from <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">=</span> <span class="pre">lhs</span> <span class="pre">-</span> <span class="pre">rhs</span></code> that is one of the following: <code class="docutils literal notranslate"><span class="pre">(0,</span> <span class="pre">1)</span></code>, <code class="docutils literal notranslate"><span class="pre">(0,</span> <span class="pre">0)</span></code>, <code class="docutils literal notranslate"><span class="pre">(symbol,</span> <span class="pre">solution)</span></code>, <code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">d)</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">solve_linear_system</span></code>(system, *symbols, **flags)</p></td>
<td><p>Solve system of $N$ linear equations with $M$ variables, which means both under- and overdetermined systems are supported.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">solve_linear_system_LU</span></code>(matrix, syms)</p></td>
<td><p>Solves the augmented matrix system using <code class="docutils literal notranslate"><span class="pre">LUsolve</span></code> and returns a dictionary in which solutions are keyed to the symbols of <em>syms</em> as ordered.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">solve_poly_inequality</span></code>(poly, rel)</p></td>
<td><p>Solve a polynomial inequality with rational coefficients.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">solve_poly_system</span></code>(seq, *gens[, strict])</p></td>
<td><p>Return a list of solutions for the system of polynomial equations or else None.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">solve_rational_inequalities</span></code>(eqs)</p></td>
<td><p>Solve a system of rational inequalities with rational coefficients.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">solve_triangulated</span></code>(polys, *gens, **args)</p></td>
<td><p>Solve a polynomial system using Gianni-Kalkbrenner algorithm.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">solve_undetermined_coeffs</span></code>(equ, coeffs, ...)</p></td>
<td><p>Solve a system of equations in $k$ parameters that is formed by matching coefficients in variables <code class="docutils literal notranslate"><span class="pre">coeffs</span></code> that are on factors dependent on the remaining variables (or those given explicitly by <code class="docutils literal notranslate"><span class="pre">syms</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">solve_univariate_inequality</span></code>(expr, gen[, ...])</p></td>
<td><p>Solves a real univariate inequality.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">solveset</span></code>(f[, symbol, domain])</p></td>
<td><p>Solves a given inequality or equation with set as output</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">sqf</span></code>(f, *gens, **args)</p></td>
<td><p>Compute square-free factorization of <code class="docutils literal notranslate"><span class="pre">f</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">sqf_list</span></code>(f, *gens, **args)</p></td>
<td><p>Compute a list of square-free factors of <code class="docutils literal notranslate"><span class="pre">f</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">sqf_norm</span></code>(f, *gens, **args)</p></td>
<td><p>Compute square-free norm of <code class="docutils literal notranslate"><span class="pre">f</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">sqf_part</span></code>(f, *gens, **args)</p></td>
<td><p>Compute square-free part of <code class="docutils literal notranslate"><span class="pre">f</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">sqrt</span></code>(arg[, evaluate])</p></td>
<td><p>Returns the principal square root.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">sqrt_mod</span></code>(a, p[, all_roots])</p></td>
<td><p>Find a root of <code class="docutils literal notranslate"><span class="pre">x**2</span> <span class="pre">=</span> <span class="pre">a</span> <span class="pre">mod</span> <span class="pre">p</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">sqrt_mod_iter</span></code>(a, p[, domain])</p></td>
<td><p>Iterate over solutions to <code class="docutils literal notranslate"><span class="pre">x**2</span> <span class="pre">=</span> <span class="pre">a</span> <span class="pre">mod</span> <span class="pre">p</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">sqrtdenest</span></code>(expr[, max_iter])</p></td>
<td><p>Denests sqrts in an expression that contain other square roots if possible, otherwise returns the expr unchanged.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">sring</span></code>(exprs, *symbols, **options)</p></td>
<td><p>Construct a ring deriving generators and domain from options and input expressions.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">stationary_points</span></code>(f, symbol[, domain])</p></td>
<td><p>Returns the stationary points of a function (where derivative of the function is 0) in the given domain.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">sturm</span></code>(f, *gens, **args)</p></td>
<td><p>Compute Sturm sequence of <code class="docutils literal notranslate"><span class="pre">f</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">subresultants</span></code>(f, g, *gens, **args)</p></td>
<td><p>Compute subresultant PRS of <code class="docutils literal notranslate"><span class="pre">f</span></code> and <code class="docutils literal notranslate"><span class="pre">g</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">subsets</span></code>(seq[, k, repetition])</p></td>
<td><p>Generates all <cite>k</cite>-subsets (combinations) from an <cite>n</cite>-element set, <code class="docutils literal notranslate"><span class="pre">seq</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">substitution</span></code>(system, symbols[, result, ...])</p></td>
<td><p>Solves the <cite>system</cite> using substitution method.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">summation</span></code>(f, *symbols, **kwargs)</p></td>
<td><p>Compute the summation of f with respect to symbols.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">swinnerton_dyer_poly</span></code>(n[, x, polys])</p></td>
<td><p>Generates n-th Swinnerton-Dyer polynomial in <cite>x</cite>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">symarray</span></code>(prefix, shape, **kwargs)</p></td>
<td><p>Create a numpy ndarray of symbols (as an object array).</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">symbols</span></code>(names, *[, cls])</p></td>
<td><p>Transform strings into instances of <code class="xref py py-class docutils literal notranslate"><span class="pre">Symbol</span></code> class.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">symmetric_poly</span></code>(n, *gens[, polys])</p></td>
<td><p>Generates symmetric polynomial of order <cite>n</cite>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">symmetrize</span></code>(F, *gens, **args)</p></td>
<td><p>Rewrite a polynomial in terms of elementary symmetric polynomials.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">sympify</span></code>(a[, locals, convert_xor, strict, ...])</p></td>
<td><p>Converts an arbitrary expression to a type that can be used inside SymPy.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">take</span></code>(iter, n)</p></td>
<td><p>Return <code class="docutils literal notranslate"><span class="pre">n</span></code> items from <code class="docutils literal notranslate"><span class="pre">iter</span></code> iterator.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">tensorcontraction</span></code>(array, *contraction_axes)</p></td>
<td><p>Contraction of an array-like object on the specified axes.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">tensordiagonal</span></code>(array, *diagonal_axes)</p></td>
<td><p>Diagonalization of an array-like object on the specified axes.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">tensorproduct</span></code>(*args)</p></td>
<td><p>Tensor product among scalars or array-like objects.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">terms_gcd</span></code>(f, *gens, **args)</p></td>
<td><p>Remove GCD of terms from <code class="docutils literal notranslate"><span class="pre">f</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">textplot</span></code>(expr, a, b[, W, H])</p></td>
<td><p>Print a crude ASCII art plot of the SymPy expression 'expr' (which should contain a single symbol, e.g. x or something else) over the interval [a, b].</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">threaded</span></code>(func)</p></td>
<td><p>Apply <code class="docutils literal notranslate"><span class="pre">func</span></code> to sub--elements of an object, including <code class="xref py py-class docutils literal notranslate"><span class="pre">Add</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">timed</span></code>(func[, setup, limit])</p></td>
<td><p>Adaptively measure execution time of a function.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_cnf</span></code>(expr[, simplify, force])</p></td>
<td><p>Convert a propositional logical sentence <code class="docutils literal notranslate"><span class="pre">expr</span></code> to conjunctive normal form: <code class="docutils literal notranslate"><span class="pre">((A</span> <span class="pre">|</span> <span class="pre">~B</span> <span class="pre">|</span> <span class="pre">...)</span> <span class="pre">&amp;</span> <span class="pre">(B</span> <span class="pre">|</span> <span class="pre">C</span> <span class="pre">|</span> <span class="pre">...)</span> <span class="pre">&amp;</span> <span class="pre">...)</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_dnf</span></code>(expr[, simplify, force])</p></td>
<td><p>Convert a propositional logical sentence <code class="docutils literal notranslate"><span class="pre">expr</span></code> to disjunctive normal form: <code class="docutils literal notranslate"><span class="pre">((A</span> <span class="pre">&amp;</span> <span class="pre">~B</span> <span class="pre">&amp;</span> <span class="pre">...)</span> <span class="pre">|</span> <span class="pre">(B</span> <span class="pre">&amp;</span> <span class="pre">C</span> <span class="pre">&amp;</span> <span class="pre">...)</span> <span class="pre">|</span> <span class="pre">...)</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_nnf</span></code>(expr[, simplify])</p></td>
<td><p>Converts <code class="docutils literal notranslate"><span class="pre">expr</span></code> to Negation Normal Form (NNF).</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_number_field</span></code>(extension[, theta, gen, alias])</p></td>
<td><p>Express one algebraic number in the field generated by another.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">together</span></code>(expr[, deep, fraction])</p></td>
<td><p>Denest and combine rational expressions using symbolic methods.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">topological_sort</span></code>(graph[, key])</p></td>
<td><p>Topological sort of graph's vertices.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">total_degree</span></code>(f, *gens)</p></td>
<td><p>Return the total_degree of <code class="docutils literal notranslate"><span class="pre">f</span></code> in the given variables.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">trace</span></code>(expr)</p></td>
<td><p>Trace of a Matrix.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">trailing</span></code>(n)</p></td>
<td><p>Count the number of trailing zero digits in the binary representation of n, i.e. determine the largest power of 2 that divides n.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">trigsimp</span></code>(expr[, inverse])</p></td>
<td><p>Returns a reduced expression by using known trig identities.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">trunc</span></code>(f, p, *gens, **args)</p></td>
<td><p>Reduce <code class="docutils literal notranslate"><span class="pre">f</span></code> modulo a constant <code class="docutils literal notranslate"><span class="pre">p</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">unbranched_argument</span></code>(arg)</p></td>
<td><p>Returns periodic argument of arg with period as infinity.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">unflatten</span></code>(iter[, n])</p></td>
<td><p>Group <code class="docutils literal notranslate"><span class="pre">iter</span></code> into tuples of length <code class="docutils literal notranslate"><span class="pre">n</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">unpolarify</span></code>(eq[, subs, exponents_only])</p></td>
<td><p>If <cite>p</cite> denotes the projection from the Riemann surface of the logarithm to the complex line, return a simplified version <cite>eq'</cite> of <cite>eq</cite> such that <cite>p(eq') = p(eq)</cite>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">use</span></code>(expr, func[, level, args, kwargs])</p></td>
<td><p>Use <code class="docutils literal notranslate"><span class="pre">func</span></code> to transform <code class="docutils literal notranslate"><span class="pre">expr</span></code> at the given level.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">var</span></code>(names, **args)</p></td>
<td><p>Create symbols and inject them into the global namespace.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">variations</span></code>(seq, n[, repetition])</p></td>
<td><p>Returns an iterator over the n-sized variations of <code class="docutils literal notranslate"><span class="pre">seq</span></code> (size N).</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">vfield</span></code>(symbols, domain[, order])</p></td>
<td><p>Construct new rational function field and inject generators into global namespace.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">viete</span></code>(f[, roots])</p></td>
<td><p>Generate Viete's formulas for <code class="docutils literal notranslate"><span class="pre">f</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">vring</span></code>(symbols, domain[, order])</p></td>
<td><p>Construct a polynomial ring and inject <code class="docutils literal notranslate"><span class="pre">x_1,</span> <span class="pre">...,</span> <span class="pre">x_n</span></code> into the global namespace.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">wronskian</span></code>(functions, var[, method])</p></td>
<td><p>Compute Wronskian for [] of functions</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">xfield</span></code>(symbols, domain[, order])</p></td>
<td><p>Construct new rational function field returning (field, (x1, ..., xn)).</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">xring</span></code>(symbols, domain[, order])</p></td>
<td><p>Construct a polynomial ring returning <code class="docutils literal notranslate"><span class="pre">(ring,</span> <span class="pre">(x_1,</span> <span class="pre">...,</span> <span class="pre">x_n))</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">xthreaded</span></code>(func)</p></td>
<td><p>Apply <code class="docutils literal notranslate"><span class="pre">func</span></code> to sub--elements of an object, excluding <code class="xref py py-class docutils literal notranslate"><span class="pre">Add</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">zeros</span></code>(*args, **kwargs)</p></td>
<td><p>Returns a matrix of zeros with <code class="docutils literal notranslate"><span class="pre">rows</span></code> rows and <code class="docutils literal notranslate"><span class="pre">cols</span></code> columns; if <code class="docutils literal notranslate"><span class="pre">cols</span></code> is omitted a square matrix will be returned.</p></td>
</tr>
</tbody>
</table>
<p class="rubric">Classes</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Abs</span></code>(arg)</p></td>
<td><p>Return the absolute value of the argument.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">AccumBounds</span></code></p></td>
<td><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">AccumulationBounds</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Add</span></code>(*args[, evaluate, _sympify])</p></td>
<td><p>Expression representing addition operation for algebraic group.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Adjoint</span></code>(*args, **kwargs)</p></td>
<td><p>The Hermitian adjoint of a matrix expression.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">AlgebraicField</span></code>(dom, *ext[, alias])</p></td>
<td><p>Algebraic number field <span class="xref std std-ref">QQ(a)</span></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">AlgebraicNumber</span></code>(expr[, coeffs, alias])</p></td>
<td><p>Class for representing algebraic numbers in SymPy.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">And</span></code>(*args)</p></td>
<td><p>Logical AND function.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">AppliedPredicate</span></code>(predicate, *args)</p></td>
<td><p>The class of expressions resulting from applying <code class="docutils literal notranslate"><span class="pre">Predicate</span></code> to the arguments.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Array</span></code></p></td>
<td><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">ImmutableDenseNDimArray</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">AssumptionsContext</span></code></p></td>
<td><p>Set containing default assumptions which are applied to the <code class="docutils literal notranslate"><span class="pre">ask()</span></code> function.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Atom</span></code>(*args)</p></td>
<td><p>A parent class for atomic things.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">AtomicExpr</span></code>(*args)</p></td>
<td><p>A parent class for object which are both atoms and Exprs.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">AutoSympy</span></code>(model)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Basic</span></code>(*args)</p></td>
<td><p>Base class for all SymPy objects.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">BlockDiagMatrix</span></code>(*mats)</p></td>
<td><p>A sparse matrix with block matrices along its diagonals</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">BlockMatrix</span></code>(*args, **kwargs)</p></td>
<td><p>A BlockMatrix is a Matrix comprised of other matrices.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">CRootOf</span></code></p></td>
<td><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">ComplexRootOf</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Chi</span></code>(z)</p></td>
<td><p>Cosh integral.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Ci</span></code>(z)</p></td>
<td><p>Cosine integral.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Circle</span></code>(*args, **kwargs)</p></td>
<td><p>A circle in space.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Complement</span></code>(a, b[, evaluate])</p></td>
<td><p>Represents the set difference or relative complement of a set with another set.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">ComplexField</span></code>([prec, dps, tol])</p></td>
<td><p>Complex numbers up to the given precision.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">ComplexRegion</span></code>(sets[, polar])</p></td>
<td><p>Represents the Set of all Complex Numbers.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">ComplexRootOf</span></code>(f, x[, index, radicals, expand])</p></td>
<td><p>Represents an indexed complex root of a polynomial.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">ConditionSet</span></code>(sym, condition[, base_set])</p></td>
<td><p>Set of elements which satisfies a given condition.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Contains</span></code>(x, s)</p></td>
<td><p>Asserts that x is an element of the set S.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">CoordMap</span></code>(var_vector, eq_duals, ineq_duals, ...)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">CosineTransform</span></code>(*args)</p></td>
<td><p>Class representing unevaluated cosine transforms.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Curve</span></code>(function, limits)</p></td>
<td><p>A curve in space.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">DeferredVector</span></code>(name, **assumptions)</p></td>
<td><p>A vector whose components are deferred (e.g. for use with lambdify).</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">DenseNDimArray</span></code>(*args, **kwargs)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Derivative</span></code>(expr, *variables, **kwargs)</p></td>
<td><p>Carries out differentiation of the given expression with respect to symbols.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Determinant</span></code>(mat)</p></td>
<td><p>Matrix Determinant</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">DiagMatrix</span></code>(vector)</p></td>
<td><p>Turn a vector into a diagonal matrix.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">DiagonalMatrix</span></code>(*args, **kwargs)</p></td>
<td><p>DiagonalMatrix(M) will create a matrix expression that behaves as though all off-diagonal elements, <cite>M[i, j]</cite> where <cite>i != j</cite>, are zero.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">DiagonalOf</span></code>(*args, **kwargs)</p></td>
<td><p>DiagonalOf(M) will create a matrix expression that is equivalent to the diagonal of <cite>M</cite>, represented as a single column matrix.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Dict</span></code>(*args)</p></td>
<td><p>Wrapper around the builtin dict object.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">DifferentialMapping</span></code>(US, coord2item, ...)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">DiracDelta</span></code>(arg[, k])</p></td>
<td><p>The DiracDelta function and its derivatives.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">DisjointUnion</span></code>(*sets)</p></td>
<td><p>Represents the disjoint union (also known as the external disjoint union) of a finite number of sets.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Domain</span></code>()</p></td>
<td><p>Superclass for all domains in the polys domains system.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">DotProduct</span></code>(arg1, arg2)</p></td>
<td><p>Dot product of vector matrices</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Dummy</span></code>([name, dummy_index])</p></td>
<td><p>Dummy symbols are each unique, even if they have the same name:</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">EPath</span></code>(path)</p></td>
<td><p>Manipulate expressions using paths.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Ei</span></code>(z)</p></td>
<td><p>The classical exponential integral.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Ellipse</span></code>([center, hradius, vradius, eccentricity])</p></td>
<td><p>An elliptical GeometryEntity.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Eq</span></code></p></td>
<td><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">Equality</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Equality</span></code>(lhs, rhs, **options)</p></td>
<td><p>An equal relation between two objects.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Equivalent</span></code>(*args)</p></td>
<td><p>Equivalence relation.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Expr</span></code>(*args)</p></td>
<td><p>Base class for algebraic expressions.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">ExpressionDomain</span></code>()</p></td>
<td><p>A class for arbitrary expressions.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">FF</span></code></p></td>
<td><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">FiniteField</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">FF_gmpy</span></code></p></td>
<td><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">GMPYFiniteField</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">FF_python</span></code></p></td>
<td><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">PythonFiniteField</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">FallingFactorial</span></code>(x, k)</p></td>
<td><p>Falling factorial (related to rising factorial) is a double valued function arising in concrete mathematics, hypergeometric functions and series expansions.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">FiniteField</span></code>(mod[, symmetric])</p></td>
<td><p>Finite field of prime order <span class="xref std std-ref">GF(p)</span></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">FiniteSet</span></code>(*args, **kwargs)</p></td>
<td><p>Represents a finite set of Sympy expressions.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Float</span></code>(num[, dps, precision])</p></td>
<td><p>Represent a floating-point number of arbitrary precision.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">FourierTransform</span></code>(*args)</p></td>
<td><p>Class representing unevaluated Fourier transforms.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">FractionField</span></code>(domain_or_field[, symbols, order])</p></td>
<td><p>A class for representing multivariate rational function fields.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Function</span></code>(*args)</p></td>
<td><p>Base class for applied mathematical functions.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">FunctionClass</span></code>(*args, **kwargs)</p></td>
<td><p>Base class for function classes.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">FunctionMatrix</span></code>(rows, cols, lamda)</p></td>
<td><p>Represents a matrix using a function (<code class="docutils literal notranslate"><span class="pre">Lambda</span></code>) which gives outputs according to the coordinates of each matrix entries.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">GF</span></code></p></td>
<td><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">FiniteField</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">GMPYFiniteField</span></code>(mod[, symmetric])</p></td>
<td><p>Finite field based on GMPY integers.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">GMPYIntegerRing</span></code>()</p></td>
<td><p>Integer ring based on GMPY's <code class="docutils literal notranslate"><span class="pre">mpz</span></code> type.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">GMPYRationalField</span></code>()</p></td>
<td><p>Rational field based on GMPY's <code class="docutils literal notranslate"><span class="pre">mpq</span></code> type.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Ge</span></code></p></td>
<td><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">GreaterThan</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">GreaterThan</span></code>(lhs, rhs, **options)</p></td>
<td><p>Class representations of inequalities.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">GroebnerBasis</span></code>(F, *gens, **args)</p></td>
<td><p>Represents a reduced Groebner basis.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Gt</span></code></p></td>
<td><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">StrictGreaterThan</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">HadamardPower</span></code>(base, exp)</p></td>
<td><p>Elementwise power of matrix expressions</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">HadamardProduct</span></code>(*args[, evaluate, check])</p></td>
<td><p>Elementwise product of matrix expressions</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">HankelTransform</span></code>(*args)</p></td>
<td><p>Class representing unevaluated Hankel transforms.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Heaviside</span></code>(arg[, H0])</p></td>
<td><p>Heaviside step function.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">ITE</span></code>(*args)</p></td>
<td><p>If-then-else clause.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Identity</span></code>(n)</p></td>
<td><p>The Matrix Identity I - multiplicative identity</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Idx</span></code>(label[, range])</p></td>
<td><p>Represents an integer index as an <code class="docutils literal notranslate"><span class="pre">Integer</span></code> or integer expression.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">ImageSet</span></code>(flambda, *sets)</p></td>
<td><p>Image of a set under a mathematical function.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">ImmutableDenseMatrix</span></code>(*args, **kwargs)</p></td>
<td><p>Create an immutable version of a matrix.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">ImmutableDenseNDimArray</span></code>(iterable[, shape])</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">ImmutableMatrix</span></code></p></td>
<td><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">ImmutableDenseMatrix</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">ImmutableSparseMatrix</span></code>(*args, **kwargs)</p></td>
<td><p>Create an immutable version of a sparse matrix.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">ImmutableSparseNDimArray</span></code>([iterable, shape])</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Implies</span></code>(*args)</p></td>
<td><p>Logical implication.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Indexed</span></code>(base, *args, **kw_args)</p></td>
<td><p>Represents a mathematical object with indices.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">IndexedBase</span></code>(label[, shape, offset, strides])</p></td>
<td><p>Represent the base or stem of an indexed object</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Integer</span></code>(i)</p></td>
<td><p>Represents integer numbers of any size.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">IntegerRing</span></code>()</p></td>
<td><p>The domain <code class="docutils literal notranslate"><span class="pre">ZZ</span></code> representing the integers <cite>mathbb{Z}</cite>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Integral</span></code>(function, *symbols, **assumptions)</p></td>
<td><p>Represents unevaluated integral.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Intersection</span></code>(*args, **kwargs)</p></td>
<td><p>Represents an intersection of sets as a <code class="xref py py-class docutils literal notranslate"><span class="pre">Set</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Interval</span></code>(start, end[, left_open, right_open])</p></td>
<td><p>Represents a real interval as a Set.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Inverse</span></code>(mat[, exp])</p></td>
<td><p>The multiplicative inverse of a matrix expression</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">InverseCosineTransform</span></code>(*args)</p></td>
<td><p>Class representing unevaluated inverse cosine transforms.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">InverseFourierTransform</span></code>(*args)</p></td>
<td><p>Class representing unevaluated inverse Fourier transforms.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">InverseHankelTransform</span></code>(*args)</p></td>
<td><p>Class representing unevaluated inverse Hankel transforms.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">InverseLaplaceTransform</span></code>(*args)</p></td>
<td><p>Class representing unevaluated inverse Laplace transforms.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">InverseMellinTransform</span></code>(*args)</p></td>
<td><p>Class representing unevaluated inverse Mellin transforms.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">InverseSineTransform</span></code>(*args)</p></td>
<td><p>Class representing unevaluated inverse sine transforms.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">KroneckerDelta</span></code>(i, j[, delta_range])</p></td>
<td><p>The discrete, or Kronecker, delta function.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">KroneckerProduct</span></code>(*args[, check])</p></td>
<td><p>The Kronecker product of two or more arguments.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Lambda</span></code>(signature, expr)</p></td>
<td><p>Lambda(x, expr) represents a lambda function similar to Python's 'lambda x: expr'.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">LambertW</span></code>(x[, k])</p></td>
<td><p>The Lambert W function $W(z)$ is defined as the inverse function of $w exp(w)$ <a href="#id10"><span class="problematic" id="id5">[1]_</span></a>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">LaplaceTransform</span></code>(*args)</p></td>
<td><p>Class representing unevaluated Laplace transforms.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Le</span></code></p></td>
<td><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">LessThan</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">LessThan</span></code>(lhs, rhs, **options)</p></td>
<td><p>Class representations of inequalities.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">LeviCivita</span></code>(*args)</p></td>
<td><p>Represent the Levi-Civita symbol.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Li</span></code>(z)</p></td>
<td><p>The offset logarithmic integral.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Limit</span></code>(e, z, z0[, dir])</p></td>
<td><p>Represents an unevaluated limit.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Line</span></code>(*args, **kwargs)</p></td>
<td><p>An infinite line in space.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Line2D</span></code>(p1[, pt, slope])</p></td>
<td><p>An infinite line in space 2D.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Line3D</span></code>(p1[, pt, direction_ratio])</p></td>
<td><p>An infinite 3D line in space.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Lt</span></code></p></td>
<td><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">StrictLessThan</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">MatAdd</span></code>(*args[, evaluate, check, _sympify])</p></td>
<td><p>A Sum of Matrix Expressions</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">MatMul</span></code>(*args[, evaluate, check, _sympify])</p></td>
<td><p>A product of matrix expressions</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">MatPow</span></code>(base, exp[, evaluate])</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Matrix</span></code></p></td>
<td><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">MutableDenseMatrix</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">MatrixBase</span></code>()</p></td>
<td><p>Base class for matrix objects.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">MatrixExpr</span></code>(*args, **kwargs)</p></td>
<td><p>Superclass for Matrix Expressions</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">MatrixPermute</span></code>(mat, perm[, axis])</p></td>
<td><p>Symbolic representation for permuting matrix rows or columns.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">MatrixSlice</span></code>(parent, rowslice, colslice)</p></td>
<td><p>A MatrixSlice of a Matrix Expression</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">MatrixSymbol</span></code>(name, n, m)</p></td>
<td><p>Symbolic representation of a Matrix object</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Max</span></code>(*args)</p></td>
<td><p>Return, if possible, the maximum value of the list.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">MellinTransform</span></code>(*args)</p></td>
<td><p>Class representing unevaluated Mellin transforms.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Min</span></code>(*args)</p></td>
<td><p>Return, if possible, the minimum value of the list.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Mod</span></code>(p, q)</p></td>
<td><p>Represents a modulo operation on symbolic expressions.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Monomial</span></code>(monom[, gens])</p></td>
<td><p>Class representing a monomial, i.e. a product of powers.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Mul</span></code>(*args[, evaluate, _sympify])</p></td>
<td><p>Expression representing multiplication operation for algebraic field.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">MutableDenseMatrix</span></code>(*args, **kwargs)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">MutableDenseNDimArray</span></code>([iterable, shape])</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">MutableMatrix</span></code></p></td>
<td><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">MutableDenseMatrix</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">MutableSparseMatrix</span></code>(*args, **kwargs)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">MutableSparseNDimArray</span></code>([iterable, shape])</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">NDimArray</span></code>(iterable[, shape])</p></td>
<td><p>N-dimensional array.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Nand</span></code>(*args)</p></td>
<td><p>Logical NAND function.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Ne</span></code></p></td>
<td><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">Unequality</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Nor</span></code>(*args)</p></td>
<td><p>Logical NOR function.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Not</span></code>(arg)</p></td>
<td><p>Logical Not function (negation)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Number</span></code>(*obj)</p></td>
<td><p>Represents atomic numbers in SymPy.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">NumberSymbol</span></code>()</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">O</span></code></p></td>
<td><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">Order</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">OmegaPower</span></code>(a, b)</p></td>
<td><p>Represents ordinal exponential and multiplication terms one of the building blocks of the <code class="xref py py-class docutils literal notranslate"><span class="pre">Ordinal</span></code> class.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">OneMatrix</span></code>(m, n[, evaluate])</p></td>
<td><p>Matrix whose all entries are ones.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Options</span></code>(gens, args[, flags, strict])</p></td>
<td><p>Options manager for polynomial manipulation module.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Or</span></code>(*args)</p></td>
<td><p>Logical OR function</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Order</span></code>(expr, *args, **kwargs)</p></td>
<td><p>Represents the limiting behavior of some function.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Ordinal</span></code>(*terms)</p></td>
<td><p>Represents ordinals in Cantor normal form.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Parabola</span></code>([focus, directrix])</p></td>
<td><p>A parabolic GeometryEntity.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Permanent</span></code>(mat)</p></td>
<td><p>Matrix Permanent</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">PermutationMatrix</span></code>(perm)</p></td>
<td><p>A Permutation Matrix</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Piecewise</span></code>(*_args)</p></td>
<td><p>Represents a piecewise function.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Plane</span></code>(p1[, a, b])</p></td>
<td><p>A plane is a flat, two-dimensional surface.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Point</span></code>(*args, **kwargs)</p></td>
<td><p>A point in a n-dimensional Euclidean space.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Point2D</span></code>(*args[, _nocheck])</p></td>
<td><p>A point in a 2-dimensional Euclidean space.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Point3D</span></code>(*args[, _nocheck])</p></td>
<td><p>A point in a 3-dimensional Euclidean space.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Poly</span></code>(rep, *gens, **args)</p></td>
<td><p>Generic class for representing and operating on polynomial expressions.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Polygon</span></code>(*args[, n])</p></td>
<td><p>A two-dimensional polygon.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">PolynomialRing</span></code>(domain_or_ring[, symbols, order])</p></td>
<td><p>A class for representing multivariate polynomial rings.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Pow</span></code>(b, e[, evaluate])</p></td>
<td><p>Defines the expression x**y as &quot;x raised to a power y&quot;</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">PowerSet</span></code>(arg[, evaluate])</p></td>
<td><p>A symbolic object representing a power set.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Predicate</span></code>(*args, **kwargs)</p></td>
<td><p>Base class for mathematical predicates.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Product</span></code>(function, *symbols, **assumptions)</p></td>
<td><p>Represents unevaluated products.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">ProductSet</span></code>(*sets, **assumptions)</p></td>
<td><p>Represents a Cartesian Product of Sets.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">PurePoly</span></code>(rep, *gens, **args)</p></td>
<td><p>Class for representing pure polynomials.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">PythonFiniteField</span></code>(mod[, symmetric])</p></td>
<td><p>Finite field based on Python's integers.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">PythonIntegerRing</span></code>()</p></td>
<td><p>Integer ring based on Python's <code class="docutils literal notranslate"><span class="pre">int</span></code> type.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">PythonRational</span></code></p></td>
<td><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">PythonMPQ</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">QQ_gmpy</span></code></p></td>
<td><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">GMPYRationalField</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">QQ_python</span></code></p></td>
<td><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">PythonRationalField</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Quaternion</span></code>([a, b, c, d, real_field, norm])</p></td>
<td><p>Provides basic quaternion operations.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Range</span></code>(*args)</p></td>
<td><p>Represents a range of integers.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Rational</span></code>(p[, q, gcd])</p></td>
<td><p>Represents rational numbers (p/q) of any size.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">RationalField</span></code>()</p></td>
<td><p>Abstract base class for the domain <span class="xref std std-ref">QQ</span>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Ray</span></code>(p1[, p2])</p></td>
<td><p>A Ray is a semi-line in the space with a source point and a direction.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Ray2D</span></code>(p1[, pt, angle])</p></td>
<td><p>A Ray is a semi-line in the space with a source point and a direction.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Ray3D</span></code>(p1[, pt, direction_ratio])</p></td>
<td><p>A Ray is a semi-line in the space with a source point and a direction.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">RealField</span></code>([prec, dps, tol])</p></td>
<td><p>Real numbers up to the given precision.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">RealNumber</span></code></p></td>
<td><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">Float</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">RegularPolygon</span></code>(c, r, n[, rot])</p></td>
<td><p>A regular polygon.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Rel</span></code></p></td>
<td><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">Relational</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Rem</span></code>(p, q)</p></td>
<td><p>Returns the remainder when <code class="docutils literal notranslate"><span class="pre">p</span></code> is divided by <code class="docutils literal notranslate"><span class="pre">q</span></code> where <code class="docutils literal notranslate"><span class="pre">p</span></code> is finite and <code class="docutils literal notranslate"><span class="pre">q</span></code> is not equal to zero.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">RisingFactorial</span></code>(x, k)</p></td>
<td><p>Rising factorial (also called Pochhammer symbol <a href="#id11"><span class="problematic" id="id6">[1]_</span></a>) is a double valued function arising in concrete mathematics, hypergeometric functions and series expansions.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">RootOf</span></code>(f, x[, index, radicals, expand])</p></td>
<td><p>Represents a root of a univariate polynomial.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">RootSum</span></code>(expr[, func, x, auto, quadratic])</p></td>
<td><p>Represents a sum of all roots of a univariate polynomial.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Segment</span></code>(p1, p2, **kwargs)</p></td>
<td><p>A line segment in space.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Segment2D</span></code>(p1, p2, **kwargs)</p></td>
<td><p>A line segment in 2D space.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Segment3D</span></code>(p1, p2, **kwargs)</p></td>
<td><p>A line segment in a 3D space.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">SensitivityMatrix</span></code>(sympification, duals, ...)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">SeqAdd</span></code>(*args, **kwargs)</p></td>
<td><p>Represents term-wise addition of sequences.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">SeqFormula</span></code>(formula[, limits])</p></td>
<td><p>Represents sequence based on a formula.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">SeqMul</span></code>(*args, **kwargs)</p></td>
<td><p>Represents term-wise multiplication of sequences.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">SeqPer</span></code>(periodical[, limits])</p></td>
<td><p>Represents a periodic sequence.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Set</span></code>(*args)</p></td>
<td><p>The base class for any kind of set.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Shi</span></code>(z)</p></td>
<td><p>Sinh integral.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Si</span></code>(z)</p></td>
<td><p>Sine integral.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Sieve</span></code>()</p></td>
<td><p>An infinite list of prime numbers, implemented as a dynamically growing sieve of Eratosthenes.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">SineTransform</span></code>(*args)</p></td>
<td><p>Class representing unevaluated sine transforms.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">SingularityFunction</span></code>(variable, offset, exponent)</p></td>
<td><p>Singularity functions are a class of discontinuous functions.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">SparseMatrix</span></code></p></td>
<td><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">MutableSparseMatrix</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">SparseNDimArray</span></code>(*args, **kwargs)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">StrPrinter</span></code>([settings])</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">StrictGreaterThan</span></code>(lhs, rhs, **options)</p></td>
<td><p>Class representations of inequalities.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">StrictLessThan</span></code>(lhs, rhs, **options)</p></td>
<td><p>Class representations of inequalities.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Subs</span></code>(expr, variables, point, **assumptions)</p></td>
<td><p>Represents unevaluated substitutions of an expression.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Sum</span></code>(function, *symbols, **assumptions)</p></td>
<td><p>Represents unevaluated summation.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Symbol</span></code>(name, **assumptions)</p></td>
<td><p>Assumptions:</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">SymmetricDifference</span></code>(a, b[, evaluate])</p></td>
<td><p>Represents the set of elements which are in either of the sets and not in their intersection.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">TableForm</span></code>(data, **kwarg)</p></td>
<td><p>Create a nice table representation of data.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#src.sensitivity.babymodel.TestBabyModel" title="src.sensitivity.babymodel.TestBabyModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">TestBabyModel</span></code></a>(*args, **kwds)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Trace</span></code>(mat)</p></td>
<td><p>Matrix Trace</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Transpose</span></code>(*args, **kwargs)</p></td>
<td><p>The transpose of a matrix expression.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Triangle</span></code>(*args, **kwargs)</p></td>
<td><p>A polygon with three vertices and three sides.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Tuple</span></code>(*args, **kwargs)</p></td>
<td><p>Wrapper around the builtin tuple object.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Unequality</span></code>(lhs, rhs, **options)</p></td>
<td><p>An unequal relation between two objects.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">UnevaluatedExpr</span></code>(arg, **kwargs)</p></td>
<td><p>Expression that is not evaluated unless released.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Union</span></code>(*args, **kwargs)</p></td>
<td><p>Represents a union of sets as a <code class="xref py py-class docutils literal notranslate"><span class="pre">Set</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Wild</span></code>(name[, exclude, properties])</p></td>
<td><p>A Wild symbol matches anything, or anything without whatever is explicitly excluded.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">WildFunction</span></code>(*args)</p></td>
<td><p>A WildFunction function matches any function (with its arguments).</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Xor</span></code>(*args)</p></td>
<td><p>Logical XOR (exclusive OR) function.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Ynm</span></code>(n, m, theta, phi)</p></td>
<td><p>Spherical harmonics defined as</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">ZZ_gmpy</span></code></p></td>
<td><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">GMPYIntegerRing</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">ZZ_python</span></code></p></td>
<td><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">PythonIntegerRing</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">ZeroMatrix</span></code>(m, n)</p></td>
<td><p>The Matrix Zero 0 - additive identity</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Znm</span></code>(n, m, theta, phi)</p></td>
<td><p>Real spherical harmonics defined as</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">acos</span></code>(arg)</p></td>
<td><p>The inverse cosine function.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">acosh</span></code>(arg)</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">acosh(x)</span></code> is the inverse hyperbolic cosine of <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">acot</span></code>(arg)</p></td>
<td><p>The inverse cotangent function.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">acoth</span></code>(arg)</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">acoth(x)</span></code> is the inverse hyperbolic cotangent of <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">acsc</span></code>(arg)</p></td>
<td><p>The inverse cosecant function.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">acsch</span></code>(arg)</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">acsch(x)</span></code> is the inverse hyperbolic cosecant of <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">adjoint</span></code>(arg)</p></td>
<td><p>Conjugate transpose or Hermite conjugation.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">airyai</span></code>(arg)</p></td>
<td><p>The Airy function $operatorname{Ai}$ of the first kind.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">airyaiprime</span></code>(arg)</p></td>
<td><p>The derivative $operatorname{Ai}^prime$ of the Airy function of the first kind.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">airybi</span></code>(arg)</p></td>
<td><p>The Airy function $operatorname{Bi}$ of the second kind.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">airybiprime</span></code>(arg)</p></td>
<td><p>The derivative $operatorname{Bi}^prime$ of the Airy function of the first kind.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">andre</span></code>(n)</p></td>
<td><p>Andre numbers / Andre function</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">appellf1</span></code>(a, b1, b2, c, x, y)</p></td>
<td><p>This is the Appell hypergeometric function of two variables as:</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">arg</span></code>(arg)</p></td>
<td><p>Returns the argument (in radians) of a complex number.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">asec</span></code>(arg)</p></td>
<td><p>The inverse secant function.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">asech</span></code>(arg)</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">asech(x)</span></code> is the inverse hyperbolic secant of <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">asin</span></code>(arg)</p></td>
<td><p>The inverse sine function.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">asinh</span></code>(arg)</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">asinh(x)</span></code> is the inverse hyperbolic sine of <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">assoc_laguerre</span></code>(n, alpha, x)</p></td>
<td><p>Returns the $n$th generalized Laguerre polynomial in $x$, $L_n(x)$.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">assoc_legendre</span></code>(n, m, x)</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">assoc_legendre(n,</span> <span class="pre">m,</span> <span class="pre">x)</span></code> gives $P_n^m(x)$, where $n$ and $m$ are the degree and order or an expression which is related to the nth order Legendre polynomial, $P_n(x)$ in the following manner:</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">atan</span></code>(arg)</p></td>
<td><p>The inverse tangent function.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">atan2</span></code>(y, x)</p></td>
<td><p>The function <code class="docutils literal notranslate"><span class="pre">atan2(y,</span> <span class="pre">x)</span></code> computes <cite>operatorname{atan}(y/x)</cite> taking two arguments <cite>y</cite> and <cite>x</cite>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">atanh</span></code>(arg)</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">atanh(x)</span></code> is the inverse hyperbolic tangent of <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">bell</span></code>(n[, k_sym, symbols])</p></td>
<td><p>Bell numbers / Bell polynomials</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">bernoulli</span></code>(n[, x])</p></td>
<td><p>Bernoulli numbers / Bernoulli polynomials / Bernoulli function</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">besseli</span></code>(nu, z)</p></td>
<td><p>Modified Bessel function of the first kind.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">besselj</span></code>(nu, z)</p></td>
<td><p>Bessel function of the first kind.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">besselk</span></code>(nu, z)</p></td>
<td><p>Modified Bessel function of the second kind.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">bessely</span></code>(nu, z)</p></td>
<td><p>Bessel function of the second kind.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">beta</span></code>(x[, y])</p></td>
<td><p>The beta integral is called the Eulerian integral of the first kind by Legendre:</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">betainc</span></code>(*args)</p></td>
<td><p>The Generalized Incomplete Beta function is defined as</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">betainc_regularized</span></code>(*args)</p></td>
<td><p>The Generalized Regularized Incomplete Beta function is given by</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">binomial</span></code>(n, k)</p></td>
<td><p>Implementation of the binomial coefficient.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">carmichael</span></code>(*args)</p></td>
<td><p>Carmichael Numbers:</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cartes</span></code></p></td>
<td><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">product</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">catalan</span></code>(n)</p></td>
<td><p>Catalan numbers</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">ceiling</span></code>(arg)</p></td>
<td><p>Ceiling is a univariate function which returns the smallest integer value not less than its argument.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">chebyshevt</span></code>(n, x)</p></td>
<td><p>Chebyshev polynomial of the first kind, $T_n(x)$.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">chebyshevt_root</span></code>(n, k)</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">chebyshev_root(n,</span> <span class="pre">k)</span></code> returns the $k$th root (indexed from zero) of the $n$th Chebyshev polynomial of the first kind; that is, if $0 le k &lt; n$, <code class="docutils literal notranslate"><span class="pre">chebyshevt(n,</span> <span class="pre">chebyshevt_root(n,</span> <span class="pre">k))</span> <span class="pre">==</span> <span class="pre">0</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">chebyshevu</span></code>(n, x)</p></td>
<td><p>Chebyshev polynomial of the second kind, $U_n(x)$.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">chebyshevu_root</span></code>(n, k)</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">chebyshevu_root(n,</span> <span class="pre">k)</span></code> returns the $k$th root (indexed from zero) of the $n$th Chebyshev polynomial of the second kind; that is, if $0 le k &lt; n$, <code class="docutils literal notranslate"><span class="pre">chebyshevu(n,</span> <span class="pre">chebyshevu_root(n,</span> <span class="pre">k))</span> <span class="pre">==</span> <span class="pre">0</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">conjugate</span></code>(arg)</p></td>
<td><p>Returns the <em>complex conjugate</em> <a href="#id12"><span class="problematic" id="id7">[1]_</span></a> of an argument.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cos</span></code>(arg)</p></td>
<td><p>The cosine function.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cosh</span></code>(arg)</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">cosh(x)</span></code> is the hyperbolic cosine of <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cot</span></code>(arg)</p></td>
<td><p>The cotangent function.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">coth</span></code>(arg)</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">coth(x)</span></code> is the hyperbolic cotangent of <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">csc</span></code>(arg)</p></td>
<td><p>The cosecant function.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">csch</span></code>(arg)</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">csch(x)</span></code> is the hyperbolic cosecant of <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">defaultdict</span></code></p></td>
<td><p>defaultdict(default_factory=None, /, [...]) --&gt; dict with default factory</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">digamma</span></code>(z)</p></td>
<td><p>The <code class="docutils literal notranslate"><span class="pre">digamma</span></code> function is the first derivative of the <code class="docutils literal notranslate"><span class="pre">loggamma</span></code> function</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">dirichlet_eta</span></code>(s[, a])</p></td>
<td><p>Dirichlet eta function.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">divisor_sigma</span></code>(n[, k])</p></td>
<td><p>Calculate the divisor function <cite>sigma_k(n)</cite> for positive integer n</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">elliptic_e</span></code>(m[, z])</p></td>
<td><p>Called with two arguments $z$ and $m$, evaluates the incomplete elliptic integral of the second kind, defined by</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">elliptic_f</span></code>(z, m)</p></td>
<td><p>The Legendre incomplete elliptic integral of the first kind, defined by</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">elliptic_k</span></code>(m)</p></td>
<td><p>The complete elliptic integral of the first kind, defined by</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">elliptic_pi</span></code>(n, m[, z])</p></td>
<td><p>Called with three arguments $n$, $z$ and $m$, evaluates the Legendre incomplete elliptic integral of the third kind, defined by</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">erf</span></code>(arg)</p></td>
<td><p>The Gauss error function.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">erf2</span></code>(x, y)</p></td>
<td><p>Two-argument error function.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">erf2inv</span></code>(x, y)</p></td>
<td><p>Two-argument Inverse error function.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">erfc</span></code>(arg)</p></td>
<td><p>Complementary Error Function.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">erfcinv</span></code>(z)</p></td>
<td><p>Inverse Complementary Error Function.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">erfi</span></code>(z)</p></td>
<td><p>Imaginary error function.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">erfinv</span></code>(z)</p></td>
<td><p>Inverse Error Function.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">euler</span></code>(n[, x])</p></td>
<td><p>Euler numbers / Euler polynomials / Euler function</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">exp</span></code>(arg)</p></td>
<td><p>The exponential function, <span class="math notranslate nohighlight">\(e^x\)</span>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">exp_polar</span></code>(*args)</p></td>
<td><p>Represent a <em>polar number</em> (see g-function Sphinx documentation).</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">expint</span></code>(nu, z)</p></td>
<td><p>Generalized exponential integral.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">factorial</span></code>(n)</p></td>
<td><p>Implementation of factorial function over nonnegative integers.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">factorial2</span></code>(arg)</p></td>
<td><p>The double factorial <cite>n!!</cite>, not to be confused with <cite>(n!)!</cite></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">ff</span></code></p></td>
<td><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">FallingFactorial</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">fibonacci</span></code>(n[, sym])</p></td>
<td><p>Fibonacci numbers / Fibonacci polynomials</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">floor</span></code>(arg)</p></td>
<td><p>Floor is a univariate function which returns the largest integer value not greater than its argument.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">frac</span></code>(arg)</p></td>
<td><p>Represents the fractional part of x</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">fresnelc</span></code>(z)</p></td>
<td><p>Fresnel integral C.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">fresnels</span></code>(z)</p></td>
<td><p>Fresnel integral S.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">gamma</span></code>(arg)</p></td>
<td><p>The gamma function</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">gegenbauer</span></code>(n, a, x)</p></td>
<td><p>Gegenbauer polynomial $C_n^{left(alpharight)}(x)$.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">genocchi</span></code>(n[, x])</p></td>
<td><p>Genocchi numbers / Genocchi polynomials / Genocchi function</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">hankel1</span></code>(nu, z)</p></td>
<td><p>Hankel function of the first kind.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">hankel2</span></code>(nu, z)</p></td>
<td><p>Hankel function of the second kind.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">harmonic</span></code>(n[, m])</p></td>
<td><p>Harmonic numbers</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">hermite</span></code>(n, x)</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">hermite(n,</span> <span class="pre">x)</span></code> gives the $n$th Hermite polynomial in $x$, $H_n(x)$.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">hermite_prob</span></code>(n, x)</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">hermite_prob(n,</span> <span class="pre">x)</span></code> gives the $n$th probabilist's Hermite polynomial in $x$, $He_n(x)$.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">hn1</span></code>(nu, z)</p></td>
<td><p>Spherical Hankel function of the first kind.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">hn2</span></code>(nu, z)</p></td>
<td><p>Spherical Hankel function of the second kind.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">hyper</span></code>(ap, bq, z)</p></td>
<td><p>The generalized hypergeometric function is defined by a series where the ratios of successive terms are a rational function of the summation index.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">im</span></code>(arg)</p></td>
<td><p>Returns imaginary part of expression.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">jacobi</span></code>(n, a, b, x)</p></td>
<td><p>Jacobi polynomial $P_n^{left(alpha, betaright)}(x)$.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">jn</span></code>(nu, z)</p></td>
<td><p>Spherical Bessel function of the first kind.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">laguerre</span></code>(n, x)</p></td>
<td><p>Returns the $n$th Laguerre polynomial in $x$, $L_n(x)$.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">legendre</span></code>(n, x)</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">legendre(n,</span> <span class="pre">x)</span></code> gives the $n$th Legendre polynomial of $x$, $P_n(x)$</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">lerchphi</span></code>(*args)</p></td>
<td><p>Lerch transcendent (Lerch phi function).</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">li</span></code>(z)</p></td>
<td><p>The classical logarithmic integral.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">ln</span></code></p></td>
<td><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">log</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">log</span></code>(arg[, base])</p></td>
<td><p>The natural logarithm function <cite>ln(x)</cite> or <cite>log(x)</cite>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">loggamma</span></code>(z)</p></td>
<td><p>The <code class="docutils literal notranslate"><span class="pre">loggamma</span></code> function implements the logarithm of the gamma function (i.e., $logGamma(x)$).</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">lowergamma</span></code>(a, x)</p></td>
<td><p>The lower incomplete gamma function.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">lucas</span></code>(n)</p></td>
<td><p>Lucas numbers</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">marcumq</span></code>(m, a, b)</p></td>
<td><p>The Marcum Q-function.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">mathieuc</span></code>(a, q, z)</p></td>
<td><p>The Mathieu Cosine function $C(a,q,z)$.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">mathieucprime</span></code>(a, q, z)</p></td>
<td><p>The derivative $C^{prime}(a,q,z)$ of the Mathieu Cosine function.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">mathieus</span></code>(a, q, z)</p></td>
<td><p>The Mathieu Sine function $S(a,q,z)$.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">mathieusprime</span></code>(a, q, z)</p></td>
<td><p>The derivative $S^{prime}(a,q,z)$ of the Mathieu Sine function.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">meijerg</span></code>(*args)</p></td>
<td><p>The Meijer G-function is defined by a Mellin-Barnes type integral that resembles an inverse Mellin transform.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">mobius</span></code>(n)</p></td>
<td><p>Mobius function maps natural number to {-1, 0, 1}</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">motzkin</span></code>(n)</p></td>
<td><p>The nth Motzkin number is the number</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">multigamma</span></code>(x, p)</p></td>
<td><p>The multivariate gamma function is a generalization of the gamma function</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">partition</span></code>(n)</p></td>
<td><p>Partition numbers</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">periodic_argument</span></code>(ar, period)</p></td>
<td><p>Represent the argument on a quotient of the Riemann surface of the logarithm.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">polar_lift</span></code>(arg)</p></td>
<td><p>Lift argument to the Riemann surface of the logarithm, using the standard branch.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">polygamma</span></code>(n, z)</p></td>
<td><p>The function <code class="docutils literal notranslate"><span class="pre">polygamma(n,</span> <span class="pre">z)</span></code> returns <code class="docutils literal notranslate"><span class="pre">log(gamma(z)).diff(n</span> <span class="pre">+</span> <span class="pre">1)</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">polylog</span></code>(s, z)</p></td>
<td><p>Polylogarithm function.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">preorder_traversal</span></code>(node[, keys])</p></td>
<td><p>Do a pre-order traversal of a tree.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">primenu</span></code>(n)</p></td>
<td><p>Calculate the number of distinct prime factors for a positive integer n.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">primeomega</span></code>(n)</p></td>
<td><p>Calculate the number of prime factors counting multiplicities for a positive integer n.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">primepi</span></code>(n)</p></td>
<td><p>Represents the prime counting function pi(n) = the number of prime numbers less than or equal to n.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">principal_branch</span></code>(x, period)</p></td>
<td><p>Represent a polar number reduced to its principal branch on a quotient of the Riemann surface of the logarithm.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">re</span></code>(arg)</p></td>
<td><p>Returns real part of expression.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">reduced_totient</span></code>(n)</p></td>
<td><p>Calculate the Carmichael reduced totient function lambda(n)</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">rf</span></code></p></td>
<td><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">RisingFactorial</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">riemann_xi</span></code>(s)</p></td>
<td><p>Riemann Xi function.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">sec</span></code>(arg)</p></td>
<td><p>The secant function.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">sech</span></code>(arg)</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">sech(x)</span></code> is the hyperbolic secant of <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">sign</span></code>(arg)</p></td>
<td><p>Returns the complex sign of an expression:</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">sin</span></code>(arg)</p></td>
<td><p>The sine function.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">sinc</span></code>(arg)</p></td>
<td><p>Represents an unnormalized sinc function:</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">sinh</span></code>(arg)</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">sinh(x)</span></code> is the hyperbolic sine of <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">stieltjes</span></code>(n[, a])</p></td>
<td><p>Represents Stieltjes constants, $gamma_{k}$ that occur in Laurent Series expansion of the Riemann zeta function.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">subfactorial</span></code>(arg)</p></td>
<td><p>The subfactorial counts the derangements of $n$ items and is defined for non-negative integers as:</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">tan</span></code>(arg)</p></td>
<td><p>The tangent function.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">tanh</span></code>(arg)</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">tanh(x)</span></code> is the hyperbolic tangent of <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">totient</span></code>(n)</p></td>
<td><p>Calculate the Euler totient function phi(n)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">transpose</span></code>(arg)</p></td>
<td><p>Linear map transposition.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">tribonacci</span></code>(n[, sym])</p></td>
<td><p>Tribonacci numbers / Tribonacci polynomials</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">trigamma</span></code>(z)</p></td>
<td><p>The <code class="docutils literal notranslate"><span class="pre">trigamma</span></code> function is the second derivative of the <code class="docutils literal notranslate"><span class="pre">loggamma</span></code> function</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">uppergamma</span></code>(a, z)</p></td>
<td><p>The upper incomplete gamma function.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">vectorize</span></code>(*mdargs)</p></td>
<td><p>Generalizes a function taking scalars to accept multidimensional arguments.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">yn</span></code>(nu, z)</p></td>
<td><p>Spherical Bessel function of the second kind.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">zeta</span></code>(s[, a])</p></td>
<td><p>Hurwitz zeta function (or Riemann zeta function).</p></td>
</tr>
</tbody>
</table>
<p class="rubric">Exceptions</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">BasePolynomialError</span></code></p></td>
<td><p>Base class for polynomial related exceptions.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">CoercionFailed</span></code></p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">ComputationFailed</span></code>(func, nargs, exc)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">DomainError</span></code></p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">EvaluationFailed</span></code></p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">ExactQuotientFailed</span></code>(f, g[, dom])</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">ExtraneousFactors</span></code></p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">FlagError</span></code></p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">GeneratorsError</span></code></p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">GeneratorsNeeded</span></code></p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">GeometryError</span></code></p></td>
<td><p>An exception raised by classes in the geometry module.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">HeuristicGCDFailed</span></code></p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">HomomorphismFailed</span></code></p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">IsomorphismFailed</span></code></p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">MultivariatePolynomialError</span></code></p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">NonSquareMatrixError</span></code></p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">NotAlgebraic</span></code></p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">NotInvertible</span></code></p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">NotReversible</span></code></p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">OperationNotSupported</span></code>(poly, func)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">OptionError</span></code></p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">PoleError</span></code></p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">PolificationFailed</span></code>(opt, origs, exprs[, seq])</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">PolynomialDivisionFailed</span></code>(f, g, domain)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">PolynomialError</span></code></p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">PrecisionExhausted</span></code></p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">RefinementFailed</span></code></p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">ShapeError</span></code></p></td>
<td><p>Wrong matrix shape</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">SympifyError</span></code>(expr[, base_exc])</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">UnificationFailed</span></code></p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">UnivariatePolynomialError</span></code></p></td>
<td><p></p></td>
</tr>
</tbody>
</table>
<dl class="py class">
<dt class="sig sig-object py" id="src.sensitivity.babymodel.TestBabyModel">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">src.sensitivity.babymodel.</span></span><span class="sig-name descname"><span class="pre">TestBabyModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwds</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/src/sensitivity/babymodel.html#TestBabyModel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.sensitivity.babymodel.TestBabyModel" title="Link to this definition"></a></dt>
<dd><dl class="py attribute">
<dt class="sig sig-object py" id="src.sensitivity.babymodel.TestBabyModel._active">
<span class="sig-name descname"><span class="pre">_active</span></span><a class="headerlink" href="#src.sensitivity.babymodel.TestBabyModel._active" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="src.sensitivity.babymodel.TestBabyModel.solve">
<span class="sig-name descname"><span class="pre">solve</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/src/sensitivity/babymodel.html#TestBabyModel.solve"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.sensitivity.babymodel.TestBabyModel.solve" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.sensitivity.babymodel.connect_regions">
<span class="sig-prename descclassname"><span class="pre">src.sensitivity.babymodel.</span></span><span class="sig-name descname"><span class="pre">connect_regions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">region_map</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hubmap</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base_trans_cap</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/src/sensitivity/babymodel.html#connect_regions"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.sensitivity.babymodel.connect_regions" title="Link to this definition"></a></dt>
<dd><p>given a mapping of regions to lists of hubs, and hubs to regions, creates
a set of arcs between hubs such that:</p>
<ol class="arabic simple">
<li><p>the grid is connected</p></li>
<li><p>each region has a main hub that all other hubs in the region are connected to</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>region_map</strong> (<em>dict</em>) – dictionary of region names to lists of hubs</p></li>
<li><p><strong>hubmap</strong> (<em>dict</em>) – dictionary of hub names to their parent region</p></li>
<li><p><strong>base_trans_cap</strong> (<em>float</em>) – base transportation capacity for arcs</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>arcs</strong> (<em>list</em>) – list of tuples of hubs, representing start and endpoints</p></li>
<li><p><strong>outbound</strong> (<em>dict</em>) – dictionary of hub:list of arcs originating from hub</p></li>
<li><p><strong>inbound</strong> (<em>dict</em>) – dictionary of hub:list of arcs terminating at hub</p></li>
<li><p><strong>trans_capacity</strong> (<em>dict</em>) – dictionary of arcs:transportation capacity of arc</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.sensitivity.babymodel.generate">
<span class="sig-prename descclassname"><span class="pre">src.sensitivity.babymodel.</span></span><span class="sig-name descname"><span class="pre">generate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_regions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hubs_per_region</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base_elec_price</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base_prod_capacity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">demand_fraction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.7</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base_transport_cost</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">22.3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base_elec_consumption</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">9.8</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/src/sensitivity/babymodel.html#generate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.sensitivity.babymodel.generate" title="Link to this definition"></a></dt>
<dd><p>generates a random network with all parameters required to initialize a ToyBabyModel</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>num_regions</strong> (<em>int</em><em>, </em><em>optional</em>) – number of regions. Defaults to 3.</p></li>
<li><p><strong>hubs_per_region</strong> (<em>int</em><em>, </em><em>optional</em>) – number of hubs per region. Defaults to 2.</p></li>
<li><p><strong>base_elec_price</strong> (<em>float</em><em>, </em><em>optional</em>) – the average electricity price in all regions. Defaults to 5.0.</p></li>
<li><p><strong>base_prod_capacity</strong> (<em>int</em><em>, </em><em>optional</em>) – the average production capacity for all hubs. Defaults to 5000.</p></li>
<li><p><strong>demand_fraction</strong> (<em>float</em><em>, </em><em>optional</em>) – the average fraction of capacity initial demand is set to. Defaults to 0.7.</p></li>
<li><p><strong>base_transport_cost</strong> (<em>float</em><em>, </em><em>optional</em>) – the base transportation cost for all arcs. Defaults to 22.3.</p></li>
<li><p><strong>base_elec_consumption</strong> (<em>float</em><em>, </em><em>optional</em>) – the electricity consumption rate for production. Defaults to 9.8.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>hublist</strong> (<em>list</em>)</p></li>
<li><p><strong>region_list</strong> (<em>list</em>)</p></li>
<li><p><strong>hub_map</strong> (<em>dict</em>)</p></li>
<li><p><strong>region_map</strong> (<em>dict</em>)</p></li>
<li><p><strong>elec_price</strong> (<em>dict</em>)</p></li>
<li><p><strong>prod_capacity</strong> (<em>dict</em>)</p></li>
<li><p><strong>demand</strong> (<em>dict</em>)</p></li>
<li><p><strong>base_elec_consumption</strong> (<em>float</em>)</p></li>
<li><p><strong>base_transport_cost</strong> (<em>float</em>)</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, U.S. Energy Information Administration.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>