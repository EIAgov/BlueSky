

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>src.common.model &mdash; BlueSky Prototype Model v1.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=45183d27"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            BlueSky Prototype Model
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../src.models.html">src.models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../src.html">src</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">BlueSky Prototype Model</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">src.common.model</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for src.common.model</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Establish a base model class for the sectoral modules to inherit.&quot;&quot;&quot;</span>

<span class="c1">###################################################################################################</span>
<span class="c1"># Setup</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Literal</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">MutableSequence</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">DefaultDict</span><span class="p">,</span> <span class="n">Set</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">sys</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sys</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pyomo.environ</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pyo</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">logging</span><span class="w"> </span><span class="kn">import</span> <span class="n">getLogger</span>

<span class="c1"># Establish logger</span>
<span class="n">logger</span> <span class="o">=</span> <span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="c1">###################################################################################################</span>
<span class="c1"># MODEL</span>


<div class="viewcode-block" id="Model">
<a class="viewcode-back" href="../../../src.common.model.html#src.common.model.Model">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Model</span><span class="p">(</span><span class="n">pyo</span><span class="o">.</span><span class="n">ConcreteModel</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;This is the base model class for the models.</span>

<span class="sd">    This class contains methods for declaring pyomo components, extracting duals, and</span>
<span class="sd">    decorating expressions. The model class methods and attributes provide functionality</span>
<span class="sd">    for keeping track of index labels and ordering for all pyomo components; this is</span>
<span class="sd">    essential for integration tasks without the use of hard-coded indices and allows for</span>
<span class="sd">    easy post-processing tasks.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">pyo</span><span class="o">.</span><span class="n">ConcreteModel</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Initialize decorators with model instance</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">DefaultDecorator</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># dictionary to lookup column names for sets, params, variables</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cols_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dual</span> <span class="o">=</span> <span class="n">pyo</span><span class="o">.</span><span class="n">Suffix</span><span class="p">(</span><span class="n">direction</span><span class="o">=</span><span class="n">pyo</span><span class="o">.</span><span class="n">Suffix</span><span class="o">.</span><span class="n">IMPORT</span><span class="p">)</span>

<div class="viewcode-block" id="Model.build">
<a class="viewcode-back" href="../../../src.common.model.html#src.common.model.Model.build">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">build</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Default build command; class-level build to create and return an instance of Model.</span>

<span class="sd">        This will work for any class inheriting the method, but it is recommended to replace this</span>
<span class="sd">        with model-specific build instructions if this functionality is desired.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Object</span>
<span class="sd">            Instance of Model object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">()</span></div>


<div class="viewcode-block" id="Model.reorganize_index_set">
<a class="viewcode-back" href="../../../src.common.model.html#src.common.model.Model.reorganize_index_set">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">reorganize_index_set</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">sname</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">new_sname</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">return_set</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">create_indexed_set</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">reorg_set_cols</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">reorg_set_sname</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Creates new pyomo sets based on an input set and a desired set of indices for an output</span>
<span class="sd">        set. User should provide either names of columns desired for reorganized output set OR the</span>
<span class="sd">        name of a set that mirrors the desired indexing.</span>

<span class="sd">        For instance, an input set indexed by (yr, region, month, day) can be reorganized into an</span>
<span class="sd">        output set:</span>

<span class="sd">        (yr, region):[(month,day), (month,day), (month,day)]</span>

<span class="sd">        when [&quot;yr&quot;, &quot;region&quot;] is provided for reorg_set_cols.</span>

<span class="sd">        If only the set keys are desired, without creating an indexed set object as illustrated</span>
<span class="sd">        above, the user can set &#39;create_indexed_set&#39; to false. If true, the output is a</span>
<span class="sd">        pyo.IndexedSet, with each element of the IndexedSet containing the values of other indices</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sname : str</span>
<span class="sd">            Name of input set</span>
<span class="sd">        new_sname : str</span>
<span class="sd">            Name of output set or IndexedSet</span>
<span class="sd">        create_indexed_set : bool | None, optional</span>
<span class="sd">            Indicator for whether output set should include values as well as new index (IndexedSets), by default False</span>
<span class="sd">        return_set: bool | None, optional</span>
<span class="sd">            Indicator for whether to return the constructed set</span>
<span class="sd">        reorg_set_cols : List[str] | None, optional</span>
<span class="sd">            List of columns to index output set contained in &#39;sname&#39;, by default None</span>
<span class="sd">        reorg_set_sname : str | None, optional</span>
<span class="sd">            Name of set to use for identifying output set indices, by default None</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Pyo.Set</span>
<span class="sd">            Pyomo Set or IndexedSet object reorganized based on input set</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            Populate function is either-or for reorg_set_cols and reorg_set_sname, received both</span>
<span class="sd">        ValueError</span>
<span class="sd">           Populate function is either-or for reorg_set_cols and reorg_set_sname, received neither</span>
<span class="sd">        ValueError</span>
<span class="sd">            Elements missing from input set desired in new set</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># reorganize_index_set -- Get a hook to the input set</span>
        <span class="n">set_in</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sname</span><span class="p">)</span>
        <span class="n">set_in_cols</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols_dict</span><span class="p">[</span><span class="n">sname</span><span class="p">]</span>

        <span class="c1"># reorganize_index_set -- Throw error if both reorg options provided</span>
        <span class="k">if</span> <span class="n">reorg_set_cols</span> <span class="ow">and</span> <span class="n">reorg_set_sname</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;Populate function is either-or for reorg_set_cols and reorg_set_sname, received both: </span><span class="si">{</span><span class="n">reorg_set_cols</span><span class="si">}</span><span class="s1">, </span><span class="si">{</span><span class="n">reorg_set_sname</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">reorg_set_cols</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">reorg_set_sname</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;Populate function is either-or for reorg_set_cols and reorg_set_sname; need to provide a template or names for new set or indexedset&#39;</span>
            <span class="p">)</span>

        <span class="c1"># reorganize_index_set --</span>
        <span class="k">if</span> <span class="n">reorg_set_sname</span><span class="p">:</span>
            <span class="n">reorg_set</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span> <span class="n">reorg_set_sname</span>
            <span class="p">)</span>  <span class="c1"># placeholder for a function that crosschecks the indices if desired</span>
            <span class="n">reorg_set_cols</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols_dict</span><span class="p">[</span><span class="n">reorg_set_sname</span><span class="p">]</span>

        <span class="c1"># reorganize_index_set -- Check to ensure names desired are included in the reorg set (or columns)</span>
        <span class="n">missing_elements</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">reorg_set_cols</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">set_in_cols</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">bool</span><span class="p">(</span><span class="n">missing_elements</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;Elements missing from input set desired in new set: </span><span class="si">{</span><span class="n">missing_elements</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="p">)</span>

        <span class="n">set_out_key_index</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">set_in_cols</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">reorg_set_cols</span><span class="p">])</span>
        <span class="n">set_out_val_index</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span>
            <span class="p">[</span><span class="n">set_in_cols</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">set_in_cols</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">reorg_set_cols</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="c1"># build dictionary result of the indexed set from the input set</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cols_dict</span><span class="p">[</span><span class="n">new_sname</span><span class="p">]</span> <span class="o">=</span> <span class="n">reorg_set_cols</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">set_in</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">element</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">set_out_key_index</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">element</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">set_out_val_index</span><span class="p">)</span>
            <span class="n">res</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="c1"># make the indexed set from keys -&gt; index set, data = the dictionary</span>

        <span class="c1"># Update cols_dict</span>
        <span class="n">set_out</span> <span class="o">=</span> <span class="n">pyo</span><span class="o">.</span><span class="n">Set</span><span class="p">(</span><span class="n">initialize</span><span class="o">=</span><span class="n">res</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">create_indexed_set</span><span class="p">:</span>
            <span class="n">set_out</span> <span class="o">=</span> <span class="n">pyo</span><span class="o">.</span><span class="n">Set</span><span class="p">(</span><span class="n">set_out</span><span class="p">,</span> <span class="n">initialize</span><span class="o">=</span><span class="n">res</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">return_set</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_sname</span><span class="p">,</span> <span class="n">set_out</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">set_out</span></div>


<div class="viewcode-block" id="Model.declare_set">
<a class="viewcode-back" href="../../../src.common.model.html#src.common.model.Model.declare_set">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">declare_set</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">sname</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">sdata</span><span class="p">:</span> <span class="n">MutableSequence</span> <span class="o">|</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span> <span class="o">|</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span> <span class="o">|</span> <span class="n">Dict</span><span class="p">,</span>
        <span class="n">scols</span><span class="p">:</span> <span class="n">MutableSequence</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">return_set</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">switch</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">create_indexed_set</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">use_values</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">use_columns</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Declares a pyomo Set object named &#39;sname&#39; using input index values and labels.</span>

<span class="sd">        Function handles input values and calls appropriate declare_set methods based on data</span>
<span class="sd">        type of sdata</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sname : str</span>
<span class="sd">            Name of set</span>
<span class="sd">        sdata : Dict</span>
<span class="sd">            Data object that contains set values</span>
<span class="sd">        scols : Sequence | None, optional</span>
<span class="sd">            List of column names corresponding to index labels and position, by default None</span>
<span class="sd">        return_set : bool | None, optional</span>
<span class="sd">            Return the set rather than assign within function, by default False</span>
<span class="sd">        switch : bool | None, optional</span>
<span class="sd">            Return None if False, by default True</span>
<span class="sd">        create_indexed_set : bool | None, optional</span>
<span class="sd">            If dict, indicator for whether output set should include values as well as new index (IndexedSets), by default True</span>
<span class="sd">        use_values : bool | None, optional</span>
<span class="sd">            If dict and create_indexed_set is False, use the values of sdata rather than keys for pyo Set members, by default False</span>
<span class="sd">        use_columns: bool | None, optional</span>
<span class="sd">            If Pandas, use columns as indices for pyo set rather than row index, by default False</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyo.Set</span>
<span class="sd">            Pyomo Set Object</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># declare_set -- Based on instance of sdata, call appropriate function and pass to sub-methods</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sdata</span><span class="p">,</span> <span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">)):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_declare_set_with_pandas</span><span class="p">(</span>
                <span class="n">sname</span><span class="p">,</span> <span class="n">sdata</span><span class="p">,</span> <span class="n">return_set</span><span class="o">=</span><span class="n">return_set</span><span class="p">,</span> <span class="n">switch</span><span class="o">=</span><span class="n">switch</span><span class="p">,</span> <span class="n">use_columns</span><span class="o">=</span><span class="n">use_columns</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sdata</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="nb">range</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_declare_set_with_iterable</span><span class="p">(</span>
                <span class="n">sname</span><span class="p">,</span>
                <span class="n">sdata</span><span class="p">,</span>
                <span class="n">scols</span><span class="o">=</span><span class="n">scols</span><span class="p">,</span>
                <span class="n">return_set</span><span class="o">=</span><span class="n">return_set</span><span class="p">,</span>
                <span class="n">switch</span><span class="o">=</span><span class="n">switch</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sdata</span><span class="p">,</span> <span class="p">(</span><span class="nb">dict</span><span class="p">,</span> <span class="n">defaultdict</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">scols</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;Provided dictionary data without index labels; specify labels in scols&#39;</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_declare_set_with_dict</span><span class="p">(</span>
                <span class="n">sname</span><span class="p">,</span>
                <span class="n">sdata</span><span class="p">,</span>
                <span class="n">scols</span><span class="p">,</span>
                <span class="n">return_set</span><span class="o">=</span><span class="n">return_set</span><span class="p">,</span>
                <span class="n">switch</span><span class="o">=</span><span class="n">switch</span><span class="p">,</span>
                <span class="n">create_indexed_set</span><span class="o">=</span><span class="n">create_indexed_set</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Object type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">sdata</span><span class="p">)</span><span class="si">}</span><span class="s2"> not supported in &#39;declare_set&#39;&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Model._declare_set_with_pandas">
<a class="viewcode-back" href="../../../src.common.model.html#src.common.model.Model._declare_set_with_pandas">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_declare_set_with_pandas</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">sname</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">sdata</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span> <span class="o">|</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span>
        <span class="n">return_set</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">switch</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">use_columns</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Declares a pyomo Set object named &#39;sname&#39; using input index values and labels from a</span>
<span class="sd">        Pandas object.</span>

<span class="sd">        Function assumes that the index values are the desired data to construct set object. User</span>
<span class="sd">        can specify whether to create set with column values instead</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sname : str</span>
<span class="sd">            Name of set</span>
<span class="sd">        sdata : MutableSequence | dict</span>
<span class="sd">            Data object that contains set indices</span>
<span class="sd">        return_set : bool | None, optional</span>
<span class="sd">            Return the set rather than assign within function, by default False</span>
<span class="sd">        switch : bool | None, optional</span>
<span class="sd">            Return None if False, by default True</span>
<span class="sd">        use_columns: bool | None, optional</span>
<span class="sd">            Use columns as indices for pyo set rather than row index, by default False</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyo.Set</span>
<span class="sd">            Pyomo Set Object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># declare_set -- If switch off, return empty set</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">switch</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">use_columns</span><span class="p">:</span>
            <span class="n">sset</span> <span class="o">=</span> <span class="n">pyo</span><span class="o">.</span><span class="n">Set</span><span class="p">(</span><span class="n">initialize</span><span class="o">=</span><span class="n">sdata</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
            <span class="n">scols</span> <span class="o">=</span> <span class="n">sdata</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">to_list</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sset</span> <span class="o">=</span> <span class="n">pyo</span><span class="o">.</span><span class="n">Set</span><span class="p">(</span><span class="n">initialize</span><span class="o">=</span><span class="n">sdata</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
            <span class="n">scols</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">sdata</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">scols</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">label</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Unnamed index in </span><span class="si">{</span><span class="n">sname</span><span class="si">}</span><span class="s1"> pandas object; check names of indices in input DataFrame or Series </span><span class="se">\</span>
<span class="s1">                    or set use_columns = True to create set with columnar data (and column names as index labels)&#39;</span><span class="p">)</span>

        <span class="c1"># declare_set -- update cols_dict with column names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cols_dict</span><span class="p">[</span><span class="n">sname</span><span class="p">]</span> <span class="o">=</span> <span class="n">scols</span>

        <span class="c1"># declare_set -- if return not desired, assign to self directly</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">return_set</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sname</span><span class="p">,</span> <span class="n">sset</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">sset</span></div>


<div class="viewcode-block" id="Model._declare_set_with_iterable">
<a class="viewcode-back" href="../../../src.common.model.html#src.common.model.Model._declare_set_with_iterable">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_declare_set_with_iterable</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">sname</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">sdata</span><span class="p">:</span> <span class="n">Sequence</span> <span class="o">|</span> <span class="n">Set</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span>
        <span class="n">scols</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">return_set</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">switch</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pyo</span><span class="o">.</span><span class="n">Set</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Declares a pyomo Set object named &#39;sname&#39; using input index values and labels.</span>

<span class="sd">        Function can take iterable objects such as tuples, lists, etc as data inputs. Note that if</span>
<span class="sd">        the dimension of the index is larger than 1, user needs to provide a list of names for each</span>
<span class="sd">        set dimension.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sname : str</span>
<span class="sd">            Name of set</span>
<span class="sd">        sdata : Sequence</span>
<span class="sd">            Data object that contains set values</span>
<span class="sd">        scols : Sequence | None, optional</span>
<span class="sd">            List of column names corresponding to index labels and position, by default None</span>
<span class="sd">        return_set : bool | None, optional</span>
<span class="sd">            Return the set rather than assign within function, by default False</span>
<span class="sd">        switch : bool | None, optional</span>
<span class="sd">            Return None if False, by default True</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyo.Set</span>
<span class="sd">            Pyomo Set Object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># declare_set_iterable -- If switch off , return None</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">switch</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># declare_set_iterable -- Check if empty, if yes, pass and return with warrnings</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sdata</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">empty</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">scols</span> <span class="o">=</span> <span class="n">sname</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;For </span><span class="si">{</span><span class="n">sname</span><span class="si">}</span><span class="s1">, sdata: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">sdata</span><span class="p">)</span><span class="si">}</span><span class="s1"> is length 0; returning empty set called </span><span class="si">{</span><span class="n">sname</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">empty</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># declare_set_with_iterable -- convert to list format if numpy array or set</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sdata</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">sdata</span> <span class="o">=</span> <span class="n">sdata</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sdata</span><span class="p">,</span> <span class="nb">set</span><span class="p">):</span>
            <span class="n">sdata</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">sdata</span><span class="p">)</span>

        <span class="c1"># declare_set_with_iterable -- initialize pyo set</span>
        <span class="n">sset</span> <span class="o">=</span> <span class="n">pyo</span><span class="o">.</span><span class="n">Set</span><span class="p">(</span><span class="n">initialize</span><span class="o">=</span><span class="n">sdata</span><span class="p">)</span>

        <span class="c1"># declare_set_with_iterable -- check to ensure column labels exist before assigning to cols_dict</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">scols</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">empty</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sdata</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sdata</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s1">&#39;if using list or set w/ multiple dimensional index, need to provide labels of indices&#39;</span>
                    <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;declare_set_with_iterable assumes desired index name is sname = </span><span class="si">{</span><span class="n">sname</span><span class="si">}</span><span class="s1"> when instantiating 1-D set&#39;</span>
                <span class="p">)</span>
                <span class="n">scols</span> <span class="o">=</span> <span class="p">[</span><span class="n">sname</span><span class="p">]</span>

        <span class="c1"># fix input if single string</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">scols</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">scols</span> <span class="o">=</span> <span class="p">[</span><span class="n">scols</span><span class="p">]</span>

        <span class="c1"># declare_set_with_iterable -- update cols_dict with column names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cols_dict</span><span class="p">[</span><span class="n">sname</span><span class="p">]</span> <span class="o">=</span> <span class="n">scols</span>

        <span class="c1"># declare_set -- if return not desired, assign to self directly</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">return_set</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sname</span><span class="p">,</span> <span class="n">sset</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">sset</span></div>


<div class="viewcode-block" id="Model._declare_set_with_dict">
<a class="viewcode-back" href="../../../src.common.model.html#src.common.model.Model._declare_set_with_dict">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_declare_set_with_dict</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">sname</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">sdata</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">|</span> <span class="n">DefaultDict</span><span class="p">,</span>
        <span class="n">scols</span><span class="p">:</span> <span class="n">MutableSequence</span><span class="p">,</span>
        <span class="n">return_set</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">switch</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">create_indexed_set</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">use_values</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pyo</span><span class="o">.</span><span class="n">Set</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Declares a pyomo Set object named &#39;sname&#39; using input index values and labels.</span>

<span class="sd">        Function takes a dictionary argument and creates pyomo set object from keys, values, or both.</span>

<span class="sd">        If an indexed set is desired, set create_indexed_set to True; the function will create an</span>
<span class="sd">        indexed set with its own indices set as keys. Otherwise, an Ordered Scalar Set will be</span>
<span class="sd">        created, either from the keys or the values of &#39;sdata&#39; depending on the value for</span>
<span class="sd">        &#39;use_values&#39; (False for keys, True for values).</span>

<span class="sd">        Names for the indices handled by scols; user must provide.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sname : str</span>
<span class="sd">            Name of set</span>
<span class="sd">        sdata : Dict</span>
<span class="sd">            Data object that contains set values</span>
<span class="sd">        scols : Sequence | None, optional</span>
<span class="sd">            List of column names corresponding to index labels and position, by default None</span>
<span class="sd">        return_set : bool | None, optional</span>
<span class="sd">            Return the set rather than assign within function, by default False</span>
<span class="sd">        switch : bool | None, optional</span>
<span class="sd">            Return None if False, by default True</span>
<span class="sd">        create_indexed_set : bool | None, optional</span>
<span class="sd">            Indicator for whether output set should include values as well as new index (IndexedSets), by default True</span>
<span class="sd">        use_values : bool | None, optional</span>
<span class="sd">            If create_indexed_set is False, use the values of sdata rather than keys for pyo Set members, by default False</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyo.Set</span>
<span class="sd">            Pyomo Set Object</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># declare_set_with_dict -- If switch off, return empty set</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">switch</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># declare_set_with_dict -- initialize set</span>
        <span class="k">if</span> <span class="n">create_indexed_set</span><span class="p">:</span>
            <span class="n">sset</span> <span class="o">=</span> <span class="n">pyo</span><span class="o">.</span><span class="n">Set</span><span class="p">(</span><span class="n">sdata</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">initialize</span><span class="o">=</span><span class="n">sdata</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">use_values</span><span class="p">:</span>
                <span class="n">sset</span> <span class="o">=</span> <span class="n">pyo</span><span class="o">.</span><span class="n">Set</span><span class="p">(</span><span class="n">initialize</span><span class="o">=</span><span class="n">sdata</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sset</span> <span class="o">=</span> <span class="n">pyo</span><span class="o">.</span><span class="n">Set</span><span class="p">(</span><span class="n">initialize</span><span class="o">=</span><span class="n">sdata</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="c1"># fix input if single string</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">scols</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">scols</span> <span class="o">=</span> <span class="p">[</span><span class="n">scols</span><span class="p">]</span>

        <span class="c1"># check if scols dim is equal to dimension of index</span>
        <span class="n">index_dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">([[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">sdata</span><span class="o">.</span><span class="n">keys</span><span class="p">()][</span><span class="mi">0</span><span class="p">]])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">scols</span><span class="p">)</span> <span class="o">!=</span> <span class="n">index_dim</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;number of index labels provided in scols (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">scols</span><span class="p">)</span><span class="si">}</span><span class="s2">) doesn&#39;t match dimension of index </span><span class="se">\</span>
<span class="s2">                in set (</span><span class="si">{</span><span class="n">index_dim</span><span class="si">}</span><span class="s2">). Check set_values and ensure </span><span class="se">\</span>
<span class="s2">                dimension of scols is equal to dimension of elements of values in sdata&quot;</span>
            <span class="p">)</span>

        <span class="c1"># declare_set_with_iterable -- update cols_dict with column names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cols_dict</span><span class="p">[</span><span class="n">sname</span><span class="p">]</span> <span class="o">=</span> <span class="n">scols</span>

        <span class="c1"># declare_set -- if return not desired, assign to self directly</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">return_set</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sname</span><span class="p">,</span> <span class="n">sset</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">sset</span></div>


<div class="viewcode-block" id="Model.declare_set_with_sets">
<a class="viewcode-back" href="../../../src.common.model.html#src.common.model.Model.declare_set_with_sets">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">declare_set_with_sets</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">sname</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="o">*</span><span class="n">sets</span><span class="p">:</span> <span class="n">pyo</span><span class="o">.</span><span class="n">Set</span><span class="p">,</span>
        <span class="n">return_set</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">switch</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pyo</span><span class="o">.</span><span class="n">Set</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Declares a new set object using input sets as arguments.</span>

<span class="sd">        Function creates a set product with set arguments to create a new set. This is how pyomo</span>
<span class="sd">        handles set creation with multiple existing sets as arguments.</span>

<span class="sd">        However, this function finds each pyomo set in column dictionary and unpacks the names,</span>
<span class="sd">        so that the new set can be logged in the column dictionary too.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sname : str</span>
<span class="sd">            Desired name of new set</span>
<span class="sd">        *sets : tuple of pyo.Set</span>
<span class="sd">            Unnamed arguments assumed to be pyomo sets</span>
<span class="sd">        return_set : bool | None, optional</span>
<span class="sd">            Return the set rather than assign within function, by default False</span>
<span class="sd">        switch : bool | None, optional</span>
<span class="sd">            Return None if False, by default True</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyo.Set</span>
<span class="sd">            Pyomo Set Object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># declare_set_with_sets -- If switch off, return empty set</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">switch</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># declare_set_with_sets -- Unpack arguments, create new name column, and new set product</span>
        <span class="n">new_set</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unpack_set_arguments</span><span class="p">(</span><span class="n">sname</span><span class="p">,</span> <span class="n">sets</span><span class="p">)</span>

        <span class="c1"># declare_set_with_sets -- unpack and create new set</span>
        <span class="n">sset</span> <span class="o">=</span> <span class="n">pyo</span><span class="o">.</span><span class="n">Set</span><span class="p">(</span><span class="n">initialize</span><span class="o">=</span><span class="n">new_set</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">return_set</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sname</span><span class="p">,</span> <span class="n">sset</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">sset</span></div>


<div class="viewcode-block" id="Model.declare_ordered_time_set">
<a class="viewcode-back" href="../../../src.common.model.html#src.common.model.Model.declare_ordered_time_set">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">declare_ordered_time_set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sname</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">*</span><span class="n">sets</span><span class="p">:</span> <span class="n">pyo</span><span class="o">.</span><span class="n">Set</span><span class="p">,</span> <span class="n">return_set</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Unnest the time sets into a single, unnested ordered, synchronous time set, an IndexedSet</span>
<span class="sd">        object keyed by the values in the time set, and an IndexedSet object keyed by the combined,</span>
<span class="sd">        original input sets.</span>

<span class="sd">        These three set outputs are directly set as attributes of the model instance:</span>

<span class="sd">        sname:               (1,) , (2, ), ... ,(N)</span>
<span class="sd">        sname_time_to_index: (1,):[set1, set2, set3] , (2,):[set1, set2, set3]</span>
<span class="sd">        sname_index_to_time: (set1, set2, set3): [1] , (set1, set2, set3): [2]</span>

<span class="sd">        In summary, this function creates three sets, creating a unique, ordered set from input sets</span>
<span class="sd">        with the assumption that they are given to the function in hierarchical order. For example,</span>
<span class="sd">        for a desired time set that orders Year, Month, Day values, the args for the function</span>
<span class="sd">        should be provided as:</span>

<span class="sd">        m.Year, m.Month, m.Day</span>

<span class="sd">        Pyomo set products are used to unpack and create new set values that are ordered by the</span>
<span class="sd">        hierarchy provided:</span>

<span class="sd">        (year1, month1, day1) , (year1, month1, day2) , ... , (year2, month1, day1) , ... (yearY, monthM, dayD)</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sname : str</span>
<span class="sd">            Desired root name for the new sets</span>
<span class="sd">        sets : pyo.Set</span>
<span class="sd">            A series of unnamed arguments assumed to contain pyo.Set in order of temporal hierarchy</span>
<span class="sd">        return_set : bool | None, optional</span>
<span class="sd">            Return the set rather than assign within function, by default False</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">            No return object; all sets assigned to model internally</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            &quot;No sets provided in args; provide pyo.Set objects to use this function&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># declare_ordered_time_set -- Unpack arguments, create new name column, and new set product</span>
        <span class="n">new_set</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unpack_set_arguments</span><span class="p">(</span><span class="n">sname</span><span class="p">,</span> <span class="n">sets</span><span class="p">)</span>

        <span class="c1"># declare_ordered_time_set -- s</span>
        <span class="n">n_times</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_set</span><span class="p">)</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">pyo</span><span class="o">.</span><span class="n">RangeSet</span><span class="p">(</span><span class="n">n_times</span><span class="p">)</span>

        <span class="c1"># declare_ordered_time_set -- create IndexSets to switch between singleton and full tuple</span>
        <span class="n">time_to_index</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">()</span>
        <span class="n">index_to_time</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">time</span><span class="p">:</span>
            <span class="n">time_to_index</span><span class="p">[</span><span class="n">element</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_set</span><span class="o">.</span><span class="n">at</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
            <span class="n">index_to_time</span><span class="p">[</span><span class="n">new_set</span><span class="o">.</span><span class="n">at</span><span class="p">(</span><span class="n">element</span><span class="p">)]</span> <span class="o">=</span> <span class="p">[</span><span class="n">element</span><span class="p">]</span>

        <span class="c1"># declare_ordered_time_sets -- create IndexedSets</span>
        <span class="n">time_to_index_set</span> <span class="o">=</span> <span class="n">pyo</span><span class="o">.</span><span class="n">Set</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">initialize</span><span class="o">=</span><span class="n">time_to_index</span><span class="p">)</span>
        <span class="n">index_to_time_set</span> <span class="o">=</span> <span class="n">pyo</span><span class="o">.</span><span class="n">Set</span><span class="p">(</span><span class="n">index_to_time</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">initialize</span><span class="o">=</span><span class="n">index_to_time</span><span class="p">)</span>

        <span class="c1"># declare_ordered_time_sets -- assign sets</span>
        <span class="n">time_setname</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">sname</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="n">time_index_setname</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">sname</span><span class="si">}</span><span class="s1">_time_to_index&#39;</span>
        <span class="n">index_time_setname</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">sname</span><span class="si">}</span><span class="s1">_index_to_time&#39;</span>

        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_setname</span><span class="p">,</span> <span class="n">time</span><span class="p">)</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_index_setname</span><span class="p">,</span> <span class="n">time_to_index_set</span><span class="p">)</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index_time_setname</span><span class="p">,</span> <span class="n">index_to_time_set</span><span class="p">)</span></div>


    <span class="c1"># I&#39;d love for someone to rewrite this; need to move on for now</span>
<div class="viewcode-block" id="Model.declare_shifted_time_set">
<a class="viewcode-back" href="../../../src.common.model.html#src.common.model.Model.declare_shifted_time_set">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">declare_shifted_time_set</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">sname</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">shift_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">shift_type</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s1">&#39;lag&#39;</span><span class="p">,</span> <span class="s1">&#39;lead&#39;</span><span class="p">],</span>
        <span class="o">*</span><span class="n">sets</span><span class="p">:</span> <span class="n">pyo</span><span class="o">.</span><span class="n">Set</span><span class="p">,</span>
        <span class="n">return_set</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">shift_sets</span><span class="p">:</span> <span class="n">List</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A generalize shifting function that creates sets compatible with leads or lags in pyomo</span>
<span class="sd">        components.</span>

<span class="sd">        For example, with a storage constraint where the current value is contrained to be equal to</span>
<span class="sd">        the value of storage in the previous period:</span>

<span class="sd">        model.storage[t] == model.storage[t-1] + ...</span>

<span class="sd">        The indexing set must be consistent with the storage variable, but not include elements that</span>
<span class="sd">        are undefined for this constraint. In this example, the set containing values for t must not</span>
<span class="sd">        include t = 1 (e.g. the lagged value must be defined). This function creates a shifted time</span>
<span class="sd">        set by removing values from the input sets to comply with the lags or leads.</span>

<span class="sd">        Function inputs require a shift size (in the example above, this would be 1), a shift type</span>
<span class="sd">        (lead or lag), and the sets used to construct the new, shifted set (model.timestep). If a</span>
<span class="sd">        lag or lead is required on a single dimension of the new set, the &#39;shift_sets&#39; argument can</span>
<span class="sd">        include a list of pyo.set names (included in the arguments) to shift by the other args.</span>

<span class="sd">        For example...</span>

<span class="sd">        model.storage[hub, season] == model.storage[hub, season - 1]</span>

<span class="sd">        In this case, season = 1 is always invalid due to the lag; so index (1, 2) or the value for</span>
<span class="sd">        hub = 1 and season = 2 is valid, but (2, 1) remains an invalid argument as there is no</span>
<span class="sd">        season = 0. A new set composed of hub and season, with shift_sets = [&quot;season&quot;] and</span>
<span class="sd">        sets = model.hub, model.season, is created to lag on one index value while leaving others</span>
<span class="sd">        unchanged.</span>

<span class="sd">        Default is to create set product of all input sets and lag/lead w/ resulting elements.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sname : str</span>
<span class="sd">            Desired name for new set</span>
<span class="sd">        shift_size : int</span>
<span class="sd">            Size of shift in set</span>
<span class="sd">        shift_type : str in [&quot;lag&quot;, &quot;lead&quot;]</span>
<span class="sd">            Type of shift (e.g. t-1 or t+1)</span>
<span class="sd">        *sets: Unnamed arguments</span>
<span class="sd">            A series of unnamed arguments assumed to contain pyo.Set in order of temporal hierarchy</span>
<span class="sd">        return_set : bool | None, optional</span>
<span class="sd">            Return the set rather than assign within function, by default False</span>
<span class="sd">        shift_sets : List | None, optional</span>
<span class="sd">            List of pyo.Set (by name) in *sets to shift, by default None</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyo.Set</span>
<span class="sd">            A pyomo Set</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            Shift sets don&#39;t align with *sets names</span>
<span class="sd">        ValueError</span>
<span class="sd">            Type argument is neither lead nor lag</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># declare_ordered_time_set  -- Unpack sets and assign indices to column dictionary; no need</span>
        <span class="c1"># to return set product</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unpack_set_arguments</span><span class="p">(</span><span class="n">sname</span><span class="p">,</span> <span class="n">sets</span><span class="p">,</span> <span class="n">return_set_product</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># declare_lagged_time_set  -- if time_sets provided, use timesets to lag; unpack into list</span>
        <span class="c1"># to modify set objects</span>
        <span class="n">setnames</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">getname</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">sets</span><span class="p">]</span>
        <span class="n">sets</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">sets</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">shift_sets</span><span class="p">:</span>
            <span class="n">shift_sets</span> <span class="o">=</span> <span class="p">[</span><span class="n">setnames</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>

        <span class="c1"># declare_lagged_time_set -- remove necessary elements for shifted sets</span>
        <span class="k">for</span> <span class="n">shift_set</span> <span class="ow">in</span> <span class="n">shift_sets</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">shift_set</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">setnames</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;You provided a shift set that was not included in the set arguments: </span><span class="si">{</span><span class="n">shift_set</span><span class="si">}</span><span class="s1">&#39;</span>
                <span class="p">)</span>

            <span class="n">shift_set_index</span> <span class="o">=</span> <span class="n">setnames</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">shift_set</span><span class="p">)</span>
            <span class="n">shifted_set</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">sets</span><span class="p">[</span><span class="n">shift_set_index</span><span class="p">]]</span>
            <span class="k">match</span> <span class="n">shift_type</span><span class="p">:</span>
                <span class="k">case</span> <span class="s1">&#39;lag&#39;</span><span class="p">:</span>
                    <span class="n">shifted_set</span> <span class="o">=</span> <span class="n">shifted_set</span><span class="p">[</span><span class="n">shift_size</span><span class="p">:]</span>
                <span class="k">case</span> <span class="s1">&#39;lead&#39;</span><span class="p">:</span>
                    <span class="n">shifted_set</span> <span class="o">=</span> <span class="n">shifted_set</span><span class="p">[:</span><span class="o">-</span><span class="n">shift_size</span><span class="p">]</span>
                <span class="k">case</span><span class="w"> </span><span class="k">_</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;type argument was neither lead nor lag&#39;</span><span class="p">)</span>
            <span class="n">sets</span><span class="p">[</span><span class="n">shift_set_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">pyo</span><span class="o">.</span><span class="n">Set</span><span class="p">(</span><span class="n">initialize</span><span class="o">=</span><span class="n">shifted_set</span><span class="p">)</span>

        <span class="c1"># declared_lagged_time_set -- create new set product</span>
        <span class="n">n_sets</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sets</span><span class="p">)</span>
        <span class="n">new_set</span> <span class="o">=</span> <span class="n">sets</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">n_sets</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">sset</span> <span class="ow">in</span> <span class="n">sets</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="n">new_set</span> <span class="o">=</span> <span class="n">new_set</span> <span class="o">*</span> <span class="n">sset</span>

        <span class="c1"># declare_lagged_time_set -- create new set and return if desired</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">return_set</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sname</span><span class="p">,</span> <span class="n">new_set</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">sset</span></div>


<div class="viewcode-block" id="Model.declare_param">
<a class="viewcode-back" href="../../../src.common.model.html#src.common.model.Model.declare_param">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">declare_param</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">pname</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">p_set</span><span class="p">:</span> <span class="n">pyo</span><span class="o">.</span><span class="n">Set</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">data</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">|</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span> <span class="o">|</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span> <span class="o">|</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">return_param</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">default</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">mutable</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pyo</span><span class="o">.</span><span class="n">Param</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Declares a pyo Parameter component named &#39;pname&#39; with the input data and index set.</span>

<span class="sd">        Unpacks column dictionary of index set for param instance and creates pyo.Param; either</span>
<span class="sd">        assigns the value internally or returns the object based on return_param.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pname : str</span>
<span class="sd">            Desired name of new pyo.Param instance</span>
<span class="sd">        p_set : pyo.Set</span>
<span class="sd">            Pyomo Set instance to index new Param</span>
<span class="sd">        data : dict | pd.DataFrame | pd.Series</span>
<span class="sd">            Data to initialize Param instance</span>
<span class="sd">        return_param : bool | None, optional</span>
<span class="sd">            Return the param after function call rather than assign to self, by default False</span>
<span class="sd">        default : int | None, optional</span>
<span class="sd">            pyo.Param keyword argument, by default 0</span>
<span class="sd">        mutable : bool | None, optional</span>
<span class="sd">            pyo.Param keyword argument, by default False</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyo.Param</span>
<span class="sd">            A pyomo Parameter instance</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            Raises error if input data not in format supported by function</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># declare_param -- For pandas objects, create param</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">)):</span>
            <span class="c1"># create param</span>
            <span class="n">param</span> <span class="o">=</span> <span class="n">pyo</span><span class="o">.</span><span class="n">Param</span><span class="p">(</span><span class="n">p_set</span><span class="p">,</span> <span class="n">initialize</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">default</span><span class="p">,</span> <span class="n">mutable</span><span class="o">=</span><span class="n">mutable</span><span class="p">)</span>

            <span class="c1"># update cols_dict</span>
            <span class="n">pcols</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
            <span class="n">pcols</span> <span class="o">=</span> <span class="n">pcols</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">pcols</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># declare_param -- for dictionaries, create param</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="nb">dict</span><span class="p">,</span> <span class="n">defaultdict</span><span class="p">)):</span>
            <span class="c1"># create param</span>
            <span class="n">param</span> <span class="o">=</span> <span class="n">pyo</span><span class="o">.</span><span class="n">Param</span><span class="p">(</span><span class="n">p_set</span><span class="p">,</span> <span class="n">initialize</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">default</span><span class="p">,</span> <span class="n">mutable</span><span class="o">=</span><span class="n">mutable</span><span class="p">)</span>

            <span class="c1"># Get set names from cols_dict and update with new entry</span>
            <span class="n">pcols</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols_dict</span><span class="p">[</span><span class="n">p_set</span><span class="o">.</span><span class="n">getname</span><span class="p">()]</span>
            <span class="n">pcols</span> <span class="o">=</span> <span class="p">[</span><span class="n">pname</span><span class="p">,</span> <span class="n">pcols</span><span class="p">]</span>

        <span class="c1"># declare_param -- for integers and floats</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="n">param</span> <span class="o">=</span> <span class="n">pyo</span><span class="o">.</span><span class="n">Param</span><span class="p">(</span><span class="n">initialize</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">default</span><span class="p">,</span> <span class="n">mutable</span><span class="o">=</span><span class="n">mutable</span><span class="p">)</span>
            <span class="n">pcols</span> <span class="o">=</span> <span class="p">[</span><span class="n">pname</span><span class="p">,</span> <span class="s1">&#39;None&#39;</span><span class="p">]</span>

        <span class="c1"># declare_param -- throw error if datatype not supported</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Data type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="si">}</span><span class="s1"> currently unsupported in declare_set method&#39;</span><span class="p">)</span>

        <span class="c1"># declare_param -- assign cols to cols_dict</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cols_dict</span><span class="p">[</span><span class="n">pname</span><span class="p">]</span> <span class="o">=</span> <span class="n">pcols</span>

        <span class="c1"># declare_param -- If return, return the param object or set attribute and return None</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">return_param</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pname</span><span class="p">,</span> <span class="n">param</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">param</span></div>


<div class="viewcode-block" id="Model.declare_var">
<a class="viewcode-back" href="../../../src.common.model.html#src.common.model.Model.declare_var">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">declare_var</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">vname</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">v_set</span><span class="p">:</span> <span class="n">pyo</span><span class="o">.</span><span class="n">Set</span><span class="p">,</span>
        <span class="n">return_var</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">within</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s1">&#39;NonNegativeReals&#39;</span><span class="p">,</span> <span class="s1">&#39;Binary&#39;</span><span class="p">,</span> <span class="s1">&#39;Reals&#39;</span><span class="p">,</span> <span class="s1">&#39;NonNegativeIntegers&#39;</span><span class="p">]</span>
        <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="s1">&#39;NonNegativeReals&#39;</span><span class="p">,</span>
        <span class="n">bound</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1000000000</span><span class="p">),</span>
        <span class="n">switch</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pyo</span><span class="o">.</span><span class="n">Var</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Declares a pyo Variable component named &#39;vname&#39; with index set &#39;v_set&#39;.</span>

<span class="sd">        Creates variable indexed by previously defined pyo Set instance &#39;v_set&#39; and assigns to self;</span>
<span class="sd">        function will return the component if return_var is set to True. Other keywords passed to</span>
<span class="sd">        pyo.Var are within and bound.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        vname : str</span>
<span class="sd">            Desired name of new pyo Variable</span>
<span class="sd">        v_set : pyo.Set</span>
<span class="sd">            Index set for new pyo Variable</span>
<span class="sd">        return_var : bool | None, optional</span>
<span class="sd">            Return component rather than assign internally, by default False</span>
<span class="sd">        within : str in [&quot;NonNegativeReals&quot;, &quot;Binary&quot;, &quot;Reals&quot;, &quot;NonNegativeIntegers&quot;] | None, optional</span>
<span class="sd">            pyo.Var keyword argument, by default &quot;NonNegativeReals&quot;</span>
<span class="sd">        bound : tuple | None, optional</span>
<span class="sd">            pyo.Var keyword argument, by default (0, 1000000000)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyo.Var</span>
<span class="sd">            A pyomo Variable instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># declare_var -- If switch off, return empty set</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">switch</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># declare_var -- Get domain object</span>
        <span class="n">domain</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">pyo</span><span class="p">,</span> <span class="n">within</span><span class="p">)</span>

        <span class="c1"># declare_var -- Create pyo.Var object with domain and bound</span>
        <span class="n">var</span> <span class="o">=</span> <span class="n">pyo</span><span class="o">.</span><span class="n">Var</span><span class="p">(</span><span class="n">v_set</span><span class="p">,</span> <span class="n">within</span><span class="o">=</span><span class="n">domain</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="n">bound</span><span class="p">)</span>

        <span class="c1"># declare_var -- Update cols_dict with variable name and index column names</span>
        <span class="n">sname</span> <span class="o">=</span> <span class="n">v_set</span><span class="o">.</span><span class="n">getname</span><span class="p">()</span>
        <span class="n">vcols</span> <span class="o">=</span> <span class="p">[</span><span class="n">vname</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols_dict</span><span class="p">[</span><span class="n">sname</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cols_dict</span><span class="p">[</span><span class="n">vname</span><span class="p">]</span> <span class="o">=</span> <span class="n">vcols</span>

        <span class="c1"># declare_var -- If not returning the variable, assign to model or return the var object</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">return_var</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vname</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">var</span></div>


<div class="viewcode-block" id="Model.unpack_set_arguments">
<a class="viewcode-back" href="../../../src.common.model.html#src.common.model.Model.unpack_set_arguments">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">unpack_set_arguments</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">sname</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">sets</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">pyo</span><span class="o">.</span><span class="n">Set</span><span class="p">],</span> <span class="n">return_set_product</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pyo</span><span class="o">.</span><span class="n">Set</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Handles unnamed pyo.Set arguments for multiple declaration functions.</span>

<span class="sd">        For an arbitrarily large number of set inputs, this function unpacks the names for each set</span>
<span class="sd">        stored in the column dictionary, creates a new list of the index labels and ordering, and</span>
<span class="sd">        then provides the pyo.Set product result as an output.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sname: str</span>
<span class="sd">            Name of new set</span>
<span class="sd">        sets: tuple of pyo.Set</span>
<span class="sd">            Tuple of pyo.Set arguments to be used to generate new set</span>
<span class="sd">        return_set_product: bool</span>
<span class="sd">            If True, return the unpacked set product</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        new_set : pyo.Set</span>
<span class="sd">            Set product result from input sets, by order of sets arguments</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># declare_ordered_time_set  -- Check for args</span>
        <span class="n">n_sets</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sets</span><span class="p">)</span>
        <span class="n">did_you_provide_any_sets</span> <span class="o">=</span> <span class="n">n_sets</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">did_you_provide_any_sets</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;No sets provided in *args; provide pyo.Set objects to use this function&#39;</span>
            <span class="p">)</span>

        <span class="c1"># declare_ordered_time_set -- get index names for index_to_time set</span>
        <span class="n">scols</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">sset</span> <span class="ow">in</span> <span class="n">sets</span><span class="p">:</span>
            <span class="n">scols</span> <span class="o">=</span> <span class="n">scols</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols_dict</span><span class="p">[</span><span class="n">sset</span><span class="o">.</span><span class="n">getname</span><span class="p">()]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cols_dict</span><span class="p">[</span><span class="n">sname</span><span class="p">]</span> <span class="o">=</span> <span class="n">scols</span>

        <span class="c1"># declare_ordered_time_set  -- unpack sets and save index names to cols_dict</span>
        <span class="k">if</span> <span class="n">return_set_product</span><span class="p">:</span>
            <span class="n">new_set</span> <span class="o">=</span> <span class="n">sets</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">n_sets</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">sset</span> <span class="ow">in</span> <span class="n">sets</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                    <span class="n">new_set</span> <span class="o">=</span> <span class="n">new_set</span> <span class="o">*</span> <span class="n">sset</span>
            <span class="k">return</span> <span class="n">new_set</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="Model.populate_sets_rule">
<a class="viewcode-back" href="../../../src.common.model.html#src.common.model.Model.populate_sets_rule">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">populate_sets_rule</span><span class="p">(</span><span class="n">m1</span><span class="p">,</span> <span class="n">sname</span><span class="p">,</span> <span class="n">set_base_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">set_base2</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pyo</span><span class="o">.</span><span class="n">Set</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generic function to create a new re-indexed set for a pyomo ConcreteModel instance which</span>
<span class="sd">        should speed up build time. Must pass non-empty (either) set_base_name or set_base2</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        m1 : pyo.ConcreteModel</span>
<span class="sd">            pyomo model instance</span>
<span class="sd">        sname : str</span>
<span class="sd">            name of input pyomo set to base reindexing</span>
<span class="sd">        set_base_name : str, optional</span>
<span class="sd">            the name of the set to be the base of the reindexing, if left blank, uses set_base2, by default &#39;&#39;</span>
<span class="sd">        set_base2 : list, optional</span>
<span class="sd">            the list of names of set columns to be the base of the reindexing, if left blank, should</span>
<span class="sd">            use set_base_name, by default [] these will form the index set of the indexed set structure</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyomo set</span>
<span class="sd">            reindexed set to be added to model</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># get a hook to the input set</span>
        <span class="n">set_in</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">m1</span><span class="p">,</span> <span class="n">sname</span><span class="p">)</span>
        <span class="c1"># get a hook to the column names for the set...</span>
        <span class="n">scols</span> <span class="o">=</span> <span class="n">m1</span><span class="o">.</span><span class="n">cols_dict</span><span class="p">[</span><span class="n">sname</span><span class="p">]</span>
        <span class="c1"># organize/locate the names of the index set based on input of set_base_name or set_base2</span>
        <span class="k">if</span> <span class="n">set_base_name</span> <span class="ow">and</span> <span class="n">set_base2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;Populate function is either-or for set_base_name and set_base2, received both: </span><span class="si">{</span><span class="n">set_base_name</span><span class="si">}</span><span class="s1">, </span><span class="si">{</span><span class="n">set_base2</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="p">)</span>
        <span class="n">label_locs</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">index_labels</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">set_base_name</span><span class="p">:</span>
            <span class="n">label_locs</span> <span class="o">=</span> <span class="n">scols</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">set_base_name</span><span class="p">)</span>
            <span class="n">index_labels</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">set_base_name</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">set_base2</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">label_locs</span> <span class="o">=</span> <span class="p">[</span><span class="n">scols</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">set_base2</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="n">missing_elements</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">set_base2</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">scols</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;These elements from set_base2 are not in the base set: </span><span class="si">{</span><span class="n">missing_elements</span><span class="si">}</span><span class="s1">&#39;</span>
                <span class="p">)</span>
            <span class="n">index_labels</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">set_base2</span><span class="p">)</span>
            <span class="c1"># look for case where we did NOT match all of the desired targets in set_base_2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Neither base name or set_base_2 provided&#39;</span><span class="p">)</span>

        <span class="c1"># pick up the &quot;data&quot; elements that are not in the index, in current order</span>
        <span class="n">data_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">scols</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">scols</span> <span class="k">if</span> <span class="n">t</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">index_labels</span><span class="p">]</span>

        <span class="c1"># build dictionary result of the indexed set from the input set</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">set_in</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span>
                <span class="nb">tuple</span><span class="p">(</span><span class="n">element</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">label_locs</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">label_locs</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>
                <span class="k">else</span> <span class="n">element</span><span class="p">[</span><span class="n">label_locs</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">element</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">data_indices</span><span class="p">)</span>
            <span class="n">res</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="c1"># make the indexed set from keys -&gt; index set, data = the dictionary</span>
        <span class="n">indexing_set</span> <span class="o">=</span> <span class="n">pyo</span><span class="o">.</span><span class="n">Set</span><span class="p">(</span><span class="n">initialize</span><span class="o">=</span><span class="n">res</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="n">t</span> <span class="o">=</span> <span class="n">pyo</span><span class="o">.</span><span class="n">Set</span><span class="p">(</span><span class="n">indexing_set</span><span class="p">,</span> <span class="n">initialize</span><span class="o">=</span><span class="n">res</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">t</span></div>


<div class="viewcode-block" id="Model.get_duals">
<a class="viewcode-back" href="../../../src.common.model.html#src.common.model.Model.get_duals">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_duals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">component_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">defaultdict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Extract duals from a solved model instance</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        component_name : str</span>
<span class="sd">            Name of constraint</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        defaultdict</span>
<span class="sd">            Dual values w/ index values</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># get_duals: get component</span>
        <span class="n">component</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">component_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">component</span><span class="p">,</span> <span class="n">pyo</span><span class="o">.</span><span class="n">Constraint</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;Component </span><span class="si">{</span><span class="n">component</span><span class="si">}</span><span class="s1"> is not a pyo.Constraint object; cannot extract duals&#39;</span>
            <span class="p">)</span>

        <span class="c1"># get_duals: set up dictionary to capture duals</span>
        <span class="n">dual_dict</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">component</span><span class="p">:</span>
            <span class="n">dual_dict</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dual</span><span class="p">[</span><span class="n">component</span><span class="p">[</span><span class="n">index</span><span class="p">]]</span>

        <span class="c1"># get_duals: return values</span>
        <span class="k">return</span> <span class="n">dual_dict</span></div>


    <span class="c1">###</span>
    <span class="c1"># Classes for decorator expressions</span>
    <span class="c1">###</span>

<div class="viewcode-block" id="Model.DefaultDecorator">
<a class="viewcode-back" href="../../../src.common.model.html#src.common.model.Model.DefaultDecorator">[docs]</a>
    <span class="k">class</span><span class="w"> </span><span class="nc">DefaultDecorator</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Default decorator class that handles assignment of model scope/pointer in order to use</span>
<span class="sd">        pyomo-style parameter and constraint decorators.</span>

<span class="sd">        Upon initialization, the decorator handles model assignment at class level to ensure</span>
<span class="sd">        inheriting classes have access to the models within local scope.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assign_model</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>

<div class="viewcode-block" id="Model.DefaultDecorator.assign_model">
<a class="viewcode-back" href="../../../src.common.model.html#src.common.model.Model.DefaultDecorator.assign_model">[docs]</a>
        <span class="nd">@classmethod</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">assign_model</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">model</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Class-method that assigns a model instance to DefaultDecorator</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            model : pyo.ConcreteModel</span>
<span class="sd">                A pyo model instance</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">model</span></div>
</div>


<div class="viewcode-block" id="Model.ParameterExpression">
<a class="viewcode-back" href="../../../src.common.model.html#src.common.model.Model.ParameterExpression">[docs]</a>
    <span class="k">class</span><span class="w"> </span><span class="nc">ParameterExpression</span><span class="p">(</span><span class="n">DefaultDecorator</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Parameter Expression decorator that works the same as pyomo decorators, while keeping</span>
<span class="sd">        column dictionary updated for any indexed parameters given.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Upon initialization, assign the model instance stored in DefaultDecorator to scope of</span>
<span class="sd">            constraint expression. Named and unnamed keywords assigned to instance.</span>

<span class="sd">            Arguments must be pyomo set instances, and named keywords need to be additional params</span>
<span class="sd">            passed to pyo.Constraint. This works in practice the same as decorator use in Pyomo.</span>

<span class="sd">            @model.ParameterExpression(model.set1, model.set2, keywordarg = &quot;value&quot;)</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_kwargs</span> <span class="o">=</span> <span class="n">kwargs</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">instance</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">model</span>

        <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expression</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Upon instantiation, __call__ unpacks indices for each argument in decorator and</span>
<span class="sd">            assigns to cols_dict. Keyword arguments unpack into creation of parameter object, and</span>
<span class="sd">            then parameter is assigned to the model instance pointed to in DefaultDecorator</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            expression : function</span>
<span class="sd">                Decorated function</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="c1"># wrapper -- use expression name and set names to update cols_dict</span>
            <span class="n">pname</span> <span class="o">=</span> <span class="n">expression</span><span class="o">.</span><span class="vm">__name__</span>
            <span class="n">scols</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">sset</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_args</span><span class="p">:</span>
                <span class="n">sname</span> <span class="o">=</span> <span class="n">sset</span><span class="o">.</span><span class="n">getname</span><span class="p">()</span>
                <span class="n">scols</span> <span class="o">=</span> <span class="p">[</span><span class="o">*</span><span class="n">scols</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="o">.</span><span class="n">cols_dict</span><span class="p">[</span><span class="n">sname</span><span class="p">]]</span>

                <span class="c1"># check if indexed_set; if so, replace w/ keys</span>
                <span class="k">if</span> <span class="n">sset</span><span class="o">.</span><span class="n">is_indexed</span><span class="p">():</span>
                    <span class="n">warning</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;Provided ParameterExpression with IndexedSet </span><span class="si">{</span><span class="n">sname</span><span class="si">}</span><span class="s1"> as Set argument for </span><span class="si">{</span><span class="n">pname</span><span class="si">}</span><span class="s1">; using keys to create OrderedScalarSet&#39;</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">warning</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_args</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_args</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">sset</span><span class="p">)]</span> <span class="o">=</span> <span class="n">pyo</span><span class="o">.</span><span class="n">Set</span><span class="p">(</span><span class="n">initialize</span><span class="o">=</span><span class="n">sset</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="o">.</span><span class="n">cols_dict</span><span class="p">[</span><span class="n">pname</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">pname</span><span class="p">]</span> <span class="o">+</span> <span class="n">scols</span>

            <span class="c1"># wrapper -- declare and create constraint</span>
            <span class="n">param</span> <span class="o">=</span> <span class="n">pyo</span><span class="o">.</span><span class="n">Param</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_args</span><span class="p">,</span> <span class="n">initialize</span><span class="o">=</span><span class="n">expression</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_kwargs</span><span class="p">)</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">,</span> <span class="n">pname</span><span class="p">,</span> <span class="n">param</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">expression</span></div>


<div class="viewcode-block" id="Model.ConstraintExpression">
<a class="viewcode-back" href="../../../src.common.model.html#src.common.model.Model.ConstraintExpression">[docs]</a>
    <span class="k">class</span><span class="w"> </span><span class="nc">ConstraintExpression</span><span class="p">(</span><span class="n">DefaultDecorator</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Constraint Expression decorator that works the same as pyomo decorators, while keeping</span>
<span class="sd">        column dictionary updated for any indexed parameters given.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Upon initialization, assign the model instance stored in DefaultDecorator to scope of</span>
<span class="sd">            constraint expression. Named and unnamed keywords assigned to instance.</span>

<span class="sd">            Arguments must be pyomo set instances, and named keywords need to be additional params</span>
<span class="sd">            passed to pyo.Constraint. This works in practice the same as decorator use in Pyomo.</span>

<span class="sd">            @model.ConstraintExpression(model.set1, model.set2, keywordarg = &quot;value&quot;)</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_kwargs</span> <span class="o">=</span> <span class="n">kwargs</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">instance</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">model</span>

        <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expression</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Upon instantiation, __call__ unpacks indices for each argument in decorator and</span>
<span class="sd">            assigns to cols_dict. Keyword arguments unpack into creation of constraint object, and</span>
<span class="sd">            then constraint is assigned to the model instance pointed to in DefaultDecorator</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            expression : function</span>
<span class="sd">                Decorated function</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="c1"># wrapper -- use expression name and set names to update cols_dict</span>
            <span class="n">cname</span> <span class="o">=</span> <span class="n">expression</span><span class="o">.</span><span class="vm">__name__</span>
            <span class="n">scols</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">sset</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_args</span><span class="p">:</span>
                <span class="n">sname</span> <span class="o">=</span> <span class="n">sset</span><span class="o">.</span><span class="n">getname</span><span class="p">()</span>
                <span class="n">scols</span> <span class="o">=</span> <span class="p">[</span><span class="o">*</span><span class="n">scols</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="o">.</span><span class="n">cols_dict</span><span class="p">[</span><span class="n">sname</span><span class="p">]]</span>

                <span class="c1"># check if indexed_set; if so, replace w/ keys</span>
                <span class="k">if</span> <span class="n">sset</span><span class="o">.</span><span class="n">is_indexed</span><span class="p">():</span>
                    <span class="n">warning</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;Provided ConstraintExpression with IndexedSet </span><span class="si">{</span><span class="n">sname</span><span class="si">}</span><span class="s1"> as Set argument for </span><span class="si">{</span><span class="n">cname</span><span class="si">}</span><span class="s1">; using keys to create OrderedScalarSet&#39;</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">warning</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_args</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_args</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">sset</span><span class="p">)]</span> <span class="o">=</span> <span class="n">pyo</span><span class="o">.</span><span class="n">Set</span><span class="p">(</span><span class="n">initialize</span><span class="o">=</span><span class="n">sset</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="o">.</span><span class="n">cols_dict</span><span class="p">[</span><span class="n">cname</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">cname</span><span class="p">]</span> <span class="o">+</span> <span class="n">scols</span>

            <span class="c1"># wrapper -- declare and create constraint</span>
            <span class="n">constraint</span> <span class="o">=</span> <span class="n">pyo</span><span class="o">.</span><span class="n">Constraint</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_args</span><span class="p">,</span> <span class="n">expr</span><span class="o">=</span><span class="n">expression</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_kwargs</span><span class="p">)</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">,</span> <span class="n">cname</span><span class="p">,</span> <span class="n">constraint</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">expression</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, U.S. Energy Information Administration.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>