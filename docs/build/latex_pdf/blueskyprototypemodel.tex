%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}

\PassOptionsToPackage{booktabs}{sphinx}
\PassOptionsToPackage{colorrows}{sphinx}

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{tgtermes}
\usepackage{tgheros}
\renewcommand{\ttdefault}{txtt}



\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=auto}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}


\usepackage{sphinxmessages}




\title{BlueSky Prototype Model}
\date{Apr 01, 2025}
\release{v1.1}
\author{U.S.\@{} Energy Information Administration}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\ifdefined\shorthandoff
  \ifnum\catcode`\=\string=\active\shorthandoff{=}\fi
  \ifnum\catcode`\"=\active\shorthandoff{"}\fi
\fi

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}



\chapter{Sphinx Documentation Structure}
\label{\detokenize{index:sphinx-documentation-structure}}
\sphinxAtStartPar
Sphinx organizes the documentation into the following sections:


\section{Package Overview}
\label{\detokenize{index:package-overview}}
\sphinxAtStartPar
The documentation starts with a general overview of the main package structure. In this project, the top\sphinxhyphen{}level package is \sphinxtitleref{src}. Inside the \sphinxtitleref{src} package, you will find the following main packages:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{electricity}: Contains modules related to electricity modeling and calculations.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{hydrogen}: Contains modules for hydrogen energy production, storage, and consumption.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{residential}: Contains models and utilities related to residential energy use.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{integrator}: Integrates components from various energy sources (electricity, hydrogen, etc.) into a cohesive system.

\end{itemize}


\section{Submodules and Subpackages}
\label{\detokenize{index:submodules-and-subpackages}}
\sphinxAtStartPar
Each package may contain additional submodules and subpackages, which are organized in the documentation as follows:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Package}: Each package (e.g., electricity, hydrogen) is documented with a high\sphinxhyphen{}level description of its purpose and contents.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Submodules}: The individual Python modules within each package are listed and documented. For example, the \sphinxtitleref{integrator} package may contain submodules like \sphinxtitleref{runner.py}, \sphinxtitleref{utilites.py}, and \sphinxtitleref{progress\_plot.py}. Each of these modules will have its own section.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Subpackages}: If a package contains nested subpackages, these are also documented. For instance, if \sphinxtitleref{electricity} has a subpackage \sphinxtitleref{scripts}, it will have its own subsection with corresponding submodules.

\end{itemize}

\sphinxAtStartPar
Each module’s docstrings are captured to provide detailed information about functions, classes, methods, and attributes.


\section{Example Structure}
\label{\detokenize{index:example-structure}}
\sphinxAtStartPar
For the \sphinxtitleref{src} package, Sphinx might organize the contents as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
src (package)/
├── integrator (subpackage)/
│   ├── input
│   └── runner.py (module)
└── models (subpackage)/
   ├── electricity (package)/
   │   └── scripts (subpackage)/
   │       ├── electricity\PYGZus{}model.py (module)
   │       └── preprocessor.py
   ├── hydrogen/
   │   ├── utilities/
   │   │   └── h2\PYGZus{}functions.py
   │   ├── model/
   │   │   └── h2\PYGZus{}model.py
   │   └── etc.
   └── residential/
      └── scripts/
            ├── residential.py
            └── utilites.py
\end{sphinxVerbatim}

\sphinxAtStartPar
In the HTML and Markdown outputs, each package and subpackage is represented with links \sphinxstylestrong{below} to the respective modules, making it easy to navigate between different sections of the documentation.

\sphinxAtStartPar
Use the \sphinxstylestrong{Search bar} on the top left to search for a specific function or module.


\section{Model Structure}
\label{\detokenize{index:model-structure}}

\begin{savenotes}
\sphinxatlongtablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\makeatletter
  \LTleft \@totalleftmargin plus1fill
  \LTright\dimexpr\columnwidth-\@totalleftmargin-\linewidth\relax plus1fill
\makeatother
\begin{longtable}{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\endfirsthead

\multicolumn{2}{c}{\sphinxnorowcolor
    \makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}%
}\\
\sphinxtoprule
\endhead

\sphinxbottomrule
\multicolumn{2}{r}{\sphinxnorowcolor
    \makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}%
}\\
\endfoot

\endlastfoot
\sphinxtableatstartofbodyhook

\sphinxAtStartPar
{\hyperref[\detokenize{src.models:module-src.models}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{src.models}}}}}
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src:module-src}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{src}}}}}
&
\sphinxAtStartPar
This directory contains the subdirectory for the integrator module and the subdirectories for the sectoral modules.
\\
\sphinxbottomrule
\end{longtable}
\sphinxtableafterendhook
\sphinxatlongtableend
\end{savenotes}

\sphinxstepscope


\subsection{src.models}
\label{\detokenize{src.models:module-src.models}}\label{\detokenize{src.models:src-models}}\label{\detokenize{src.models::doc}}\index{module@\spxentry{module}!src.models@\spxentry{src.models}}\index{src.models@\spxentry{src.models}!module@\spxentry{module}}\subsubsection*{Modules}


\begin{savenotes}
\sphinxatlongtablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\makeatletter
  \LTleft \@totalleftmargin plus1fill
  \LTright\dimexpr\columnwidth-\@totalleftmargin-\linewidth\relax plus1fill
\makeatother
\begin{longtable}{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\endfirsthead

\multicolumn{2}{c}{\sphinxnorowcolor
    \makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}%
}\\
\sphinxtoprule
\endhead

\sphinxbottomrule
\multicolumn{2}{r}{\sphinxnorowcolor
    \makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}%
}\\
\endfoot

\endlastfoot
\sphinxtableatstartofbodyhook

\sphinxAtStartPar
{\hyperref[\detokenize{src.models.electricity:module-src.models.electricity}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{electricity}}}}}
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.models.hydrogen:module-src.models.hydrogen}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{hydrogen}}}}}
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.models.residential:module-src.models.residential}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{residential}}}}}
&
\sphinxAtStartPar

\\
\sphinxbottomrule
\end{longtable}
\sphinxtableafterendhook
\sphinxatlongtableend
\end{savenotes}

\sphinxstepscope


\subsubsection{src.models.electricity}
\label{\detokenize{src.models.electricity:module-src.models.electricity}}\label{\detokenize{src.models.electricity:src-models-electricity}}\label{\detokenize{src.models.electricity::doc}}\index{module@\spxentry{module}!src.models.electricity@\spxentry{src.models.electricity}}\index{src.models.electricity@\spxentry{src.models.electricity}!module@\spxentry{module}}\subsubsection*{Modules}


\begin{savenotes}
\sphinxatlongtablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\makeatletter
  \LTleft \@totalleftmargin plus1fill
  \LTright\dimexpr\columnwidth-\@totalleftmargin-\linewidth\relax plus1fill
\makeatother
\begin{longtable}{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\endfirsthead

\multicolumn{2}{c}{\sphinxnorowcolor
    \makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}%
}\\
\sphinxtoprule
\endhead

\sphinxbottomrule
\multicolumn{2}{r}{\sphinxnorowcolor
    \makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}%
}\\
\endfoot

\endlastfoot
\sphinxtableatstartofbodyhook

\sphinxAtStartPar
{\hyperref[\detokenize{src.models.electricity.scripts:module-src.models.electricity.scripts}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{scripts}}}}}
&
\sphinxAtStartPar

\\
\sphinxbottomrule
\end{longtable}
\sphinxtableafterendhook
\sphinxatlongtableend
\end{savenotes}

\sphinxstepscope


\paragraph{src.models.electricity.scripts}
\label{\detokenize{src.models.electricity.scripts:module-src.models.electricity.scripts}}\label{\detokenize{src.models.electricity.scripts:src-models-electricity-scripts}}\label{\detokenize{src.models.electricity.scripts::doc}}\index{module@\spxentry{module}!src.models.electricity.scripts@\spxentry{src.models.electricity.scripts}}\index{src.models.electricity.scripts@\spxentry{src.models.electricity.scripts}!module@\spxentry{module}}\subsubsection*{Modules}


\begin{savenotes}
\sphinxatlongtablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\makeatletter
  \LTleft \@totalleftmargin plus1fill
  \LTright\dimexpr\columnwidth-\@totalleftmargin-\linewidth\relax plus1fill
\makeatother
\begin{longtable}{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\endfirsthead

\multicolumn{2}{c}{\sphinxnorowcolor
    \makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}%
}\\
\sphinxtoprule
\endhead

\sphinxbottomrule
\multicolumn{2}{r}{\sphinxnorowcolor
    \makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}%
}\\
\endfoot

\endlastfoot
\sphinxtableatstartofbodyhook

\sphinxAtStartPar
{\hyperref[\detokenize{src.models.electricity.scripts.electricity_model:module-src.models.electricity.scripts.electricity_model}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{electricity\_model}}}}}
&
\sphinxAtStartPar
Electricity Model, a pyomo optimization model of the electric power sector.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.models.electricity.scripts.postprocessor:module-src.models.electricity.scripts.postprocessor}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{postprocessor}}}}}
&
\sphinxAtStartPar
This file is the main postprocessor for the electricity model.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.models.electricity.scripts.preprocessor:module-src.models.electricity.scripts.preprocessor}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{preprocessor}}}}}
&
\sphinxAtStartPar
This file is the main preprocessor for the electricity model.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.models.electricity.scripts.runner:module-src.models.electricity.scripts.runner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{runner}}}}}
&
\sphinxAtStartPar
This file is a collection of functions that are used to build, run, and solve the electricity model.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.models.electricity.scripts.utilities:module-src.models.electricity.scripts.utilities}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{utilities}}}}}
&
\sphinxAtStartPar
This file is a collection of functions that are used in support of the electricity model.
\\
\sphinxbottomrule
\end{longtable}
\sphinxtableafterendhook
\sphinxatlongtableend
\end{savenotes}

\sphinxstepscope


\subparagraph{src.models.electricity.scripts.electricity\_model}
\label{\detokenize{src.models.electricity.scripts.electricity_model:module-src.models.electricity.scripts.electricity_model}}\label{\detokenize{src.models.electricity.scripts.electricity_model:src-models-electricity-scripts-electricity-model}}\label{\detokenize{src.models.electricity.scripts.electricity_model::doc}}\index{module@\spxentry{module}!src.models.electricity.scripts.electricity\_model@\spxentry{src.models.electricity.scripts.electricity\_model}}\index{src.models.electricity.scripts.electricity\_model@\spxentry{src.models.electricity.scripts.electricity\_model}!module@\spxentry{module}}
\sphinxAtStartPar
Electricity Model, a pyomo optimization model of the electric power sector.

\sphinxAtStartPar
The class is organized by sections: settings, sets, parameters, variables, objective function,
constraints, plus additional misc support functions.
\subsubsection*{Functions}


\begin{savenotes}
\sphinxatlongtablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\makeatletter
  \LTleft \@totalleftmargin plus1fill
  \LTright\dimexpr\columnwidth-\@totalleftmargin-\linewidth\relax plus1fill
\makeatother
\begin{longtable}{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\endfirsthead

\multicolumn{2}{c}{\sphinxnorowcolor
    \makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}%
}\\
\sphinxtoprule
\endhead

\sphinxbottomrule
\multicolumn{2}{r}{\sphinxnorowcolor
    \makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}%
}\\
\endfoot

\endlastfoot
\sphinxtableatstartofbodyhook

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{getLogger}}({[}name{]})
&
\sphinxAtStartPar
Return a logger with the specified name, creating it if necessary.
\\
\sphinxbottomrule
\end{longtable}
\sphinxtableafterendhook
\sphinxatlongtableend
\end{savenotes}
\subsubsection*{Classes}


\begin{savenotes}
\sphinxatlongtablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\makeatletter
  \LTleft \@totalleftmargin plus1fill
  \LTright\dimexpr\columnwidth-\@totalleftmargin-\linewidth\relax plus1fill
\makeatother
\begin{longtable}{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\endfirsthead

\multicolumn{2}{c}{\sphinxnorowcolor
    \makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}%
}\\
\sphinxtoprule
\endhead

\sphinxbottomrule
\multicolumn{2}{r}{\sphinxnorowcolor
    \makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}%
}\\
\endfoot

\endlastfoot
\sphinxtableatstartofbodyhook

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{HI}}(region, year)
&
\sphinxAtStartPar
(region, year)
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Model}}(*args, **kwds)
&
\sphinxAtStartPar
This is the base model class for the models.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.models.electricity.scripts.electricity_model:src.models.electricity.scripts.electricity_model.PowerModel}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{PowerModel}}}}}(*args, **kwds)
&
\sphinxAtStartPar
A PowerModel instance.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{defaultdict}}
&
\sphinxAtStartPar
defaultdict(default\_factory=None, /, {[}...{]}) \sphinxhyphen{}\sphinxhyphen{}\textgreater{} dict with default factory
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{em}}
&
\sphinxAtStartPar
alias of {\hyperref[\detokenize{src.models.electricity.scripts.utilities:src.models.electricity.scripts.utilities.ElectricityMethods}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ElectricityMethods}}}}}
\\
\sphinxbottomrule
\end{longtable}
\sphinxtableafterendhook
\sphinxatlongtableend
\end{savenotes}
\index{PowerModel (class in src.models.electricity.scripts.electricity\_model)@\spxentry{PowerModel}\spxextra{class in src.models.electricity.scripts.electricity\_model}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.electricity.scripts.electricity_model:src.models.electricity.scripts.electricity_model.PowerModel}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{\DUrole{k}{class}\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{src.models.electricity.scripts.electricity\_model.}}\sphinxbfcode{\sphinxupquote{PowerModel}}}
{\sphinxparam{\DUrole{o}{*}\DUrole{n}{args}}\sphinxparamcomma \sphinxparam{\DUrole{o}{**}\DUrole{n}{kwds}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
A PowerModel instance. Builds electricity pyomo model.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{all\_frames}} (\sphinxstyleliteralemphasis{\sphinxupquote{dictionary}}\sphinxstyleliteralemphasis{\sphinxupquote{ of }}\sphinxstyleliteralemphasis{\sphinxupquote{pd.DataFrames}}) \textendash{} Contains all dataframes of inputs

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{setA}} ({\hyperref[\detokenize{src.models.electricity.scripts.preprocessor:src.models.electricity.scripts.preprocessor.Sets}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Sets}}}}}) \textendash{} Contains all other non\sphinxhyphen{}dataframe inputs

\end{itemize}

\end{description}\end{quote}
\index{\_active (src.models.electricity.scripts.electricity\_model.PowerModel attribute)@\spxentry{\_active}\spxextra{src.models.electricity.scripts.electricity\_model.PowerModel attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.electricity.scripts.electricity_model:src.models.electricity.scripts.electricity_model.PowerModel._active}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{\_active}}}
\pysigstopsignatures
\end{fulllineitems}


\end{fulllineitems}


\sphinxstepscope


\subparagraph{src.models.electricity.scripts.postprocessor}
\label{\detokenize{src.models.electricity.scripts.postprocessor:module-src.models.electricity.scripts.postprocessor}}\label{\detokenize{src.models.electricity.scripts.postprocessor:src-models-electricity-scripts-postprocessor}}\label{\detokenize{src.models.electricity.scripts.postprocessor::doc}}\index{module@\spxentry{module}!src.models.electricity.scripts.postprocessor@\spxentry{src.models.electricity.scripts.postprocessor}}\index{src.models.electricity.scripts.postprocessor@\spxentry{src.models.electricity.scripts.postprocessor}!module@\spxentry{module}}
\sphinxAtStartPar
This file is the main postprocessor for the electricity model.
\begin{description}
\sphinxlineitem{It writes out all relevant model outputs (e.g., variables, parameters, constraints). It contains:}\begin{itemize}
\item {} 
\sphinxAtStartPar
A function that converts pyomo component objects to dataframes

\item {} 
\sphinxAtStartPar
A function that writes the dataframes to output directories

\item {} 
\sphinxAtStartPar
A function to make the electricity output sub\sphinxhyphen{}directories

\item {} 
\sphinxAtStartPar
The postprocessor function, which loops through the model component objects and applies the

\end{itemize}

\sphinxAtStartPar
functions to convert and write out the data to dfs to the electricity output sub\sphinxhyphen{}directories

\end{description}
\subsubsection*{Functions}


\begin{savenotes}
\sphinxatlongtablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\makeatletter
  \LTleft \@totalleftmargin plus1fill
  \LTright\dimexpr\columnwidth-\@totalleftmargin-\linewidth\relax plus1fill
\makeatother
\begin{longtable}{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\endfirsthead

\multicolumn{2}{c}{\sphinxnorowcolor
    \makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}%
}\\
\sphinxtoprule
\endhead

\sphinxbottomrule
\multicolumn{2}{r}{\sphinxnorowcolor
    \makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}%
}\\
\endfoot

\endlastfoot
\sphinxtableatstartofbodyhook

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{create\_obj\_df}}(mod\_object)
&
\sphinxAtStartPar
takes pyomo component objects (e.g., variables, parameters, constraints) and processes the pyomo data and converts it to a dataframe and then writes the dataframe out to an output dir.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{getLogger}}({[}name{]})
&
\sphinxAtStartPar
Return a logger with the specified name, creating it if necessary.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.models.electricity.scripts.postprocessor:src.models.electricity.scripts.postprocessor.make_elec_output_dir}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{make\_elec\_output\_dir}}}}}(output\_dir)
&
\sphinxAtStartPar
generates an output subdirectory to write electricity model results.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.models.electricity.scripts.postprocessor:src.models.electricity.scripts.postprocessor.postprocessor}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{postprocessor}}}}}(instance)
&
\sphinxAtStartPar
master postprocessor function that writes out the final dataframes from to the electricity model.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.models.electricity.scripts.postprocessor:src.models.electricity.scripts.postprocessor.report_obj_df}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{report\_obj\_df}}}}}(mod\_object, instance, dir\_out, ...)
&
\sphinxAtStartPar
Creates a df of the component object within the pyomo model, separates the key data into different columns and then names the columns if the names are included in the cols\_dict.
\\
\sphinxbottomrule
\end{longtable}
\sphinxtableafterendhook
\sphinxatlongtableend
\end{savenotes}
\subsubsection*{Classes}


\begin{savenotes}
\sphinxatlongtablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\makeatletter
  \LTleft \@totalleftmargin plus1fill
  \LTright\dimexpr\columnwidth-\@totalleftmargin-\linewidth\relax plus1fill
\makeatother
\begin{longtable}{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\endfirsthead

\multicolumn{2}{c}{\sphinxnorowcolor
    \makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}%
}\\
\sphinxtoprule
\endhead

\sphinxbottomrule
\multicolumn{2}{r}{\sphinxnorowcolor
    \makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}%
}\\
\endfoot

\endlastfoot
\sphinxtableatstartofbodyhook

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Path}}(*args, **kwargs)
&
\sphinxAtStartPar
PurePath subclass that can make system calls.
\\
\sphinxbottomrule
\end{longtable}
\sphinxtableafterendhook
\sphinxatlongtableend
\end{savenotes}
\index{make\_elec\_output\_dir() (in module src.models.electricity.scripts.postprocessor)@\spxentry{make\_elec\_output\_dir()}\spxextra{in module src.models.electricity.scripts.postprocessor}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.electricity.scripts.postprocessor:src.models.electricity.scripts.postprocessor.make_elec_output_dir}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{src.models.electricity.scripts.postprocessor.}}\sphinxbfcode{\sphinxupquote{make\_elec\_output\_dir}}}
{\sphinxparam{\DUrole{n}{output\_dir}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
generates an output subdirectory to write electricity model results. It includes subdirs for
vars, params, constraints.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
the name of the output directory

\sphinxlineitem{Return type}
\sphinxAtStartPar
string

\end{description}\end{quote}

\end{fulllineitems}

\index{postprocessor() (in module src.models.electricity.scripts.postprocessor)@\spxentry{postprocessor()}\spxextra{in module src.models.electricity.scripts.postprocessor}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.electricity.scripts.postprocessor:src.models.electricity.scripts.postprocessor.postprocessor}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{src.models.electricity.scripts.postprocessor.}}\sphinxbfcode{\sphinxupquote{postprocessor}}}
{\sphinxparam{\DUrole{n}{instance}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
master postprocessor function that writes out the final dataframes from to the electricity
model. Creates the output directories and writes out dataframes for variables, parameters, and
constraints. Gets the correct columns names for each dataframe using the cols\_dict.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{instance}} (\sphinxstyleliteralemphasis{\sphinxupquote{pyomo model}}) \textendash{} electricity concrete model

\sphinxlineitem{Returns}
\sphinxAtStartPar
output directory name

\sphinxlineitem{Return type}
\sphinxAtStartPar
string

\end{description}\end{quote}

\end{fulllineitems}

\index{report\_obj\_df() (in module src.models.electricity.scripts.postprocessor)@\spxentry{report\_obj\_df()}\spxextra{in module src.models.electricity.scripts.postprocessor}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.electricity.scripts.postprocessor:src.models.electricity.scripts.postprocessor.report_obj_df}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{src.models.electricity.scripts.postprocessor.}}\sphinxbfcode{\sphinxupquote{report\_obj\_df}}}
{\sphinxparam{\DUrole{n}{mod\_object}}\sphinxparamcomma \sphinxparam{\DUrole{n}{instance}}\sphinxparamcomma \sphinxparam{\DUrole{n}{dir\_out}}\sphinxparamcomma \sphinxparam{\DUrole{n}{sub\_dir}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Creates a df of the component object within the pyomo model, separates the key data into
different columns and then names the columns if the names are included in the cols\_dict.
Writes the df out to the output directory.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{obj}} (\sphinxstyleliteralemphasis{\sphinxupquote{pyomo component object}}) \textendash{} e.g., pyo.Var, pyo.Set, pyo.Param, pyo.Constraint

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{instance}} (\sphinxstyleliteralemphasis{\sphinxupquote{pyomo model}}) \textendash{} electricity concrete model

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{dir\_out}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} output electricity directory

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{sub\_dir}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} output electricity sub\sphinxhyphen{}directory

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\sphinxstepscope


\subparagraph{src.models.electricity.scripts.preprocessor}
\label{\detokenize{src.models.electricity.scripts.preprocessor:module-src.models.electricity.scripts.preprocessor}}\label{\detokenize{src.models.electricity.scripts.preprocessor:src-models-electricity-scripts-preprocessor}}\label{\detokenize{src.models.electricity.scripts.preprocessor::doc}}\index{module@\spxentry{module}!src.models.electricity.scripts.preprocessor@\spxentry{src.models.electricity.scripts.preprocessor}}\index{src.models.electricity.scripts.preprocessor@\spxentry{src.models.electricity.scripts.preprocessor}!module@\spxentry{module}}
\sphinxAtStartPar
This file is the main preprocessor for the electricity model.
\begin{description}
\sphinxlineitem{It established the parameters and sets that will be used in the model. It contains:}\begin{itemize}
\item {} 
\sphinxAtStartPar
A class that contains all sets used in the model

\item {} 
\sphinxAtStartPar
A collection of support functions to read in and setup parameter data

\item {} 
\sphinxAtStartPar
The preprocessor function, which produces an instance of the Set class and a dict of params

\item {} 
\sphinxAtStartPar
A collection of support functions to write out the inputs to the output directory

\end{itemize}

\end{description}
\subsubsection*{Functions}


\begin{savenotes}
\sphinxatlongtablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\makeatletter
  \LTleft \@totalleftmargin plus1fill
  \LTright\dimexpr\columnwidth-\@totalleftmargin-\linewidth\relax plus1fill
\makeatother
\begin{longtable}{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\endfirsthead

\multicolumn{2}{c}{\sphinxnorowcolor
    \makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}%
}\\
\sphinxtoprule
\endhead

\sphinxbottomrule
\multicolumn{2}{r}{\sphinxnorowcolor
    \makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}%
}\\
\endfoot

\endlastfoot
\sphinxtableatstartofbodyhook

\sphinxAtStartPar
{\hyperref[\detokenize{src.models.electricity.scripts.preprocessor:src.models.electricity.scripts.preprocessor.add_season_index}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{add\_season\_index}}}}}(cw\_temporal, df, pos)
&
\sphinxAtStartPar
adds a season index to the input dataframe
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.models.electricity.scripts.preprocessor:src.models.electricity.scripts.preprocessor.avg_by_group}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{avg\_by\_group}}}}}(df, set\_name, map\_frame)
&
\sphinxAtStartPar
takes in a dataframe and groups it by the set specified and then averages the data.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.models.electricity.scripts.preprocessor:src.models.electricity.scripts.preprocessor.capacitycredit_df}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{capacitycredit\_df}}}}}(all\_frames, setin)
&
\sphinxAtStartPar
builds the capacity credit dataframe
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.models.electricity.scripts.preprocessor:src.models.electricity.scripts.preprocessor.create_hourly_params}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{create\_hourly\_params}}}}}(all\_frames, key, cols)
&
\sphinxAtStartPar
Expands params that are indexed by season to be indexed by hour
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.models.electricity.scripts.preprocessor:src.models.electricity.scripts.preprocessor.create_hourly_sets}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{create\_hourly\_sets}}}}}(all\_frames, df)
&
\sphinxAtStartPar
expands sets that are indexed by season to be indexed by hour
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.models.electricity.scripts.preprocessor:src.models.electricity.scripts.preprocessor.create_other_sets}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{create\_other\_sets}}}}}(all\_frames, setin)
&
\sphinxAtStartPar
creates other (non\sphinxhyphen{}supply curve) sets
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.models.electricity.scripts.preprocessor:src.models.electricity.scripts.preprocessor.create_sc_sets}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{create\_sc\_sets}}}}}(all\_frames, setin)
&
\sphinxAtStartPar
creates supply curve sets
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.models.electricity.scripts.preprocessor:src.models.electricity.scripts.preprocessor.create_subsets}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{create\_subsets}}}}}(df, col, subset)
&
\sphinxAtStartPar
Create subsets off of full sets
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.models.electricity.scripts.preprocessor:src.models.electricity.scripts.preprocessor.fill_values}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{fill\_values}}}}}(row, subset\_list)
&
\sphinxAtStartPar
Function to fill in the subset values, is used to assign all years within the year solve range to each year the model will solve for.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.models.electricity.scripts.preprocessor:src.models.electricity.scripts.preprocessor.hourly_sc_subset}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{hourly\_sc\_subset}}}}}(all\_frames, subset)
&
\sphinxAtStartPar
Creates sets/subsets that are related to the supply curve
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.models.electricity.scripts.preprocessor:src.models.electricity.scripts.preprocessor.hr_sub_sc_subset}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{hr\_sub\_sc\_subset}}}}}(all\_frames, T\_subset, hr\_subset)
&
\sphinxAtStartPar
creates supply curve subsets by hour
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.models.electricity.scripts.preprocessor:src.models.electricity.scripts.preprocessor.load_data}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{load\_data}}}}}(tablename, metadata, engine)
&
\sphinxAtStartPar
loads the data from the SQL database; used in readin\_sql function.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.models.electricity.scripts.preprocessor:src.models.electricity.scripts.preprocessor.makedir}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{makedir}}}}}(dir\_out)
&
\sphinxAtStartPar
creates a folder directory based on the path provided
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.models.electricity.scripts.preprocessor:src.models.electricity.scripts.preprocessor.output_inputs}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{output\_inputs}}}}}(OUTPUT\_ROOT)
&
\sphinxAtStartPar
function developed initial for QA purposes, writes out to csv all of the dfs and sets passed to the electricity model to an output directory.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.models.electricity.scripts.preprocessor:src.models.electricity.scripts.preprocessor.preprocessor}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{preprocessor}}}}}(setin)
&
\sphinxAtStartPar
main preprocessor function that generates the final dataframes and sets sent over to the electricity model.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.models.electricity.scripts.preprocessor:src.models.electricity.scripts.preprocessor.print_sets}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{print\_sets}}}}}(setin)
&
\sphinxAtStartPar
function developed initially for QA purposes, prints out all of the sets passed to the electricity model.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.models.electricity.scripts.preprocessor:src.models.electricity.scripts.preprocessor.readin_csvs}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{readin\_csvs}}}}}(all\_frames)
&
\sphinxAtStartPar
Reads in all of the CSV files from the input dir and returns a dictionary of dataframes, where the key is the file name and the value is the table data.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.models.electricity.scripts.preprocessor:src.models.electricity.scripts.preprocessor.readin_sql}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{readin\_sql}}}}}(all\_frames)
&
\sphinxAtStartPar
Reads in all of the tables from a SQL databased and returns a dictionary of dataframes, where the key is the table name and the value is the table data.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{scale\_load}}(data\_root)
&
\sphinxAtStartPar
Reads in BaseLoad.csv (load for all regions/hours for first year) and LoadScalar.csv (a multiplier for all model years).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{scale\_load\_with\_enduses}}(data\_root)
&
\sphinxAtStartPar
Reads in BaseLoad.csv (load for all regions/hours for first year), EnduseBaseShares.csv (the shares of demand for each enduse in the base year) and EnduseScalar.csv (a multiplier for all model years by enduse category).
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.models.electricity.scripts.preprocessor:src.models.electricity.scripts.preprocessor.step_sub_sc_subset}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{step\_sub\_sc\_subset}}}}}(all\_frames, T\_subset, ...)
&
\sphinxAtStartPar
creates supply curve subsets by step
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.models.electricity.scripts.preprocessor:src.models.electricity.scripts.preprocessor.subset_dfs}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{subset\_dfs}}}}}(all\_frames, setin, i)
&
\sphinxAtStartPar
filters dataframes based on the values within the set
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.models.electricity.scripts.preprocessor:src.models.electricity.scripts.preprocessor.time_map}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{time\_map}}}}}(cw\_temporal, rename\_cols)
&
\sphinxAtStartPar
create temporal mapping parameters
\\
\sphinxbottomrule
\end{longtable}
\sphinxtableafterendhook
\sphinxatlongtableend
\end{savenotes}
\subsubsection*{Classes}


\begin{savenotes}
\sphinxatlongtablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\makeatletter
  \LTleft \@totalleftmargin plus1fill
  \LTright\dimexpr\columnwidth-\@totalleftmargin-\linewidth\relax plus1fill
\makeatother
\begin{longtable}{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\endfirsthead

\multicolumn{2}{c}{\sphinxnorowcolor
    \makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}%
}\\
\sphinxtoprule
\endhead

\sphinxbottomrule
\multicolumn{2}{r}{\sphinxnorowcolor
    \makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}%
}\\
\endfoot

\endlastfoot
\sphinxtableatstartofbodyhook

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Path}}(*args, **kwargs)
&
\sphinxAtStartPar
PurePath subclass that can make system calls.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.models.electricity.scripts.preprocessor:src.models.electricity.scripts.preprocessor.Sets}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Sets}}}}}(settings)
&
\sphinxAtStartPar
Generates an initial batch of sets that are used to solve electricity model.
\\
\sphinxbottomrule
\end{longtable}
\sphinxtableafterendhook
\sphinxatlongtableend
\end{savenotes}
\index{Sets (class in src.models.electricity.scripts.preprocessor)@\spxentry{Sets}\spxextra{class in src.models.electricity.scripts.preprocessor}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.electricity.scripts.preprocessor:src.models.electricity.scripts.preprocessor.Sets}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{\DUrole{k}{class}\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{src.models.electricity.scripts.preprocessor.}}\sphinxbfcode{\sphinxupquote{Sets}}}
{\sphinxparam{\DUrole{n}{settings}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Generates an initial batch of sets that are used to solve electricity model. Sets include:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Scenario descriptor and model switches

\item {} 
\sphinxAtStartPar
Regional sets

\item {} 
\sphinxAtStartPar
Temporal sets

\item {} 
\sphinxAtStartPar
Technology type sets

\item {} 
\sphinxAtStartPar
Supply curve step sets

\item {} 
\sphinxAtStartPar
Other

\end{itemize}

\end{fulllineitems}

\index{add\_season\_index() (in module src.models.electricity.scripts.preprocessor)@\spxentry{add\_season\_index()}\spxextra{in module src.models.electricity.scripts.preprocessor}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.electricity.scripts.preprocessor:src.models.electricity.scripts.preprocessor.add_season_index}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{src.models.electricity.scripts.preprocessor.}}\sphinxbfcode{\sphinxupquote{add\_season\_index}}}
{\sphinxparam{\DUrole{n}{cw\_temporal}}\sphinxparamcomma \sphinxparam{\DUrole{n}{df}}\sphinxparamcomma \sphinxparam{\DUrole{n}{pos}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
adds a season index to the input dataframe
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{cw\_temporal}} (\sphinxstyleliteralemphasis{\sphinxupquote{dataframe}}) \textendash{} dataframe that includes the season index

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{df}} (\sphinxstyleliteralemphasis{\sphinxupquote{dataframe}}) \textendash{} parameter data to be modified

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{pos}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} column position for the seasonal set

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
modified parameter data now indexed by season

\sphinxlineitem{Return type}
\sphinxAtStartPar
dataframe

\end{description}\end{quote}

\end{fulllineitems}

\index{avg\_by\_group() (in module src.models.electricity.scripts.preprocessor)@\spxentry{avg\_by\_group()}\spxextra{in module src.models.electricity.scripts.preprocessor}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.electricity.scripts.preprocessor:src.models.electricity.scripts.preprocessor.avg_by_group}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{src.models.electricity.scripts.preprocessor.}}\sphinxbfcode{\sphinxupquote{avg\_by\_group}}}
{\sphinxparam{\DUrole{n}{df}}\sphinxparamcomma \sphinxparam{\DUrole{n}{set\_name}}\sphinxparamcomma \sphinxparam{\DUrole{n}{map\_frame}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
takes in a dataframe and groups it by the set specified and then averages the data.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{df}} (\sphinxstyleliteralemphasis{\sphinxupquote{dataframe}}) \textendash{} parameter data to be modified

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{set\_name}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} name of the column/set to average the data by

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{map\_frame}} (\sphinxstyleliteralemphasis{\sphinxupquote{dataframe}}) \textendash{} data that maps the set name to the new grouping for that set

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
parameter data that is averaged by specified set mapping

\sphinxlineitem{Return type}
\sphinxAtStartPar
dataframe

\end{description}\end{quote}

\end{fulllineitems}

\index{capacitycredit\_df() (in module src.models.electricity.scripts.preprocessor)@\spxentry{capacitycredit\_df()}\spxextra{in module src.models.electricity.scripts.preprocessor}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.electricity.scripts.preprocessor:src.models.electricity.scripts.preprocessor.capacitycredit_df}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{src.models.electricity.scripts.preprocessor.}}\sphinxbfcode{\sphinxupquote{capacitycredit\_df}}}
{\sphinxparam{\DUrole{n}{all\_frames}}\sphinxparamcomma \sphinxparam{\DUrole{n}{setin}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
builds the capacity credit dataframe
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{all\_frames}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}\sphinxstyleliteralemphasis{\sphinxupquote{ of }}\sphinxstyleliteralemphasis{\sphinxupquote{pd.DataFrame}}) \textendash{} dictionary of dataframes where the key is the file name and the value is the table data

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{setin}} ({\hyperref[\detokenize{src.models.electricity.scripts.preprocessor:src.models.electricity.scripts.preprocessor.Sets}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Sets}}}}}) \textendash{} an initial batch of sets that are used to solve electricity model

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
formatted capacity credit data frame

\sphinxlineitem{Return type}
\sphinxAtStartPar
pd.DataFrame

\end{description}\end{quote}

\end{fulllineitems}

\index{create\_hourly\_params() (in module src.models.electricity.scripts.preprocessor)@\spxentry{create\_hourly\_params()}\spxextra{in module src.models.electricity.scripts.preprocessor}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.electricity.scripts.preprocessor:src.models.electricity.scripts.preprocessor.create_hourly_params}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{src.models.electricity.scripts.preprocessor.}}\sphinxbfcode{\sphinxupquote{create\_hourly\_params}}}
{\sphinxparam{\DUrole{n}{all\_frames}}\sphinxparamcomma \sphinxparam{\DUrole{n}{key}}\sphinxparamcomma \sphinxparam{\DUrole{n}{cols}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Expands params that are indexed by season to be indexed by hour
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{all\_frames}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}\sphinxstyleliteralemphasis{\sphinxupquote{ of }}\sphinxstyleliteralemphasis{\sphinxupquote{pd.DataFrame}}) \textendash{} dictionary of dataframes where the key is the file name and the value is the table data

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{key}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} name of data frame to access

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{cols}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} column names to keep in data frame

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
data frame with name key with new hourly index

\sphinxlineitem{Return type}
\sphinxAtStartPar
pd.DataFrame

\end{description}\end{quote}

\end{fulllineitems}

\index{create\_hourly\_sets() (in module src.models.electricity.scripts.preprocessor)@\spxentry{create\_hourly\_sets()}\spxextra{in module src.models.electricity.scripts.preprocessor}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.electricity.scripts.preprocessor:src.models.electricity.scripts.preprocessor.create_hourly_sets}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{src.models.electricity.scripts.preprocessor.}}\sphinxbfcode{\sphinxupquote{create\_hourly\_sets}}}
{\sphinxparam{\DUrole{n}{all\_frames}}\sphinxparamcomma \sphinxparam{\DUrole{n}{df}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
expands sets that are indexed by season to be indexed by hour
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{all\_frames}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}\sphinxstyleliteralemphasis{\sphinxupquote{ of }}\sphinxstyleliteralemphasis{\sphinxupquote{pd.DataFrame}}) \textendash{} dictionary of dataframes where the key is the file name and the value is the table data

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{df}} (\sphinxstyleliteralemphasis{\sphinxupquote{pd.DataFrame}}) \textendash{} data frame containing seasonal data

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
data frame containing updated hourly set

\sphinxlineitem{Return type}
\sphinxAtStartPar
pd.DataFrame

\end{description}\end{quote}

\end{fulllineitems}

\index{create\_other\_sets() (in module src.models.electricity.scripts.preprocessor)@\spxentry{create\_other\_sets()}\spxextra{in module src.models.electricity.scripts.preprocessor}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.electricity.scripts.preprocessor:src.models.electricity.scripts.preprocessor.create_other_sets}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{src.models.electricity.scripts.preprocessor.}}\sphinxbfcode{\sphinxupquote{create\_other\_sets}}}
{\sphinxparam{\DUrole{n}{all\_frames}}\sphinxparamcomma \sphinxparam{\DUrole{n}{setin}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
creates other (non\sphinxhyphen{}supply curve) sets
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{all\_frames}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}\sphinxstyleliteralemphasis{\sphinxupquote{ of }}\sphinxstyleliteralemphasis{\sphinxupquote{pd.DataFrame}}) \textendash{} dictionary of dataframes where the key is the file name and the value is the table data

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{setin}} ({\hyperref[\detokenize{src.models.electricity.scripts.preprocessor:src.models.electricity.scripts.preprocessor.Sets}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Sets}}}}}) \textendash{} an initial batch of sets that are used to solve electricity model

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
updated Sets which has non\sphinxhyphen{}supply curve\sphinxhyphen{}related sets updated

\sphinxlineitem{Return type}
\sphinxAtStartPar
{\hyperref[\detokenize{src.models.electricity.scripts.preprocessor:src.models.electricity.scripts.preprocessor.Sets}]{\sphinxcrossref{Sets}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{create\_sc\_sets() (in module src.models.electricity.scripts.preprocessor)@\spxentry{create\_sc\_sets()}\spxextra{in module src.models.electricity.scripts.preprocessor}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.electricity.scripts.preprocessor:src.models.electricity.scripts.preprocessor.create_sc_sets}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{src.models.electricity.scripts.preprocessor.}}\sphinxbfcode{\sphinxupquote{create\_sc\_sets}}}
{\sphinxparam{\DUrole{n}{all\_frames}}\sphinxparamcomma \sphinxparam{\DUrole{n}{setin}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
creates supply curve sets
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{all\_frames}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}\sphinxstyleliteralemphasis{\sphinxupquote{ of }}\sphinxstyleliteralemphasis{\sphinxupquote{pd.DataFrame}}) \textendash{} dictionary of dataframes where the key is the file name and the value is the table data

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{setin}} ({\hyperref[\detokenize{src.models.electricity.scripts.preprocessor:src.models.electricity.scripts.preprocessor.Sets}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Sets}}}}}) \textendash{} an initial batch of sets that are used to solve electricity model

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
updated Set containing all sets related to supply curve

\sphinxlineitem{Return type}
\sphinxAtStartPar
{\hyperref[\detokenize{src.models.electricity.scripts.preprocessor:src.models.electricity.scripts.preprocessor.Sets}]{\sphinxcrossref{Sets}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{create\_subsets() (in module src.models.electricity.scripts.preprocessor)@\spxentry{create\_subsets()}\spxextra{in module src.models.electricity.scripts.preprocessor}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.electricity.scripts.preprocessor:src.models.electricity.scripts.preprocessor.create_subsets}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{src.models.electricity.scripts.preprocessor.}}\sphinxbfcode{\sphinxupquote{create\_subsets}}}
{\sphinxparam{\DUrole{n}{df}}\sphinxparamcomma \sphinxparam{\DUrole{n}{col}}\sphinxparamcomma \sphinxparam{\DUrole{n}{subset}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Create subsets off of full sets
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{df}} (\sphinxstyleliteralemphasis{\sphinxupquote{pd.DataFrame}}) \textendash{} data frame of full data

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{col}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} column name

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{subset}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} names of values to subset

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
data frame containing subset of full data

\sphinxlineitem{Return type}
\sphinxAtStartPar
pd.DataFrame

\end{description}\end{quote}

\end{fulllineitems}

\index{fill\_values() (in module src.models.electricity.scripts.preprocessor)@\spxentry{fill\_values()}\spxextra{in module src.models.electricity.scripts.preprocessor}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.electricity.scripts.preprocessor:src.models.electricity.scripts.preprocessor.fill_values}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{src.models.electricity.scripts.preprocessor.}}\sphinxbfcode{\sphinxupquote{fill\_values}}}
{\sphinxparam{\DUrole{n}{row}}\sphinxparamcomma \sphinxparam{\DUrole{n}{subset\_list}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Function to fill in the subset values, is used to assign all years within the year
solve range to each year the model will solve for.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{row}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} row number in df

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{subset\_list}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}) \textendash{} list of values to map

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
value from subset\_list

\sphinxlineitem{Return type}
\sphinxAtStartPar
int

\end{description}\end{quote}

\end{fulllineitems}

\index{hourly\_sc\_subset() (in module src.models.electricity.scripts.preprocessor)@\spxentry{hourly\_sc\_subset()}\spxextra{in module src.models.electricity.scripts.preprocessor}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.electricity.scripts.preprocessor:src.models.electricity.scripts.preprocessor.hourly_sc_subset}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{src.models.electricity.scripts.preprocessor.}}\sphinxbfcode{\sphinxupquote{hourly\_sc\_subset}}}
{\sphinxparam{\DUrole{n}{all\_frames}}\sphinxparamcomma \sphinxparam{\DUrole{n}{subset}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Creates sets/subsets that are related to the supply curve
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{all\_frames}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}\sphinxstyleliteralemphasis{\sphinxupquote{ of }}\sphinxstyleliteralemphasis{\sphinxupquote{pd.DataFrame}}) \textendash{} dictionary of dataframes where the key is the file name and the value is the table data

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{subset}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}) \textendash{} list of technologies to subset

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
data frame containing sets/subsets related to supply curve

\sphinxlineitem{Return type}
\sphinxAtStartPar
pd.DataFrame

\end{description}\end{quote}

\end{fulllineitems}

\index{hr\_sub\_sc\_subset() (in module src.models.electricity.scripts.preprocessor)@\spxentry{hr\_sub\_sc\_subset()}\spxextra{in module src.models.electricity.scripts.preprocessor}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.electricity.scripts.preprocessor:src.models.electricity.scripts.preprocessor.hr_sub_sc_subset}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{src.models.electricity.scripts.preprocessor.}}\sphinxbfcode{\sphinxupquote{hr\_sub\_sc\_subset}}}
{\sphinxparam{\DUrole{n}{all\_frames}}\sphinxparamcomma \sphinxparam{\DUrole{n}{T\_subset}}\sphinxparamcomma \sphinxparam{\DUrole{n}{hr\_subset}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
creates supply curve subsets by hour
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{all\_frames}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}\sphinxstyleliteralemphasis{\sphinxupquote{ of }}\sphinxstyleliteralemphasis{\sphinxupquote{pd.DataFrame}}) \textendash{} dictionary of dataframes where the key is the file name and the value is the table data

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{T\_subset}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}) \textendash{} list of technologies to subset

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{hr\_subset}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}) \textendash{} list of hours to subset

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
data frame containing supply curve related hourly subset

\sphinxlineitem{Return type}
\sphinxAtStartPar
pd.DataFrame

\end{description}\end{quote}

\end{fulllineitems}

\index{load\_data() (in module src.models.electricity.scripts.preprocessor)@\spxentry{load\_data()}\spxextra{in module src.models.electricity.scripts.preprocessor}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.electricity.scripts.preprocessor:src.models.electricity.scripts.preprocessor.load_data}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{src.models.electricity.scripts.preprocessor.}}\sphinxbfcode{\sphinxupquote{load\_data}}}
{\sphinxparam{\DUrole{n}{tablename}}\sphinxparamcomma \sphinxparam{\DUrole{n}{metadata}}\sphinxparamcomma \sphinxparam{\DUrole{n}{engine}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
loads the data from the SQL database; used in readin\_sql function.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{tablename}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} table name

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{metadata}} (\sphinxstyleliteralemphasis{\sphinxupquote{SQL metadata}}) \textendash{} SQL metadata

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{engine}} (\sphinxstyleliteralemphasis{\sphinxupquote{SQL engine}}) \textendash{} SQL engine

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
table from SQL db as a dataframe

\sphinxlineitem{Return type}
\sphinxAtStartPar
dataframe

\end{description}\end{quote}

\end{fulllineitems}

\index{makedir() (in module src.models.electricity.scripts.preprocessor)@\spxentry{makedir()}\spxextra{in module src.models.electricity.scripts.preprocessor}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.electricity.scripts.preprocessor:src.models.electricity.scripts.preprocessor.makedir}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{src.models.electricity.scripts.preprocessor.}}\sphinxbfcode{\sphinxupquote{makedir}}}
{\sphinxparam{\DUrole{n}{dir\_out}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
creates a folder directory based on the path provided
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{dir\_out}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} path of directory

\end{description}\end{quote}

\end{fulllineitems}

\index{output\_inputs() (in module src.models.electricity.scripts.preprocessor)@\spxentry{output\_inputs()}\spxextra{in module src.models.electricity.scripts.preprocessor}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.electricity.scripts.preprocessor:src.models.electricity.scripts.preprocessor.output_inputs}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{src.models.electricity.scripts.preprocessor.}}\sphinxbfcode{\sphinxupquote{output\_inputs}}}
{\sphinxparam{\DUrole{n}{OUTPUT\_ROOT}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
function developed initial for QA purposes, writes out to csv all of the dfs and sets passed
to the electricity model to an output directory.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{OUTPUT\_ROOT}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} path of output directory

\sphinxlineitem{Returns}
\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{all\_frames} (\sphinxstyleemphasis{dictionary}) \textendash{} dictionary of dataframes where the key is the file name and the value is the table data

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{setin} (\sphinxstyleemphasis{Sets}) \textendash{} an initial batch of sets that are used to solve electricity model

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{preprocessor() (in module src.models.electricity.scripts.preprocessor)@\spxentry{preprocessor()}\spxextra{in module src.models.electricity.scripts.preprocessor}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.electricity.scripts.preprocessor:src.models.electricity.scripts.preprocessor.preprocessor}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{src.models.electricity.scripts.preprocessor.}}\sphinxbfcode{\sphinxupquote{preprocessor}}}
{\sphinxparam{\DUrole{n}{setin}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
main preprocessor function that generates the final dataframes and sets sent over to the
electricity model. This function reads in the input data, modifies it based on the temporal
and regional mapping specified in the inputs, and gets it into the final formatting needed.
Also adds some additional regional sets to the set class based on parameter inputs.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{setin}} ({\hyperref[\detokenize{src.models.electricity.scripts.preprocessor:src.models.electricity.scripts.preprocessor.Sets}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Sets}}}}}) \textendash{} an initial batch of sets that are used to solve electricity model

\sphinxlineitem{Returns}
\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{all\_frames} (\sphinxstyleemphasis{dictionary}) \textendash{} dictionary of dataframes where the key is the file name and the value is the table data

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{setin} (\sphinxstyleemphasis{Sets}) \textendash{} an initial batch of sets that are used to solve electricity model

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{print\_sets() (in module src.models.electricity.scripts.preprocessor)@\spxentry{print\_sets()}\spxextra{in module src.models.electricity.scripts.preprocessor}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.electricity.scripts.preprocessor:src.models.electricity.scripts.preprocessor.print_sets}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{src.models.electricity.scripts.preprocessor.}}\sphinxbfcode{\sphinxupquote{print\_sets}}}
{\sphinxparam{\DUrole{n}{setin}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
function developed initially for QA purposes, prints out all of the sets passed to the
electricity model.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{setin}} ({\hyperref[\detokenize{src.models.electricity.scripts.preprocessor:src.models.electricity.scripts.preprocessor.Sets}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Sets}}}}}) \textendash{} an initial batch of sets that are used to solve electricity model

\end{description}\end{quote}

\end{fulllineitems}

\index{readin\_csvs() (in module src.models.electricity.scripts.preprocessor)@\spxentry{readin\_csvs()}\spxextra{in module src.models.electricity.scripts.preprocessor}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.electricity.scripts.preprocessor:src.models.electricity.scripts.preprocessor.readin_csvs}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{src.models.electricity.scripts.preprocessor.}}\sphinxbfcode{\sphinxupquote{readin\_csvs}}}
{\sphinxparam{\DUrole{n}{all\_frames}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Reads in all of the CSV files from the input dir and returns a dictionary of dataframes,
where the key is the file name and the value is the table data.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{all\_frames}} (\sphinxstyleliteralemphasis{\sphinxupquote{dictionary}}) \textendash{} empty dictionary to be filled with dataframes

\sphinxlineitem{Returns}
\sphinxAtStartPar
completed dictionary filled with dataframes from the input directory

\sphinxlineitem{Return type}
\sphinxAtStartPar
dictionary

\end{description}\end{quote}

\end{fulllineitems}

\index{readin\_sql() (in module src.models.electricity.scripts.preprocessor)@\spxentry{readin\_sql()}\spxextra{in module src.models.electricity.scripts.preprocessor}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.electricity.scripts.preprocessor:src.models.electricity.scripts.preprocessor.readin_sql}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{src.models.electricity.scripts.preprocessor.}}\sphinxbfcode{\sphinxupquote{readin\_sql}}}
{\sphinxparam{\DUrole{n}{all\_frames}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Reads in all of the tables from a SQL databased and returns a dictionary of dataframes,
where the key is the table name and the value is the table data.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{all\_frames}} (\sphinxstyleliteralemphasis{\sphinxupquote{dictionary}}) \textendash{} empty dictionary to be filled with dataframes

\sphinxlineitem{Returns}
\sphinxAtStartPar
completed dictionary filled with dataframes from the input directory

\sphinxlineitem{Return type}
\sphinxAtStartPar
dictionary

\end{description}\end{quote}

\end{fulllineitems}

\index{step\_sub\_sc\_subset() (in module src.models.electricity.scripts.preprocessor)@\spxentry{step\_sub\_sc\_subset()}\spxextra{in module src.models.electricity.scripts.preprocessor}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.electricity.scripts.preprocessor:src.models.electricity.scripts.preprocessor.step_sub_sc_subset}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{src.models.electricity.scripts.preprocessor.}}\sphinxbfcode{\sphinxupquote{step\_sub\_sc\_subset}}}
{\sphinxparam{\DUrole{n}{all\_frames}}\sphinxparamcomma \sphinxparam{\DUrole{n}{T\_subset}}\sphinxparamcomma \sphinxparam{\DUrole{n}{step\_subset}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
creates supply curve subsets by step
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{all\_frames}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}\sphinxstyleliteralemphasis{\sphinxupquote{ of }}\sphinxstyleliteralemphasis{\sphinxupquote{pd.DataFrame}}) \textendash{} dictionary of dataframes where the key is the file name and the value is the table data

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{T\_subset}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}) \textendash{} technologies to subset

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{step\_subset}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}) \textendash{} step numbers to subset

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
data frame containing supply curve subsets by step

\sphinxlineitem{Return type}
\sphinxAtStartPar
pd.DataFrame

\end{description}\end{quote}

\end{fulllineitems}

\index{subset\_dfs() (in module src.models.electricity.scripts.preprocessor)@\spxentry{subset\_dfs()}\spxextra{in module src.models.electricity.scripts.preprocessor}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.electricity.scripts.preprocessor:src.models.electricity.scripts.preprocessor.subset_dfs}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{src.models.electricity.scripts.preprocessor.}}\sphinxbfcode{\sphinxupquote{subset\_dfs}}}
{\sphinxparam{\DUrole{n}{all\_frames}}\sphinxparamcomma \sphinxparam{\DUrole{n}{setin}}\sphinxparamcomma \sphinxparam{\DUrole{n}{i}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
filters dataframes based on the values within the set
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{all\_frames}} (\sphinxstyleliteralemphasis{\sphinxupquote{dictionary}}) \textendash{} dictionary of dataframes where the key is the file name and the value is the table data

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{setin}} ({\hyperref[\detokenize{src.models.electricity.scripts.preprocessor:src.models.electricity.scripts.preprocessor.Sets}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Sets}}}}}) \textendash{} contains an initial batch of sets that are used to solve electricity model

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{i}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} name of the set contained within the sets class that the df will be filtered based on.

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
completed dictionary filled with dataframes filtered based on set inputs specified

\sphinxlineitem{Return type}
\sphinxAtStartPar
dictionary

\end{description}\end{quote}

\end{fulllineitems}

\index{time\_map() (in module src.models.electricity.scripts.preprocessor)@\spxentry{time\_map()}\spxextra{in module src.models.electricity.scripts.preprocessor}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.electricity.scripts.preprocessor:src.models.electricity.scripts.preprocessor.time_map}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{src.models.electricity.scripts.preprocessor.}}\sphinxbfcode{\sphinxupquote{time\_map}}}
{\sphinxparam{\DUrole{n}{cw\_temporal}}\sphinxparamcomma \sphinxparam{\DUrole{n}{rename\_cols}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
create temporal mapping parameters
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{cw\_temporal}} (\sphinxstyleliteralemphasis{\sphinxupquote{pd.DataFrame}}) \textendash{} temporal crosswalks

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{rename\_cols}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} columns to rename from/to

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
data frame with temporal mapping parameters

\sphinxlineitem{Return type}
\sphinxAtStartPar
pd.DataFrame

\end{description}\end{quote}

\end{fulllineitems}


\sphinxstepscope


\subparagraph{src.models.electricity.scripts.runner}
\label{\detokenize{src.models.electricity.scripts.runner:module-src.models.electricity.scripts.runner}}\label{\detokenize{src.models.electricity.scripts.runner:src-models-electricity-scripts-runner}}\label{\detokenize{src.models.electricity.scripts.runner::doc}}\index{module@\spxentry{module}!src.models.electricity.scripts.runner@\spxentry{src.models.electricity.scripts.runner}}\index{src.models.electricity.scripts.runner@\spxentry{src.models.electricity.scripts.runner}!module@\spxentry{module}}
\sphinxAtStartPar
This file is a collection of functions that are used to build, run, and solve the electricity model.
\subsubsection*{Functions}


\begin{savenotes}
\sphinxatlongtablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\makeatletter
  \LTleft \@totalleftmargin plus1fill
  \LTright\dimexpr\columnwidth-\@totalleftmargin-\linewidth\relax plus1fill
\makeatother
\begin{longtable}{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\endfirsthead

\multicolumn{2}{c}{\sphinxnorowcolor
    \makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}%
}\\
\sphinxtoprule
\endhead

\sphinxbottomrule
\multicolumn{2}{r}{\sphinxnorowcolor
    \makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}%
}\\
\endfoot

\endlastfoot
\sphinxtableatstartofbodyhook

\sphinxAtStartPar
{\hyperref[\detokenize{src.models.electricity.scripts.runner:src.models.electricity.scripts.runner.build_elec_model}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{build\_elec\_model}}}}}(all\_frames, setin)
&
\sphinxAtStartPar
building pyomo electricity model
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{check\_results}}(results, SolutionStatus, ...)
&
\sphinxAtStartPar
Check results for termination condition and solution status
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.models.electricity.scripts.runner:src.models.electricity.scripts.runner.cost_learning_func}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{cost\_learning\_func}}}}}(instance, tech, y)
&
\sphinxAtStartPar
function for updating learning costs by technology and year
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{getLogger}}({[}name{]})
&
\sphinxAtStartPar
Return a logger with the specified name, creating it if necessary.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.models.electricity.scripts.runner:src.models.electricity.scripts.runner.init_old_cap}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{init\_old\_cap}}}}}(instance)
&
\sphinxAtStartPar
initialize capacity for 0th iteration
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{log\_infeasible\_constraints}}(m{[}, tol, logger, ...{]})
&
\sphinxAtStartPar
Logs the infeasible constraints in the model.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.models.electricity.scripts.runner:src.models.electricity.scripts.runner.run_elec_model}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{run\_elec\_model}}}}}(settings{[}, solve{]})
&
\sphinxAtStartPar
build electricity model (and solve if solve=True) after passing in settings
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{select\_solver}}(instance)
&
\sphinxAtStartPar
Select solver based on learning method
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.models.electricity.scripts.runner:src.models.electricity.scripts.runner.set_new_cap}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{set\_new\_cap}}}}}(instance)
&
\sphinxAtStartPar
calculate new capacity after solve iteration
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.models.electricity.scripts.runner:src.models.electricity.scripts.runner.solve_elec_model}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{solve\_elec\_model}}}}}(instance)
&
\sphinxAtStartPar
solve electicity model
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.models.electricity.scripts.runner:src.models.electricity.scripts.runner.update_cost}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{update\_cost}}}}}(instance)
&
\sphinxAtStartPar
update capital cost based on new capacity learning
\\
\sphinxbottomrule
\end{longtable}
\sphinxtableafterendhook
\sphinxatlongtableend
\end{savenotes}
\subsubsection*{Classes}


\begin{savenotes}
\sphinxatlongtablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\makeatletter
  \LTleft \@totalleftmargin plus1fill
  \LTright\dimexpr\columnwidth-\@totalleftmargin-\linewidth\relax plus1fill
\makeatother
\begin{longtable}{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\endfirsthead

\multicolumn{2}{c}{\sphinxnorowcolor
    \makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}%
}\\
\sphinxtoprule
\endhead

\sphinxbottomrule
\multicolumn{2}{r}{\sphinxnorowcolor
    \makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}%
}\\
\endfoot

\endlastfoot
\sphinxtableatstartofbodyhook

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Config\_settings}}(config\_path{[}, args, test{]})
&
\sphinxAtStartPar
Generates the model settings that are used to solve.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Path}}(*args, **kwargs)
&
\sphinxAtStartPar
PurePath subclass that can make system calls.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{PowerModel}}(*args, **kwds)
&
\sphinxAtStartPar
A PowerModel instance.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SolutionStatus}}(*values)
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SolverStatus}}(*values)
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{TerminationCondition}}(*values)
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{TicTocTimer}}({[}ostream, logger{]})
&
\sphinxAtStartPar
A class to calculate and report elapsed time.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{datetime}}(year, month, day{[}, hour{[}, minute{[}, ...)
&
\sphinxAtStartPar
The year, month and day arguments are required.
\\
\sphinxbottomrule
\end{longtable}
\sphinxtableafterendhook
\sphinxatlongtableend
\end{savenotes}
\index{build\_elec\_model() (in module src.models.electricity.scripts.runner)@\spxentry{build\_elec\_model()}\spxextra{in module src.models.electricity.scripts.runner}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.electricity.scripts.runner:src.models.electricity.scripts.runner.build_elec_model}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{src.models.electricity.scripts.runner.}}\sphinxbfcode{\sphinxupquote{build\_elec\_model}}}
{\sphinxparam{\DUrole{n}{all\_frames}}\sphinxparamcomma \sphinxparam{\DUrole{n}{setin}}}
{{ $\rightarrow$ {\hyperref[\detokenize{src.models.electricity.scripts.electricity_model:src.models.electricity.scripts.electricity_model.PowerModel}]{\sphinxcrossref{PowerModel}}}}}
\pysigstopsignatures
\sphinxAtStartPar
building pyomo electricity model
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{all\_frames}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}\sphinxstyleliteralemphasis{\sphinxupquote{ of }}\sphinxstyleliteralemphasis{\sphinxupquote{pd.DataFrame}}) \textendash{} input data frames

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{setin}} ({\hyperref[\detokenize{src.models.electricity.scripts.preprocessor:src.models.electricity.scripts.preprocessor.Sets}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Sets}}}}}) \textendash{} input settings Sets

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
built (but unsolved) electricity model

\sphinxlineitem{Return type}
\sphinxAtStartPar
{\hyperref[\detokenize{src.models.electricity.scripts.electricity_model:src.models.electricity.scripts.electricity_model.PowerModel}]{\sphinxcrossref{PowerModel}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{cost\_learning\_func() (in module src.models.electricity.scripts.runner)@\spxentry{cost\_learning\_func()}\spxextra{in module src.models.electricity.scripts.runner}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.electricity.scripts.runner:src.models.electricity.scripts.runner.cost_learning_func}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{src.models.electricity.scripts.runner.}}\sphinxbfcode{\sphinxupquote{cost\_learning\_func}}}
{\sphinxparam{\DUrole{n}{instance}}\sphinxparamcomma \sphinxparam{\DUrole{n}{tech}}\sphinxparamcomma \sphinxparam{\DUrole{n}{y}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
function for updating learning costs by technology and year
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{instance}} ({\hyperref[\detokenize{src.models.electricity.scripts.electricity_model:src.models.electricity.scripts.electricity_model.PowerModel}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{PowerModel}}}}}) \textendash{} electricity pyomo model

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{tech}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} technology type

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{y}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} year

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
updated capital cost based on learning calculation

\sphinxlineitem{Return type}
\sphinxAtStartPar
int

\end{description}\end{quote}

\end{fulllineitems}

\index{init\_old\_cap() (in module src.models.electricity.scripts.runner)@\spxentry{init\_old\_cap()}\spxextra{in module src.models.electricity.scripts.runner}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.electricity.scripts.runner:src.models.electricity.scripts.runner.init_old_cap}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{src.models.electricity.scripts.runner.}}\sphinxbfcode{\sphinxupquote{init\_old\_cap}}}
{\sphinxparam{\DUrole{n}{instance}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
initialize capacity for 0th iteration
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{instance}} ({\hyperref[\detokenize{src.models.electricity.scripts.electricity_model:src.models.electricity.scripts.electricity_model.PowerModel}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{PowerModel}}}}}) \textendash{} unsolved electricity model

\end{description}\end{quote}

\end{fulllineitems}

\index{run\_elec\_model() (in module src.models.electricity.scripts.runner)@\spxentry{run\_elec\_model()}\spxextra{in module src.models.electricity.scripts.runner}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.electricity.scripts.runner:src.models.electricity.scripts.runner.run_elec_model}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{src.models.electricity.scripts.runner.}}\sphinxbfcode{\sphinxupquote{run\_elec\_model}}}
{\sphinxparam{\DUrole{n}{settings}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{{\hyperref[\detokenize{src.common.config_setup:src.common.config_setup.Config_settings}]{\sphinxcrossref{Config\_settings}}}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{solve}\DUrole{o}{=}\DUrole{default_value}{True}}}
{{ $\rightarrow$ {\hyperref[\detokenize{src.models.electricity.scripts.electricity_model:src.models.electricity.scripts.electricity_model.PowerModel}]{\sphinxcrossref{PowerModel}}}}}
\pysigstopsignatures
\sphinxAtStartPar
build electricity model (and solve if solve=True) after passing in settings
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{settings}} ({\hyperref[\detokenize{src.common.config_setup:src.common.config_setup.Config_settings}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Config\_settings}}}}}) \textendash{} Configuration settings

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{solve}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} solve electricity model?, by default True

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
electricity model

\sphinxlineitem{Return type}
\sphinxAtStartPar
{\hyperref[\detokenize{src.models.electricity.scripts.electricity_model:src.models.electricity.scripts.electricity_model.PowerModel}]{\sphinxcrossref{PowerModel}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_new\_cap() (in module src.models.electricity.scripts.runner)@\spxentry{set\_new\_cap()}\spxextra{in module src.models.electricity.scripts.runner}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.electricity.scripts.runner:src.models.electricity.scripts.runner.set_new_cap}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{src.models.electricity.scripts.runner.}}\sphinxbfcode{\sphinxupquote{set\_new\_cap}}}
{\sphinxparam{\DUrole{n}{instance}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
calculate new capacity after solve iteration
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{instance}} ({\hyperref[\detokenize{src.models.electricity.scripts.electricity_model:src.models.electricity.scripts.electricity_model.PowerModel}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{PowerModel}}}}}) \textendash{} solved electricity pyomo model

\end{description}\end{quote}

\end{fulllineitems}

\index{solve\_elec\_model() (in module src.models.electricity.scripts.runner)@\spxentry{solve\_elec\_model()}\spxextra{in module src.models.electricity.scripts.runner}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.electricity.scripts.runner:src.models.electricity.scripts.runner.solve_elec_model}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{src.models.electricity.scripts.runner.}}\sphinxbfcode{\sphinxupquote{solve\_elec\_model}}}
{\sphinxparam{\DUrole{n}{instance}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
solve electicity model
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{instance}} ({\hyperref[\detokenize{src.models.electricity.scripts.electricity_model:src.models.electricity.scripts.electricity_model.PowerModel}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{PowerModel}}}}}) \textendash{} built (but not solved) electricity pyomo model

\end{description}\end{quote}

\end{fulllineitems}

\index{update\_cost() (in module src.models.electricity.scripts.runner)@\spxentry{update\_cost()}\spxextra{in module src.models.electricity.scripts.runner}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.electricity.scripts.runner:src.models.electricity.scripts.runner.update_cost}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{src.models.electricity.scripts.runner.}}\sphinxbfcode{\sphinxupquote{update\_cost}}}
{\sphinxparam{\DUrole{n}{instance}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
update capital cost based on new capacity learning
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{instance}} ({\hyperref[\detokenize{src.models.electricity.scripts.electricity_model:src.models.electricity.scripts.electricity_model.PowerModel}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{PowerModel}}}}}) \textendash{} electricity pyomo model

\end{description}\end{quote}

\end{fulllineitems}


\sphinxstepscope


\subparagraph{src.models.electricity.scripts.utilities}
\label{\detokenize{src.models.electricity.scripts.utilities:module-src.models.electricity.scripts.utilities}}\label{\detokenize{src.models.electricity.scripts.utilities:src-models-electricity-scripts-utilities}}\label{\detokenize{src.models.electricity.scripts.utilities::doc}}\index{module@\spxentry{module}!src.models.electricity.scripts.utilities@\spxentry{src.models.electricity.scripts.utilities}}\index{src.models.electricity.scripts.utilities@\spxentry{src.models.electricity.scripts.utilities}!module@\spxentry{module}}
\sphinxAtStartPar
This file is a collection of functions that are used in support of the electricity model.
\subsubsection*{Functions}


\begin{savenotes}
\sphinxatlongtablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\makeatletter
  \LTleft \@totalleftmargin plus1fill
  \LTright\dimexpr\columnwidth-\@totalleftmargin-\linewidth\relax plus1fill
\makeatother
\begin{longtable}{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\endfirsthead

\multicolumn{2}{c}{\sphinxnorowcolor
    \makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}%
}\\
\sphinxtoprule
\endhead

\sphinxbottomrule
\multicolumn{2}{r}{\sphinxnorowcolor
    \makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}%
}\\
\endfoot

\endlastfoot
\sphinxtableatstartofbodyhook

\sphinxAtStartPar
{\hyperref[\detokenize{src.models.electricity.scripts.utilities:src.models.electricity.scripts.utilities.annual_count}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{annual\_count}}}}}(hour, m)
&
\sphinxAtStartPar
return the aggregate weight of this hour in the representative year we know the hour weight, and the hours are unique to days, so we can get the day weight
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.models.electricity.scripts.utilities:src.models.electricity.scripts.utilities.check_results}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{check\_results}}}}}(results, SolutionStatus, ...)
&
\sphinxAtStartPar
Check results for termination condition and solution status
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.models.electricity.scripts.utilities:src.models.electricity.scripts.utilities.create_obj_df}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{create\_obj\_df}}}}}(mod\_object)
&
\sphinxAtStartPar
takes pyomo component objects (e.g., variables, parameters, constraints) and processes the pyomo data and converts it to a dataframe and then writes the dataframe out to an output dir.
\\
\sphinxbottomrule
\end{longtable}
\sphinxtableafterendhook
\sphinxatlongtableend
\end{savenotes}
\subsubsection*{Classes}


\begin{savenotes}
\sphinxatlongtablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\makeatletter
  \LTleft \@totalleftmargin plus1fill
  \LTright\dimexpr\columnwidth-\@totalleftmargin-\linewidth\relax plus1fill
\makeatother
\begin{longtable}{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\endfirsthead

\multicolumn{2}{c}{\sphinxnorowcolor
    \makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}%
}\\
\sphinxtoprule
\endhead

\sphinxbottomrule
\multicolumn{2}{r}{\sphinxnorowcolor
    \makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}%
}\\
\endfoot

\endlastfoot
\sphinxtableatstartofbodyhook

\sphinxAtStartPar
{\hyperref[\detokenize{src.models.electricity.scripts.utilities:src.models.electricity.scripts.utilities.ElectricityMethods}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ElectricityMethods}}}}}(*args, **kwds)
&
\sphinxAtStartPar
a collection of functions used within the electricity model that aid in building the model.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Model}}(*args, **kwds)
&
\sphinxAtStartPar
This is the base model class for the models.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Path}}(*args, **kwargs)
&
\sphinxAtStartPar
PurePath subclass that can make system calls.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{defaultdict}}
&
\sphinxAtStartPar
defaultdict(default\_factory=None, /, {[}...{]}) \sphinxhyphen{}\sphinxhyphen{}\textgreater{} dict with default factory
\\
\sphinxbottomrule
\end{longtable}
\sphinxtableafterendhook
\sphinxatlongtableend
\end{savenotes}
\index{ElectricityMethods (class in src.models.electricity.scripts.utilities)@\spxentry{ElectricityMethods}\spxextra{class in src.models.electricity.scripts.utilities}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.electricity.scripts.utilities:src.models.electricity.scripts.utilities.ElectricityMethods}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{\DUrole{k}{class}\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{src.models.electricity.scripts.utilities.}}\sphinxbfcode{\sphinxupquote{ElectricityMethods}}}
{\sphinxparam{\DUrole{o}{*}\DUrole{n}{args}}\sphinxparamcomma \sphinxparam{\DUrole{o}{**}\DUrole{n}{kwds}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
a collection of functions used within the electricity model that aid in building the model.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{Model}} (\sphinxstyleliteralemphasis{\sphinxupquote{Class}}) \textendash{} generic model class

\end{description}\end{quote}
\index{\_active (src.models.electricity.scripts.utilities.ElectricityMethods attribute)@\spxentry{\_active}\spxextra{src.models.electricity.scripts.utilities.ElectricityMethods attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.electricity.scripts.utilities:src.models.electricity.scripts.utilities.ElectricityMethods._active}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{\_active}}}
\pysigstopsignatures
\end{fulllineitems}

\index{populate\_RM\_sets\_rule() (src.models.electricity.scripts.utilities.ElectricityMethods method)@\spxentry{populate\_RM\_sets\_rule()}\spxextra{src.models.electricity.scripts.utilities.ElectricityMethods method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.electricity.scripts.utilities:src.models.electricity.scripts.utilities.ElectricityMethods.populate_RM_sets_rule}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{populate\_RM\_sets\_rule}}}
{}
{}
\pysigstopsignatures
\sphinxAtStartPar
Creates new reindexed sets for reserve margin constraint
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{m}} ({\hyperref[\detokenize{src.models.electricity.scripts.electricity_model:src.models.electricity.scripts.electricity_model.PowerModel}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{PowerModel}}}}}) \textendash{} pyomo electricity model instance

\end{description}\end{quote}

\end{fulllineitems}

\index{populate\_by\_hour\_sets\_rule() (src.models.electricity.scripts.utilities.ElectricityMethods method)@\spxentry{populate\_by\_hour\_sets\_rule()}\spxextra{src.models.electricity.scripts.utilities.ElectricityMethods method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.electricity.scripts.utilities:src.models.electricity.scripts.utilities.ElectricityMethods.populate_by_hour_sets_rule}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{populate\_by\_hour\_sets\_rule}}}
{}
{}
\pysigstopsignatures
\sphinxAtStartPar
Creates new reindexed sets for dispatch\_cost calculations
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{m}} ({\hyperref[\detokenize{src.models.electricity.scripts.electricity_model:src.models.electricity.scripts.electricity_model.PowerModel}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{PowerModel}}}}}) \textendash{} pyomo electricity model instance

\end{description}\end{quote}

\end{fulllineitems}

\index{populate\_demand\_balance\_sets\_rule() (src.models.electricity.scripts.utilities.ElectricityMethods method)@\spxentry{populate\_demand\_balance\_sets\_rule()}\spxextra{src.models.electricity.scripts.utilities.ElectricityMethods method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.electricity.scripts.utilities:src.models.electricity.scripts.utilities.ElectricityMethods.populate_demand_balance_sets_rule}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{populate\_demand\_balance\_sets\_rule}}}
{}
{}
\pysigstopsignatures
\sphinxAtStartPar
Creates new reindexed sets for demand balance constraint
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{m}} ({\hyperref[\detokenize{src.models.electricity.scripts.electricity_model:src.models.electricity.scripts.electricity_model.PowerModel}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{PowerModel}}}}}) \textendash{} pyomo electricity model instance

\end{description}\end{quote}

\end{fulllineitems}

\index{populate\_hydro\_sets\_rule() (src.models.electricity.scripts.utilities.ElectricityMethods method)@\spxentry{populate\_hydro\_sets\_rule()}\spxextra{src.models.electricity.scripts.utilities.ElectricityMethods method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.electricity.scripts.utilities:src.models.electricity.scripts.utilities.ElectricityMethods.populate_hydro_sets_rule}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{populate\_hydro\_sets\_rule}}}
{}
{}
\pysigstopsignatures
\sphinxAtStartPar
Creates new reindexed sets for hydroelectric generation seasonal upper bound constraint
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{m}} ({\hyperref[\detokenize{src.models.electricity.scripts.electricity_model:src.models.electricity.scripts.electricity_model.PowerModel}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{PowerModel}}}}}) \textendash{} pyomo electricity model instance

\end{description}\end{quote}

\end{fulllineitems}

\index{populate\_reserves\_sets\_rule() (src.models.electricity.scripts.utilities.ElectricityMethods method)@\spxentry{populate\_reserves\_sets\_rule()}\spxextra{src.models.electricity.scripts.utilities.ElectricityMethods method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.electricity.scripts.utilities:src.models.electricity.scripts.utilities.ElectricityMethods.populate_reserves_sets_rule}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{populate\_reserves\_sets\_rule}}}
{}
{}
\pysigstopsignatures
\sphinxAtStartPar
Creates new reindexed sets for operating reserves constraints
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{m}} ({\hyperref[\detokenize{src.models.electricity.scripts.electricity_model:src.models.electricity.scripts.electricity_model.PowerModel}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{PowerModel}}}}}) \textendash{} pyomo electricity model instance

\end{description}\end{quote}

\end{fulllineitems}

\index{populate\_trade\_sets\_rule() (src.models.electricity.scripts.utilities.ElectricityMethods method)@\spxentry{populate\_trade\_sets\_rule()}\spxextra{src.models.electricity.scripts.utilities.ElectricityMethods method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.electricity.scripts.utilities:src.models.electricity.scripts.utilities.ElectricityMethods.populate_trade_sets_rule}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{populate\_trade\_sets\_rule}}}
{}
{}
\pysigstopsignatures
\sphinxAtStartPar
Creates new reindexed sets for trade constraints
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{m}} ({\hyperref[\detokenize{src.models.electricity.scripts.electricity_model:src.models.electricity.scripts.electricity_model.PowerModel}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{PowerModel}}}}}) \textendash{} pyomo electricity model instance

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{annual\_count() (in module src.models.electricity.scripts.utilities)@\spxentry{annual\_count()}\spxextra{in module src.models.electricity.scripts.utilities}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.electricity.scripts.utilities:src.models.electricity.scripts.utilities.annual_count}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{src.models.electricity.scripts.utilities.}}\sphinxbfcode{\sphinxupquote{annual\_count}}}
{\sphinxparam{\DUrole{n}{hour}}\sphinxparamcomma \sphinxparam{\DUrole{n}{m}}}
{{ $\rightarrow$ int}}
\pysigstopsignatures
\sphinxAtStartPar
return the aggregate weight of this hour in the representative year
we know the hour weight, and the hours are unique to days, so we can
get the day weight
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{hour}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} the rep\_hour

\sphinxlineitem{Returns}
\sphinxAtStartPar
the aggregate weight (count) of this hour in the rep\_year.  NOT the hour weight!

\sphinxlineitem{Return type}
\sphinxAtStartPar
int

\end{description}\end{quote}

\end{fulllineitems}

\index{check\_results() (in module src.models.electricity.scripts.utilities)@\spxentry{check\_results()}\spxextra{in module src.models.electricity.scripts.utilities}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.electricity.scripts.utilities:src.models.electricity.scripts.utilities.check_results}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{src.models.electricity.scripts.utilities.}}\sphinxbfcode{\sphinxupquote{check\_results}}}
{\sphinxparam{\DUrole{n}{results}}\sphinxparamcomma \sphinxparam{\DUrole{n}{SolutionStatus}}\sphinxparamcomma \sphinxparam{\DUrole{n}{TerminationCondition}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Check results for termination condition and solution status
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{results}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Results from pyomo

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{SolutionStatus}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Solution Status from pyomo

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TerminationCondition}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Termination Condition from pyomo

\end{itemize}

\sphinxlineitem{Return type}
\sphinxAtStartPar
results

\end{description}\end{quote}

\end{fulllineitems}

\index{create\_obj\_df() (in module src.models.electricity.scripts.utilities)@\spxentry{create\_obj\_df()}\spxextra{in module src.models.electricity.scripts.utilities}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.electricity.scripts.utilities:src.models.electricity.scripts.utilities.create_obj_df}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{src.models.electricity.scripts.utilities.}}\sphinxbfcode{\sphinxupquote{create\_obj\_df}}}
{\sphinxparam{\DUrole{n}{mod\_object}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
takes pyomo component objects (e.g., variables, parameters, constraints) and processes the
pyomo data and converts it to a dataframe and then writes the dataframe out to an output dir.
The dataframe contains a key column which is the original way the pyomo data is structured,
as well as columns broken out for each set and the final values.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mod\_object}} (\sphinxstyleliteralemphasis{\sphinxupquote{pyomo component object}}) \textendash{} pyomo component object

\sphinxlineitem{Returns}
\sphinxAtStartPar
contains the pyomo model results for the component object

\sphinxlineitem{Return type}
\sphinxAtStartPar
pd.DataFrame

\end{description}\end{quote}

\end{fulllineitems}


\sphinxstepscope


\subsubsection{src.models.hydrogen}
\label{\detokenize{src.models.hydrogen:module-src.models.hydrogen}}\label{\detokenize{src.models.hydrogen:src-models-hydrogen}}\label{\detokenize{src.models.hydrogen::doc}}\index{module@\spxentry{module}!src.models.hydrogen@\spxentry{src.models.hydrogen}}\index{src.models.hydrogen@\spxentry{src.models.hydrogen}!module@\spxentry{module}}\subsubsection*{Modules}


\begin{savenotes}
\sphinxatlongtablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\makeatletter
  \LTleft \@totalleftmargin plus1fill
  \LTright\dimexpr\columnwidth-\@totalleftmargin-\linewidth\relax plus1fill
\makeatother
\begin{longtable}{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\endfirsthead

\multicolumn{2}{c}{\sphinxnorowcolor
    \makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}%
}\\
\sphinxtoprule
\endhead

\sphinxbottomrule
\multicolumn{2}{r}{\sphinxnorowcolor
    \makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}%
}\\
\endfoot

\endlastfoot
\sphinxtableatstartofbodyhook

\sphinxAtStartPar
{\hyperref[\detokenize{src.models.hydrogen.model:module-src.models.hydrogen.model}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{model}}}}}
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.models.hydrogen.network:module-src.models.hydrogen.network}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{network}}}}}
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.models.hydrogen.utilities:module-src.models.hydrogen.utilities}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{utilities}}}}}
&
\sphinxAtStartPar

\\
\sphinxbottomrule
\end{longtable}
\sphinxtableafterendhook
\sphinxatlongtableend
\end{savenotes}

\sphinxstepscope


\paragraph{src.models.hydrogen.model}
\label{\detokenize{src.models.hydrogen.model:module-src.models.hydrogen.model}}\label{\detokenize{src.models.hydrogen.model:src-models-hydrogen-model}}\label{\detokenize{src.models.hydrogen.model::doc}}\index{module@\spxentry{module}!src.models.hydrogen.model@\spxentry{src.models.hydrogen.model}}\index{src.models.hydrogen.model@\spxentry{src.models.hydrogen.model}!module@\spxentry{module}}\subsubsection*{Modules}


\begin{savenotes}
\sphinxatlongtablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\makeatletter
  \LTleft \@totalleftmargin plus1fill
  \LTright\dimexpr\columnwidth-\@totalleftmargin-\linewidth\relax plus1fill
\makeatother
\begin{longtable}{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\endfirsthead

\multicolumn{2}{c}{\sphinxnorowcolor
    \makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}%
}\\
\sphinxtoprule
\endhead

\sphinxbottomrule
\multicolumn{2}{r}{\sphinxnorowcolor
    \makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}%
}\\
\endfoot

\endlastfoot
\sphinxtableatstartofbodyhook

\sphinxAtStartPar
{\hyperref[\detokenize{src.models.hydrogen.model.actions:module-src.models.hydrogen.model.actions}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{actions}}}}}
&
\sphinxAtStartPar
A sequencer for actions in the model.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.models.hydrogen.model.h2_model:module-src.models.hydrogen.model.h2_model}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{h2\_model}}}}}
&
\sphinxAtStartPar
The Hydrogen Model takes in a Grid object and uses it to populate a Pyomo model that solves for the least cost to produce and distribute Hydrogen by electrolysis across the grid to satisfy a given demand, returning the duals as shadow prices.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.models.hydrogen.model.validators:module-src.models.hydrogen.model.validators}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{validators}}}}}
&
\sphinxAtStartPar
set of validator functions for use in model
\\
\sphinxbottomrule
\end{longtable}
\sphinxtableafterendhook
\sphinxatlongtableend
\end{savenotes}

\sphinxstepscope


\subparagraph{src.models.hydrogen.model.actions}
\label{\detokenize{src.models.hydrogen.model.actions:module-src.models.hydrogen.model.actions}}\label{\detokenize{src.models.hydrogen.model.actions:src-models-hydrogen-model-actions}}\label{\detokenize{src.models.hydrogen.model.actions::doc}}\index{module@\spxentry{module}!src.models.hydrogen.model.actions@\spxentry{src.models.hydrogen.model.actions}}\index{src.models.hydrogen.model.actions@\spxentry{src.models.hydrogen.model.actions}!module@\spxentry{module}}
\sphinxAtStartPar
A sequencer for actions in the model.
This may change up a bit, but it is a place to assert control of the execution sequence for now
\subsubsection*{Functions}


\begin{savenotes}
\sphinxatlongtablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\makeatletter
  \LTleft \@totalleftmargin plus1fill
  \LTright\dimexpr\columnwidth-\@totalleftmargin-\linewidth\relax plus1fill
\makeatother
\begin{longtable}{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\endfirsthead

\multicolumn{2}{c}{\sphinxnorowcolor
    \makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}%
}\\
\sphinxtoprule
\endhead

\sphinxbottomrule
\multicolumn{2}{r}{\sphinxnorowcolor
    \makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}%
}\\
\endfoot

\endlastfoot
\sphinxtableatstartofbodyhook

\sphinxAtStartPar
{\hyperref[\detokenize{src.models.hydrogen.model.actions:src.models.hydrogen.model.actions.build_grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{build\_grid}}}}}(grid\_data)
&
\sphinxAtStartPar
build a grid from grid\_data
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.models.hydrogen.model.actions:src.models.hydrogen.model.actions.build_model}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{build\_model}}}}}(grid, **kwds)
&
\sphinxAtStartPar
build model from grd
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{check\_optimal\_termination}}(results)
&
\sphinxAtStartPar
This function returns True if the termination condition for the solver is \textquotesingle{}optimal\textquotesingle{}, \textquotesingle{}locallyOptimal\textquotesingle{}, or \textquotesingle{}globallyOptimal\textquotesingle{}, and the status is \textquotesingle{}ok\textquotesingle{}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{getLogger}}({[}name{]})
&
\sphinxAtStartPar
Return a logger with the specified name, creating it if necessary.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.models.hydrogen.model.actions:src.models.hydrogen.model.actions.load_data}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{load\_data}}}}}(path\_to\_input, **kwds)
&
\sphinxAtStartPar
load data for model
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.models.hydrogen.model.actions:src.models.hydrogen.model.actions.make_h2_outputs}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{make\_h2\_outputs}}}}}(output\_path, model)
&
\sphinxAtStartPar
save model outputs
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.models.hydrogen.model.actions:src.models.hydrogen.model.actions.quick_summary}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{quick\_summary}}}}}(solved\_hm)
&
\sphinxAtStartPar
print and return summary of solve
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.models.hydrogen.model.actions:src.models.hydrogen.model.actions.run_hydrogen_model}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{run\_hydrogen\_model}}}}}(settings)
&
\sphinxAtStartPar
run hydrogen model in standalone
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{solve}}(hm)
&
\sphinxAtStartPar
\_summary\_
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.models.hydrogen.model.actions:src.models.hydrogen.model.actions.solve_it}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{solve\_it}}}}}(hm)
&
\sphinxAtStartPar
solve hm
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{value}}(obj{[}, exception{]})
&
\sphinxAtStartPar
A utility function that returns the value of a Pyomo object or expression.
\\
\sphinxbottomrule
\end{longtable}
\sphinxtableafterendhook
\sphinxatlongtableend
\end{savenotes}
\subsubsection*{Classes}


\begin{savenotes}
\sphinxatlongtablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\makeatletter
  \LTleft \@totalleftmargin plus1fill
  \LTright\dimexpr\columnwidth-\@totalleftmargin-\linewidth\relax plus1fill
\makeatother
\begin{longtable}{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\endfirsthead

\multicolumn{2}{c}{\sphinxnorowcolor
    \makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}%
}\\
\sphinxtoprule
\endhead

\sphinxbottomrule
\multicolumn{2}{r}{\sphinxnorowcolor
    \makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}%
}\\
\endfoot

\endlastfoot
\sphinxtableatstartofbodyhook

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Grid}}({[}data{]})
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{GridData}}(data\_folder{[}, regions\_of\_interest{]})
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{H2Model}}(*args, **kwds)
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Path}}(*args, **kwargs)
&
\sphinxAtStartPar
PurePath subclass that can make system calls.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SolverResults}}(*args, **kwargs)
&
\sphinxAtStartPar

\\
\sphinxbottomrule
\end{longtable}
\sphinxtableafterendhook
\sphinxatlongtableend
\end{savenotes}
\index{build\_grid() (in module src.models.hydrogen.model.actions)@\spxentry{build\_grid()}\spxextra{in module src.models.hydrogen.model.actions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.hydrogen.model.actions:src.models.hydrogen.model.actions.build_grid}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{src.models.hydrogen.model.actions.}}\sphinxbfcode{\sphinxupquote{build\_grid}}}
{\sphinxparam{\DUrole{n}{grid\_data}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{{\hyperref[\detokenize{src.models.hydrogen.network.grid_data:src.models.hydrogen.network.grid_data.GridData}]{\sphinxcrossref{GridData}}}}}}
{{ $\rightarrow$ {\hyperref[\detokenize{src.models.hydrogen.network.grid:src.models.hydrogen.network.grid.Grid}]{\sphinxcrossref{Grid}}}}}
\pysigstopsignatures
\sphinxAtStartPar
build a grid from grid\_data
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{grid\_data}} (\sphinxstyleliteralemphasis{\sphinxupquote{obj}}) \textendash{} GridData object to build grid from

\sphinxlineitem{Returns}
\sphinxAtStartPar
\sphinxstylestrong{Grid} \textendash{} Grid object

\sphinxlineitem{Return type}
\sphinxAtStartPar
obj

\end{description}\end{quote}

\end{fulllineitems}

\index{build\_model() (in module src.models.hydrogen.model.actions)@\spxentry{build\_model()}\spxextra{in module src.models.hydrogen.model.actions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.hydrogen.model.actions:src.models.hydrogen.model.actions.build_model}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{src.models.hydrogen.model.actions.}}\sphinxbfcode{\sphinxupquote{build\_model}}}
{\sphinxparam{\DUrole{n}{grid}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{{\hyperref[\detokenize{src.models.hydrogen.network.grid:src.models.hydrogen.network.grid.Grid}]{\sphinxcrossref{Grid}}}}}\sphinxparamcomma \sphinxparam{\DUrole{o}{**}\DUrole{n}{kwds}}}
{{ $\rightarrow$ {\hyperref[\detokenize{src.models.hydrogen.model.h2_model:src.models.hydrogen.model.h2_model.H2Model}]{\sphinxcrossref{H2Model}}}}}
\pysigstopsignatures
\sphinxAtStartPar
build model from grd
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{grid}} (\sphinxstyleliteralemphasis{\sphinxupquote{obj}}) \textendash{} Grid object to build model from

\sphinxlineitem{Returns}
\sphinxAtStartPar
\sphinxstylestrong{H2Model} \textendash{} H2Model object

\sphinxlineitem{Return type}
\sphinxAtStartPar
obj

\end{description}\end{quote}

\end{fulllineitems}

\index{load\_data() (in module src.models.hydrogen.model.actions)@\spxentry{load\_data()}\spxextra{in module src.models.hydrogen.model.actions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.hydrogen.model.actions:src.models.hydrogen.model.actions.load_data}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{src.models.hydrogen.model.actions.}}\sphinxbfcode{\sphinxupquote{load\_data}}}
{\sphinxparam{\DUrole{n}{path\_to\_input}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{Path}}\sphinxparamcomma \sphinxparam{\DUrole{o}{**}\DUrole{n}{kwds}}}
{{ $\rightarrow$ {\hyperref[\detokenize{src.models.hydrogen.network.grid_data:src.models.hydrogen.network.grid_data.GridData}]{\sphinxcrossref{GridData}}}}}
\pysigstopsignatures
\sphinxAtStartPar
load data for model
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path\_to\_input}} (\sphinxstyleliteralemphasis{\sphinxupquote{Path}}) \textendash{} Data folder path

\sphinxlineitem{Returns}
\sphinxAtStartPar
\sphinxstylestrong{GridData} \textendash{} Grid Data object from path

\sphinxlineitem{Return type}
\sphinxAtStartPar
obj

\end{description}\end{quote}

\end{fulllineitems}

\index{make\_h2\_outputs() (in module src.models.hydrogen.model.actions)@\spxentry{make\_h2\_outputs()}\spxextra{in module src.models.hydrogen.model.actions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.hydrogen.model.actions:src.models.hydrogen.model.actions.make_h2_outputs}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{src.models.hydrogen.model.actions.}}\sphinxbfcode{\sphinxupquote{make\_h2\_outputs}}}
{\sphinxparam{\DUrole{n}{output\_path}}\sphinxparamcomma \sphinxparam{\DUrole{n}{model}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
save model outputs
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{model}} (\sphinxstyleliteralemphasis{\sphinxupquote{obj}}) \textendash{} Solved H2Model

\end{description}\end{quote}

\end{fulllineitems}

\index{quick\_summary() (in module src.models.hydrogen.model.actions)@\spxentry{quick\_summary()}\spxextra{in module src.models.hydrogen.model.actions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.hydrogen.model.actions:src.models.hydrogen.model.actions.quick_summary}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{src.models.hydrogen.model.actions.}}\sphinxbfcode{\sphinxupquote{quick\_summary}}}
{\sphinxparam{\DUrole{n}{solved\_hm}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{{\hyperref[\detokenize{src.models.hydrogen.model.h2_model:src.models.hydrogen.model.h2_model.H2Model}]{\sphinxcrossref{H2Model}}}}}}
{{ $\rightarrow$ None}}
\pysigstopsignatures
\sphinxAtStartPar
print and return summary of solve
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{solved\_hm}} (\sphinxstyleliteralemphasis{\sphinxupquote{obj}}) \textendash{} Solved H2Model

\sphinxlineitem{Returns}
\sphinxAtStartPar
\sphinxstylestrong{res} \textendash{} Printed summary

\sphinxlineitem{Return type}
\sphinxAtStartPar
str

\end{description}\end{quote}

\end{fulllineitems}

\index{run\_hydrogen\_model() (in module src.models.hydrogen.model.actions)@\spxentry{run\_hydrogen\_model()}\spxextra{in module src.models.hydrogen.model.actions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.hydrogen.model.actions:src.models.hydrogen.model.actions.run_hydrogen_model}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{src.models.hydrogen.model.actions.}}\sphinxbfcode{\sphinxupquote{run\_hydrogen\_model}}}
{\sphinxparam{\DUrole{n}{settings}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
run hydrogen model in standalone
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{settings}} (\sphinxstyleliteralemphasis{\sphinxupquote{obj}}) \textendash{} Config\_setup instance

\end{description}\end{quote}

\end{fulllineitems}

\index{solve\_it() (in module src.models.hydrogen.model.actions)@\spxentry{solve\_it()}\spxextra{in module src.models.hydrogen.model.actions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.hydrogen.model.actions:src.models.hydrogen.model.actions.solve_it}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{src.models.hydrogen.model.actions.}}\sphinxbfcode{\sphinxupquote{solve\_it}}}
{\sphinxparam{\DUrole{n}{hm}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{{\hyperref[\detokenize{src.models.hydrogen.model.h2_model:src.models.hydrogen.model.h2_model.H2Model}]{\sphinxcrossref{H2Model}}}}}}
{{ $\rightarrow$ SolverResults}}
\pysigstopsignatures
\sphinxAtStartPar
solve hm
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{hm}} (\sphinxstyleliteralemphasis{\sphinxupquote{objH2Model}}) \textendash{} H2Model to solve

\sphinxlineitem{Returns}
\sphinxAtStartPar
\sphinxstylestrong{SolverResults} \textendash{} results of solve

\sphinxlineitem{Return type}
\sphinxAtStartPar
obj

\end{description}\end{quote}

\end{fulllineitems}


\sphinxstepscope


\subparagraph{src.models.hydrogen.model.h2\_model}
\label{\detokenize{src.models.hydrogen.model.h2_model:module-src.models.hydrogen.model.h2_model}}\label{\detokenize{src.models.hydrogen.model.h2_model:src-models-hydrogen-model-h2-model}}\label{\detokenize{src.models.hydrogen.model.h2_model::doc}}\index{module@\spxentry{module}!src.models.hydrogen.model.h2\_model@\spxentry{src.models.hydrogen.model.h2\_model}}\index{src.models.hydrogen.model.h2\_model@\spxentry{src.models.hydrogen.model.h2\_model}!module@\spxentry{module}}
\sphinxAtStartPar
The Hydrogen Model takes in a Grid object and uses it to populate a Pyomo model that solves for the
least cost to produce and distribute Hydrogen by electrolysis across the grid to satisfy a given
demand, returning the duals as shadow prices. It can be run in stand\sphinxhyphen{}alone or integrated runs. If
stand\sphinxhyphen{}alone, a function for generated temporally varying data must be supplied. By default it simply
projects geometric growth for electricity price and demand.
\subsubsection*{Functions}


\begin{savenotes}
\sphinxatlongtablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\makeatletter
  \LTleft \@totalleftmargin plus1fill
  \LTright\dimexpr\columnwidth-\@totalleftmargin-\linewidth\relax plus1fill
\makeatother
\begin{longtable}{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\endfirsthead

\multicolumn{2}{c}{\sphinxnorowcolor
    \makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}%
}\\
\sphinxtoprule
\endhead

\sphinxbottomrule
\multicolumn{2}{r}{\sphinxnorowcolor
    \makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}%
}\\
\endfoot

\endlastfoot
\sphinxtableatstartofbodyhook

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{check\_optimal\_termination}}(results)
&
\sphinxAtStartPar
This function returns True if the termination condition for the solver is \textquotesingle{}optimal\textquotesingle{}, \textquotesingle{}locallyOptimal\textquotesingle{}, or \textquotesingle{}globallyOptimal\textquotesingle{}, and the status is \textquotesingle{}ok\textquotesingle{}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{getLogger}}({[}name{]})
&
\sphinxAtStartPar
Return a logger with the specified name, creating it if necessary.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.models.hydrogen.model.h2_model:src.models.hydrogen.model.h2_model.resolve}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{resolve}}}}}(hm{[}, new\_demand, ...{]})
&
\sphinxAtStartPar
For convenience: After building and solving the model initially:
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.models.hydrogen.model.h2_model:src.models.hydrogen.model.h2_model.solve}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{solve}}}}}(hm)
&
\sphinxAtStartPar
\_summary\_
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{value}}(obj{[}, exception{]})
&
\sphinxAtStartPar
A utility function that returns the value of a Pyomo object or expression.
\\
\sphinxbottomrule
\end{longtable}
\sphinxtableafterendhook
\sphinxatlongtableend
\end{savenotes}
\subsubsection*{Classes}


\begin{savenotes}
\sphinxatlongtablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\makeatletter
  \LTleft \@totalleftmargin plus1fill
  \LTright\dimexpr\columnwidth-\@totalleftmargin-\linewidth\relax plus1fill
\makeatother
\begin{longtable}{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\endfirsthead

\multicolumn{2}{c}{\sphinxnorowcolor
    \makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}%
}\\
\sphinxtoprule
\endhead

\sphinxbottomrule
\multicolumn{2}{r}{\sphinxnorowcolor
    \makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}%
}\\
\endfoot

\endlastfoot
\sphinxtableatstartofbodyhook

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Block}}(*args, **kwds)
&
\sphinxAtStartPar
Blocks are indexed components that contain other components (including blocks).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ConcreteModel}}(*args, **kwds)
&
\sphinxAtStartPar
A concrete optimization model that does not defer construction of components.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Constraint}}(*args, **kwds)
&
\sphinxAtStartPar
This modeling component defines a constraint expression using a rule function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Grid}}({[}data{]})
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.models.hydrogen.model.h2_model:src.models.hydrogen.model.h2_model.H2Model}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{H2Model}}}}}(*args, **kwds)
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{HI}}(region, year)
&
\sphinxAtStartPar
(region, year)
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{LinearExpression}}({[}args, constant, ...{]})
&
\sphinxAtStartPar
An expression object for linear polynomials.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Objective}}(*args, **kwds)
&
\sphinxAtStartPar
This modeling component defines an objective expression.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Param}}(*args, **kwds)
&
\sphinxAtStartPar
A parameter value, which may be defined over an index.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{RangeSet}}(*args, **kwds)
&
\sphinxAtStartPar
A set object that represents a set of numeric values
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Set}}(*args, **kwds)
&
\sphinxAtStartPar
A component used to index other Pyomo components.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SolverResults}}(*args, **kwargs)
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Suffix}}(*args, **kwargs)
&
\sphinxAtStartPar
A model suffix, representing extraneous model data
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Var}}(*args, **kwargs)
&
\sphinxAtStartPar
A numeric variable, which may be defined over an index.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{defaultdict}}
&
\sphinxAtStartPar
defaultdict(default\_factory=None, /, {[}...{]}) \sphinxhyphen{}\sphinxhyphen{}\textgreater{} dict with default factory
\\
\sphinxbottomrule
\end{longtable}
\sphinxtableafterendhook
\sphinxatlongtableend
\end{savenotes}
\index{H2Model (class in src.models.hydrogen.model.h2\_model)@\spxentry{H2Model}\spxextra{class in src.models.hydrogen.model.h2\_model}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.hydrogen.model.h2_model:src.models.hydrogen.model.h2_model.H2Model}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{\DUrole{k}{class}\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{src.models.hydrogen.model.h2\_model.}}\sphinxbfcode{\sphinxupquote{H2Model}}}
{\sphinxparam{\DUrole{o}{*}\DUrole{n}{args}}\sphinxparamcomma \sphinxparam{\DUrole{o}{**}\DUrole{n}{kwds}}}
{}
\pysigstopsignatures\index{\_active (src.models.hydrogen.model.h2\_model.H2Model attribute)@\spxentry{\_active}\spxextra{src.models.hydrogen.model.h2\_model.H2Model attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.hydrogen.model.h2_model:src.models.hydrogen.model.h2_model.H2Model._active}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{\_active}}}
\pysigstopsignatures
\end{fulllineitems}

\index{\_filter\_update\_info() (src.models.hydrogen.model.h2\_model.H2Model method)@\spxentry{\_filter\_update\_info()}\spxextra{src.models.hydrogen.model.h2\_model.H2Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.hydrogen.model.h2_model:src.models.hydrogen.model.h2_model.H2Model._filter_update_info}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{\_filter\_update\_info}}}
{\sphinxparam{\DUrole{n}{data}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{dict\DUrole{p}{{[}}{\hyperref[\detokenize{src.integrator.utilities:src.integrator.utilities.HI}]{\sphinxcrossref{HI}}}\DUrole{p}{,}\DUrole{w}{ }float\DUrole{p}{{]}}}}}
{{ $\rightarrow$ dict\DUrole{p}{{[}}{\hyperref[\detokenize{src.integrator.utilities:src.integrator.utilities.HI}]{\sphinxcrossref{HI}}}\DUrole{p}{,}\DUrole{w}{ }float\DUrole{p}{{]}}}}
\pysigstopsignatures
\sphinxAtStartPar
quick filter to remove regions that don’t exist in the model
\begin{quote}
\begin{quote}

\sphinxAtStartPar
It is possible (right now) that the H2 network is unaware of particular regions
\end{quote}

\sphinxAtStartPar
because no baseline data for them was ever provided…. so it is possible to
recieve and “unkown” region here, even though it was selected, due to lack of
data
\end{quote}
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{hm}} ({\hyperref[\detokenize{src.models.hydrogen.model.h2_model:src.models.hydrogen.model.h2_model.H2Model}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{H2Model}}}}}) \textendash{} self

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{data}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}{\hyperref[\detokenize{src.integrator.utilities:src.integrator.utilities.HI}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{HI}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} hydrogen index : value

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
regions index: value with missing data removed

\sphinxlineitem{Return type}
\sphinxAtStartPar
dict{[}{\hyperref[\detokenize{src.integrator.utilities:src.integrator.utilities.HI}]{\sphinxcrossref{HI}}}, float{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{\_update\_demand() (src.models.hydrogen.model.h2\_model.H2Model method)@\spxentry{\_update\_demand()}\spxextra{src.models.hydrogen.model.h2\_model.H2Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.hydrogen.model.h2_model:src.models.hydrogen.model.h2_model.H2Model._update_demand}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{\_update\_demand}}}
{\sphinxparam{\DUrole{n}{new\_demand}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
update the demand parameter with new demand data
\begin{quote}

\sphinxAtStartPar
insert new demand as a dict in the format: new\_demand{[}region, year{]}
\end{quote}
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{hm}} ({\hyperref[\detokenize{src.models.hydrogen.model.h2_model:src.models.hydrogen.model.h2_model.H2Model}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{H2Model}}}}}) \textendash{} self

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{new\_demand}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} new demand values

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{\_update\_electricity\_price() (src.models.hydrogen.model.h2\_model.H2Model method)@\spxentry{\_update\_electricity\_price()}\spxextra{src.models.hydrogen.model.h2\_model.H2Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.hydrogen.model.h2_model:src.models.hydrogen.model.h2_model.H2Model._update_electricity_price}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{\_update\_electricity\_price}}}
{\sphinxparam{\DUrole{n}{new\_electricity\_price}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
update electricity price parameter
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{hm}} ({\hyperref[\detokenize{src.models.hydrogen.model.h2_model:src.models.hydrogen.model.h2_model.H2Model}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{H2Model}}}}}) \textendash{} self

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{new\_electricity\_price}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} region, year : electricity price

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{poll\_electric\_demand() (src.models.hydrogen.model.h2\_model.H2Model method)@\spxentry{poll\_electric\_demand()}\spxextra{src.models.hydrogen.model.h2\_model.H2Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.hydrogen.model.h2_model:src.models.hydrogen.model.h2_model.H2Model.poll_electric_demand}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{poll\_electric\_demand}}}
{}
{{ $\rightarrow$ dict\DUrole{p}{{[}}{\hyperref[\detokenize{src.integrator.utilities:src.integrator.utilities.HI}]{\sphinxcrossref{HI}}}\DUrole{p}{,}\DUrole{w}{ }float\DUrole{p}{{]}}}}
\pysigstopsignatures
\sphinxAtStartPar
compute the electrical demand by region\sphinxhyphen{}year after solve

\sphinxAtStartPar
Note:  we will use production * 1/eff to compute electrical demand
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{hm}} ({\hyperref[\detokenize{src.models.hydrogen.model.h2_model:src.models.hydrogen.model.h2_model.H2Model}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{H2Model}}}}}) \textendash{} self

\sphinxlineitem{Returns}
\sphinxAtStartPar
electricity demand by region, year. (region, year):demand

\sphinxlineitem{Return type}
\sphinxAtStartPar
dict{[}{\hyperref[\detokenize{src.integrator.utilities:src.integrator.utilities.HI}]{\sphinxcrossref{HI}}}, float{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{update\_exchange\_params() (src.models.hydrogen.model.h2\_model.H2Model method)@\spxentry{update\_exchange\_params()}\spxextra{src.models.hydrogen.model.h2\_model.H2Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.hydrogen.model.h2_model:src.models.hydrogen.model.h2_model.H2Model.update_exchange_params}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{update\_exchange\_params}}}
{\sphinxparam{\DUrole{n}{new\_demand}\DUrole{o}{=}\DUrole{default_value}{None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{new\_electricity\_price}\DUrole{o}{=}\DUrole{default_value}{None}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
update exchange parameters in integrated mode
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{hm}} ({\hyperref[\detokenize{src.models.hydrogen.model.h2_model:src.models.hydrogen.model.h2_model.H2Model}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{H2Model}}}}}) \textendash{} model

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{new\_demand}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} new demand (region, year):value. Defaults to None.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{new\_electricity\_price}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} new electricity prices (region,year):value . Defaults to None.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{resolve() (in module src.models.hydrogen.model.h2\_model)@\spxentry{resolve()}\spxextra{in module src.models.hydrogen.model.h2\_model}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.hydrogen.model.h2_model:src.models.hydrogen.model.h2_model.resolve}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{src.models.hydrogen.model.h2\_model.}}\sphinxbfcode{\sphinxupquote{resolve}}}
{\sphinxparam{\DUrole{n}{hm}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{{\hyperref[\detokenize{src.models.hydrogen.model.h2_model:src.models.hydrogen.model.h2_model.H2Model}]{\sphinxcrossref{H2Model}}}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{new\_demand}\DUrole{o}{=}\DUrole{default_value}{None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{new\_electricity\_price}\DUrole{o}{=}\DUrole{default_value}{None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{test}\DUrole{o}{=}\DUrole{default_value}{False}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
For convenience: After building and solving the model initially:

\sphinxAtStartPar
if you want to solve without annual data by applying a geometric growth rate to exhcange params
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{hm}} ({\hyperref[\detokenize{src.models.hydrogen.model.h2_model:src.models.hydrogen.model.h2_model.H2Model}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{H2Model}}}}}) \textendash{} model

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{new\_demand}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} new\_demand{[}region,year{]} for H2demand in (region,year). Defaults to None.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{new\_electricity\_price}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} new\_electricity\_price{[}region,year{]}. Defaults to None.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{test}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} is this just a test? Defaults to False.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{solve() (in module src.models.hydrogen.model.h2\_model)@\spxentry{solve()}\spxextra{in module src.models.hydrogen.model.h2\_model}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.hydrogen.model.h2_model:src.models.hydrogen.model.h2_model.solve}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{src.models.hydrogen.model.h2\_model.}}\sphinxbfcode{\sphinxupquote{solve}}}
{\sphinxparam{\DUrole{n}{hm}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{{\hyperref[\detokenize{src.models.hydrogen.model.h2_model:src.models.hydrogen.model.h2_model.H2Model}]{\sphinxcrossref{H2Model}}}}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
\_summary\_
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{hm}} ({\hyperref[\detokenize{src.models.hydrogen.model.h2_model:src.models.hydrogen.model.h2_model.H2Model}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{H2Model}}}}}) \textendash{} self

\sphinxlineitem{Raises}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{RuntimeError}} \textendash{} no optimal solution to problem

\end{description}\end{quote}

\end{fulllineitems}


\sphinxstepscope


\subparagraph{src.models.hydrogen.model.validators}
\label{\detokenize{src.models.hydrogen.model.validators:module-src.models.hydrogen.model.validators}}\label{\detokenize{src.models.hydrogen.model.validators:src-models-hydrogen-model-validators}}\label{\detokenize{src.models.hydrogen.model.validators::doc}}\index{module@\spxentry{module}!src.models.hydrogen.model.validators@\spxentry{src.models.hydrogen.model.validators}}\index{src.models.hydrogen.model.validators@\spxentry{src.models.hydrogen.model.validators}!module@\spxentry{module}}
\sphinxAtStartPar
set of validator functions for use in model
\subsubsection*{Functions}


\begin{savenotes}
\sphinxatlongtablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\makeatletter
  \LTleft \@totalleftmargin plus1fill
  \LTright\dimexpr\columnwidth-\@totalleftmargin-\linewidth\relax plus1fill
\makeatother
\begin{longtable}{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\endfirsthead

\multicolumn{2}{c}{\sphinxnorowcolor
    \makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}%
}\\
\sphinxtoprule
\endhead

\sphinxbottomrule
\multicolumn{2}{r}{\sphinxnorowcolor
    \makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}%
}\\
\endfoot

\endlastfoot
\sphinxtableatstartofbodyhook

\sphinxAtStartPar
{\hyperref[\detokenize{src.models.hydrogen.model.validators:src.models.hydrogen.model.validators.region_validator}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{region\_validator}}}}}(hm, region)
&
\sphinxAtStartPar
checks if region name is string or numeric
\\
\sphinxbottomrule
\end{longtable}
\sphinxtableafterendhook
\sphinxatlongtableend
\end{savenotes}
\index{region\_validator() (in module src.models.hydrogen.model.validators)@\spxentry{region\_validator()}\spxextra{in module src.models.hydrogen.model.validators}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.hydrogen.model.validators:src.models.hydrogen.model.validators.region_validator}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{src.models.hydrogen.model.validators.}}\sphinxbfcode{\sphinxupquote{region\_validator}}}
{\sphinxparam{\DUrole{n}{hm}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{{\hyperref[\detokenize{src.models.hydrogen.model.h2_model:src.models.hydrogen.model.h2_model.H2Model}]{\sphinxcrossref{H2Model}}}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{region}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
checks if region name is string or numeric
\begin{quote}
\begin{description}
\sphinxlineitem{hm}{[}H2Model{]}
\sphinxAtStartPar
model

\sphinxlineitem{region}{[}any{]}
\sphinxAtStartPar
region name

\end{description}
\end{quote}
\begin{quote}\begin{description}
\sphinxlineitem{Raises}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ValueError}} \textendash{} region wrong type

\sphinxlineitem{Returns}
\sphinxAtStartPar
is correct type

\sphinxlineitem{Return type}
\sphinxAtStartPar
bool

\end{description}\end{quote}

\end{fulllineitems}


\sphinxstepscope


\paragraph{src.models.hydrogen.network}
\label{\detokenize{src.models.hydrogen.network:module-src.models.hydrogen.network}}\label{\detokenize{src.models.hydrogen.network:src-models-hydrogen-network}}\label{\detokenize{src.models.hydrogen.network::doc}}\index{module@\spxentry{module}!src.models.hydrogen.network@\spxentry{src.models.hydrogen.network}}\index{src.models.hydrogen.network@\spxentry{src.models.hydrogen.network}!module@\spxentry{module}}\subsubsection*{Modules}


\begin{savenotes}
\sphinxatlongtablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\makeatletter
  \LTleft \@totalleftmargin plus1fill
  \LTright\dimexpr\columnwidth-\@totalleftmargin-\linewidth\relax plus1fill
\makeatother
\begin{longtable}{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\endfirsthead

\multicolumn{2}{c}{\sphinxnorowcolor
    \makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}%
}\\
\sphinxtoprule
\endhead

\sphinxbottomrule
\multicolumn{2}{r}{\sphinxnorowcolor
    \makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}%
}\\
\endfoot

\endlastfoot
\sphinxtableatstartofbodyhook

\sphinxAtStartPar
{\hyperref[\detokenize{src.models.hydrogen.network.grid:module-src.models.hydrogen.network.grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{grid}}}}}
&
\sphinxAtStartPar
GRID CLASS
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.models.hydrogen.network.grid_data:module-src.models.hydrogen.network.grid_data}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{grid\_data}}}}}
&
\sphinxAtStartPar
GRIDDATA CLASS
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.models.hydrogen.network.hub:module-src.models.hydrogen.network.hub}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{hub}}}}}
&
\sphinxAtStartPar
HUB CLASS
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.models.hydrogen.network.region:module-src.models.hydrogen.network.region}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{region}}}}}
&
\sphinxAtStartPar
REGION CLASS
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.models.hydrogen.network.registry:module-src.models.hydrogen.network.registry}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{registry}}}}}
&
\sphinxAtStartPar
REGISTRY CLASS
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.models.hydrogen.network.transportation_arc:module-src.models.hydrogen.network.transportation_arc}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{transportation\_arc}}}}}
&
\sphinxAtStartPar
TRANSPORTATION ARC CLASS
\\
\sphinxbottomrule
\end{longtable}
\sphinxtableafterendhook
\sphinxatlongtableend
\end{savenotes}

\sphinxstepscope


\subparagraph{src.models.hydrogen.network.grid}
\label{\detokenize{src.models.hydrogen.network.grid:module-src.models.hydrogen.network.grid}}\label{\detokenize{src.models.hydrogen.network.grid:src-models-hydrogen-network-grid}}\label{\detokenize{src.models.hydrogen.network.grid::doc}}\index{module@\spxentry{module}!src.models.hydrogen.network.grid@\spxentry{src.models.hydrogen.network.grid}}\index{src.models.hydrogen.network.grid@\spxentry{src.models.hydrogen.network.grid}!module@\spxentry{module}}

\subparagraph{GRID CLASS}
\label{\detokenize{src.models.hydrogen.network.grid:grid-class}}\begin{quote}

\sphinxAtStartPar
This is the central class that binds all the other classes together. No class
instance exists in a reference that isn’t fundamentally contained in a grid.
The grid is used to instantiate a model, read data, create the regionality
and hub / arc network within that regionality, assign data to objects and more.

\sphinxAtStartPar
notably, the grid is used to coordinate internal methods in various classes to
make sure that their combined actions keep the model consistent and accomplish
the desired task.
\end{quote}
\subsubsection*{Classes}


\begin{savenotes}
\sphinxatlongtablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\makeatletter
  \LTleft \@totalleftmargin plus1fill
  \LTright\dimexpr\columnwidth-\@totalleftmargin-\linewidth\relax plus1fill
\makeatother
\begin{longtable}{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\endfirsthead

\multicolumn{2}{c}{\sphinxnorowcolor
    \makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}%
}\\
\sphinxtoprule
\endhead

\sphinxbottomrule
\multicolumn{2}{r}{\sphinxnorowcolor
    \makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}%
}\\
\endfoot

\endlastfoot
\sphinxtableatstartofbodyhook

\sphinxAtStartPar
{\hyperref[\detokenize{src.models.hydrogen.network.grid:src.models.hydrogen.network.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}}({[}data{]})
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{GridData}}(data\_folder{[}, regions\_of\_interest{]})
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Hub}}(name, region{[}, data{]})
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Region}}(name{[}, grid, kind, data, parent{]})
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Registry}}()
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{TransportationArc}}(origin, destination, capacity)
&
\sphinxAtStartPar

\\
\sphinxbottomrule
\end{longtable}
\sphinxtableafterendhook
\sphinxatlongtableend
\end{savenotes}
\index{Grid (class in src.models.hydrogen.network.grid)@\spxentry{Grid}\spxextra{class in src.models.hydrogen.network.grid}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.hydrogen.network.grid:src.models.hydrogen.network.grid.Grid}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{\DUrole{k}{class}\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{src.models.hydrogen.network.grid.}}\sphinxbfcode{\sphinxupquote{Grid}}}
{\sphinxparam{\DUrole{n}{data}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{{\hyperref[\detokenize{src.models.hydrogen.network.grid_data:src.models.hydrogen.network.grid_data.GridData}]{\sphinxcrossref{GridData}}}\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }None}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{None}}}
{}
\pysigstopsignatures\index{aggregate\_hubs() (src.models.hydrogen.network.grid.Grid method)@\spxentry{aggregate\_hubs()}\spxextra{src.models.hydrogen.network.grid.Grid method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.hydrogen.network.grid:src.models.hydrogen.network.grid.Grid.aggregate_hubs}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{aggregate\_hubs}}}
{\sphinxparam{\DUrole{n}{hublist}}\sphinxparamcomma \sphinxparam{\DUrole{n}{region}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
combine all hubs in hublist into a single hub, and place them in region. Arcs that
connect to any of these hubs also get aggegated into arcs that connect to the new hub and
their original origin / destination that’s not in hublist.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{hublist}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}) \textendash{} list of hubs to aggregate

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{region}} ({\hyperref[\detokenize{src.models.hydrogen.network.region:src.models.hydrogen.network.region.Region}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Region}}}}}) \textendash{} region to place them in

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{arc\_generation() (src.models.hydrogen.network.grid.Grid method)@\spxentry{arc\_generation()}\spxextra{src.models.hydrogen.network.grid.Grid method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.hydrogen.network.grid:src.models.hydrogen.network.grid.Grid.arc_generation}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{arc\_generation}}}
{\sphinxparam{\DUrole{n}{df}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
generate arcs from the arc data
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{df}} (\sphinxstyleliteralemphasis{\sphinxupquote{DataFrame}}) \textendash{} arc data

\end{description}\end{quote}

\end{fulllineitems}

\index{build\_grid() (src.models.hydrogen.network.grid.Grid method)@\spxentry{build\_grid()}\spxextra{src.models.hydrogen.network.grid.Grid method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.hydrogen.network.grid:src.models.hydrogen.network.grid.Grid.build_grid}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{build\_grid}}}
{\sphinxparam{\DUrole{n}{vis}\DUrole{o}{=}\DUrole{default_value}{True}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
builds a grid fom the GridData by recursively adding regions starting at top\sphinxhyphen{}level region
‘world’.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{vis}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} if True, will generate an image of the hub\sphinxhyphen{}network with regional color\sphinxhyphen{}coding. Defaults to True.

\end{description}\end{quote}

\end{fulllineitems}

\index{collapse() (src.models.hydrogen.network.grid.Grid method)@\spxentry{collapse()}\spxextra{src.models.hydrogen.network.grid.Grid method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.hydrogen.network.grid:src.models.hydrogen.network.grid.Grid.collapse}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{collapse}}}
{\sphinxparam{\DUrole{n}{region\_name}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
make a region absorb all it’s sub\sphinxhyphen{}regions and combine all its and its childrens hubs into one
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{region\_name}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} region to collapse

\end{description}\end{quote}

\end{fulllineitems}

\index{collapse\_level() (src.models.hydrogen.network.grid.Grid method)@\spxentry{collapse\_level()}\spxextra{src.models.hydrogen.network.grid.Grid method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.hydrogen.network.grid:src.models.hydrogen.network.grid.Grid.collapse_level}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{collapse\_level}}}
{\sphinxparam{\DUrole{n}{level}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
collapse all regions at a specific level of depth in the regional hierarchy, with world = 0
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{level}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} level to collapse

\end{description}\end{quote}

\end{fulllineitems}

\index{combine\_arcs() (src.models.hydrogen.network.grid.Grid method)@\spxentry{combine\_arcs()}\spxextra{src.models.hydrogen.network.grid.Grid method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.hydrogen.network.grid:src.models.hydrogen.network.grid.Grid.combine_arcs}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{combine\_arcs}}}
{\sphinxparam{\DUrole{n}{arclist}}\sphinxparamcomma \sphinxparam{\DUrole{n}{origin}}\sphinxparamcomma \sphinxparam{\DUrole{n}{destination}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
combine a set of arcs into a single arc with given origin and destination
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{arclist}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}) \textendash{} list of arcs to aggregate

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{origin}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} new origin hub

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{destination}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} new destination hub

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{connect\_subregions() (src.models.hydrogen.network.grid.Grid method)@\spxentry{connect\_subregions()}\spxextra{src.models.hydrogen.network.grid.Grid method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.hydrogen.network.grid:src.models.hydrogen.network.grid.Grid.connect_subregions}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{connect\_subregions}}}
{}
{}
\pysigstopsignatures
\sphinxAtStartPar
create an arc for all hubs in bottom\sphinxhyphen{}level regions to whatever hub is located in their
parent region

\end{fulllineitems}

\index{create\_arc() (src.models.hydrogen.network.grid.Grid method)@\spxentry{create\_arc()}\spxextra{src.models.hydrogen.network.grid.Grid method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.hydrogen.network.grid:src.models.hydrogen.network.grid.Grid.create_arc}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{create\_arc}}}
{\sphinxparam{\DUrole{n}{origin}}\sphinxparamcomma \sphinxparam{\DUrole{n}{destination}}\sphinxparamcomma \sphinxparam{\DUrole{n}{capacity}}\sphinxparamcomma \sphinxparam{\DUrole{n}{cost}\DUrole{o}{=}\DUrole{default_value}{0.0}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Creates and arc from origin to destination with given capacity and cost
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{origin}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} origin hub name

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{destination}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} destination hub name

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{capacity}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} capacity of arc

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{cost}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} cost of transporting 1kg H2 along arc. Defaults to 0.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{create\_hub() (src.models.hydrogen.network.grid.Grid method)@\spxentry{create\_hub()}\spxextra{src.models.hydrogen.network.grid.Grid method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.hydrogen.network.grid:src.models.hydrogen.network.grid.Grid.create_hub}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{create\_hub}}}
{\sphinxparam{\DUrole{n}{name}}\sphinxparamcomma \sphinxparam{\DUrole{n}{region}}\sphinxparamcomma \sphinxparam{\DUrole{n}{data}\DUrole{o}{=}\DUrole{default_value}{None}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
creates a hub in a given region
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{name}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} hub name

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{region}} ({\hyperref[\detokenize{src.models.hydrogen.network.region:src.models.hydrogen.network.region.Region}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Region}}}}}) \textendash{} Region hub is placed in

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{data}} (\sphinxstyleliteralemphasis{\sphinxupquote{DataFrame}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} dataframe of hub data to append. Defaults to None.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{create\_region() (src.models.hydrogen.network.grid.Grid method)@\spxentry{create\_region()}\spxextra{src.models.hydrogen.network.grid.Grid method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.hydrogen.network.grid:src.models.hydrogen.network.grid.Grid.create_region}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{create\_region}}}
{\sphinxparam{\DUrole{n}{name}}\sphinxparamcomma \sphinxparam{\DUrole{n}{parent}\DUrole{o}{=}\DUrole{default_value}{None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{data}\DUrole{o}{=}\DUrole{default_value}{None}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
creates a region with a given name, parent region, and data
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{name}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} name of region

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{parent}} ({\hyperref[\detokenize{src.models.hydrogen.network.region:src.models.hydrogen.network.region.Region}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Region}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} parent region. Defaults to None.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{data}} (\sphinxstyleliteralemphasis{\sphinxupquote{DataFrame}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} region data. Defaults to None.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{delete() (src.models.hydrogen.network.grid.Grid method)@\spxentry{delete()}\spxextra{src.models.hydrogen.network.grid.Grid method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.hydrogen.network.grid:src.models.hydrogen.network.grid.Grid.delete}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{delete}}}
{\sphinxparam{\DUrole{n}{thing}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
deletes a hub, arc, or region
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{thing}} ({\hyperref[\detokenize{src.models.hydrogen.network.hub:src.models.hydrogen.network.hub.Hub}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Hub}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{Arc}}\sphinxstyleliteralemphasis{\sphinxupquote{, or }}{\hyperref[\detokenize{src.models.hydrogen.network.region:src.models.hydrogen.network.region.Region}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Region}}}}}) \textendash{} thing to delete

\end{description}\end{quote}

\end{fulllineitems}

\index{load\_hubs() (src.models.hydrogen.network.grid.Grid method)@\spxentry{load\_hubs()}\spxextra{src.models.hydrogen.network.grid.Grid method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.hydrogen.network.grid:src.models.hydrogen.network.grid.Grid.load_hubs}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{load\_hubs}}}
{}
{}
\pysigstopsignatures
\sphinxAtStartPar
load hubs from data

\end{fulllineitems}

\index{recursive\_region\_generation() (src.models.hydrogen.network.grid.Grid method)@\spxentry{recursive\_region\_generation()}\spxextra{src.models.hydrogen.network.grid.Grid method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.hydrogen.network.grid:src.models.hydrogen.network.grid.Grid.recursive_region_generation}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{recursive\_region\_generation}}}
{\sphinxparam{\DUrole{n}{df}}\sphinxparamcomma \sphinxparam{\DUrole{n}{parent}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
cycle through a region dataframe, left column to right until it hits data column, adding
new regions and subregions according to how it is hierarchically structured. Future versions
should implement this with a graph structure for the data instead of a dataframe, which
would be more natural.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{df}} (\sphinxstyleliteralemphasis{\sphinxupquote{DataFrame}}) \textendash{} hierarchically structured dataframe of regions and their data.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{parent}} ({\hyperref[\detokenize{src.models.hydrogen.network.region:src.models.hydrogen.network.region.Region}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Region}}}}}) \textendash{} Parent region

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{test() (src.models.hydrogen.network.grid.Grid method)@\spxentry{test()}\spxextra{src.models.hydrogen.network.grid.Grid method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.hydrogen.network.grid:src.models.hydrogen.network.grid.Grid.test}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{test}}}
{}
{}
\pysigstopsignatures
\sphinxAtStartPar
test run

\end{fulllineitems}

\index{visualize() (src.models.hydrogen.network.grid.Grid method)@\spxentry{visualize()}\spxextra{src.models.hydrogen.network.grid.Grid method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.hydrogen.network.grid:src.models.hydrogen.network.grid.Grid.visualize}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{visualize}}}
{}
{}
\pysigstopsignatures
\sphinxAtStartPar
visualize the grid network using graphx

\end{fulllineitems}

\index{write\_data() (src.models.hydrogen.network.grid.Grid method)@\spxentry{write\_data()}\spxextra{src.models.hydrogen.network.grid.Grid method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.hydrogen.network.grid:src.models.hydrogen.network.grid.Grid.write_data}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{write\_data}}}
{}
{}
\pysigstopsignatures
\sphinxAtStartPar
\_write data to file

\end{fulllineitems}


\end{fulllineitems}


\sphinxstepscope


\subparagraph{src.models.hydrogen.network.grid\_data}
\label{\detokenize{src.models.hydrogen.network.grid_data:module-src.models.hydrogen.network.grid_data}}\label{\detokenize{src.models.hydrogen.network.grid_data:src-models-hydrogen-network-grid-data}}\label{\detokenize{src.models.hydrogen.network.grid_data::doc}}\index{module@\spxentry{module}!src.models.hydrogen.network.grid\_data@\spxentry{src.models.hydrogen.network.grid\_data}}\index{src.models.hydrogen.network.grid\_data@\spxentry{src.models.hydrogen.network.grid\_data}!module@\spxentry{module}}

\subparagraph{GRIDDATA CLASS}
\label{\detokenize{src.models.hydrogen.network.grid_data:griddata-class}}
\sphinxAtStartPar
grid\_data is the the data object that grids are generated from. It reads in raw data with a region
grid\_data is the the data object that grids are generated from. It reads in raw data with a region
filter, and holds it in one structure for easy access
\subsubsection*{Classes}


\begin{savenotes}
\sphinxatlongtablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\makeatletter
  \LTleft \@totalleftmargin plus1fill
  \LTright\dimexpr\columnwidth-\@totalleftmargin-\linewidth\relax plus1fill
\makeatother
\begin{longtable}{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\endfirsthead

\multicolumn{2}{c}{\sphinxnorowcolor
    \makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}%
}\\
\sphinxtoprule
\endhead

\sphinxbottomrule
\multicolumn{2}{r}{\sphinxnorowcolor
    \makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}%
}\\
\endfoot

\endlastfoot
\sphinxtableatstartofbodyhook

\sphinxAtStartPar
{\hyperref[\detokenize{src.models.hydrogen.network.grid_data:src.models.hydrogen.network.grid_data.GridData}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{GridData}}}}}(data\_folder{[}, regions\_of\_interest{]})
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Path}}(*args, **kwargs)
&
\sphinxAtStartPar
PurePath subclass that can make system calls.
\\
\sphinxbottomrule
\end{longtable}
\sphinxtableafterendhook
\sphinxatlongtableend
\end{savenotes}
\index{GridData (class in src.models.hydrogen.network.grid\_data)@\spxentry{GridData}\spxextra{class in src.models.hydrogen.network.grid\_data}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.hydrogen.network.grid_data:src.models.hydrogen.network.grid_data.GridData}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{\DUrole{k}{class}\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{src.models.hydrogen.network.grid\_data.}}\sphinxbfcode{\sphinxupquote{GridData}}}
{\sphinxparam{\DUrole{n}{data\_folder}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{Path}}\sphinxparamcomma \sphinxparam{\DUrole{n}{regions\_of\_interest}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{list\DUrole{p}{{[}}str\DUrole{p}{{]}}\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }None}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{None}}}
{}
\pysigstopsignatures
\end{fulllineitems}


\sphinxstepscope


\subparagraph{src.models.hydrogen.network.hub}
\label{\detokenize{src.models.hydrogen.network.hub:module-src.models.hydrogen.network.hub}}\label{\detokenize{src.models.hydrogen.network.hub:src-models-hydrogen-network-hub}}\label{\detokenize{src.models.hydrogen.network.hub::doc}}\index{module@\spxentry{module}!src.models.hydrogen.network.hub@\spxentry{src.models.hydrogen.network.hub}}\index{src.models.hydrogen.network.hub@\spxentry{src.models.hydrogen.network.hub}!module@\spxentry{module}}

\subparagraph{HUB CLASS}
\label{\detokenize{src.models.hydrogen.network.hub:hub-class}}
\sphinxAtStartPar
class objects are individual hubs, which are fundamental units of production in the model. Hubs
belong to regions, and connect to each other with transportation arcs.
\subsubsection*{Classes}


\begin{savenotes}
\sphinxatlongtablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\makeatletter
  \LTleft \@totalleftmargin plus1fill
  \LTright\dimexpr\columnwidth-\@totalleftmargin-\linewidth\relax plus1fill
\makeatother
\begin{longtable}{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\endfirsthead

\multicolumn{2}{c}{\sphinxnorowcolor
    \makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}%
}\\
\sphinxtoprule
\endhead

\sphinxbottomrule
\multicolumn{2}{r}{\sphinxnorowcolor
    \makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}%
}\\
\endfoot

\endlastfoot
\sphinxtableatstartofbodyhook

\sphinxAtStartPar
{\hyperref[\detokenize{src.models.hydrogen.network.hub:src.models.hydrogen.network.hub.Hub}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Hub}}}}}(name, region{[}, data{]})
&
\sphinxAtStartPar

\\
\sphinxbottomrule
\end{longtable}
\sphinxtableafterendhook
\sphinxatlongtableend
\end{savenotes}
\index{Hub (class in src.models.hydrogen.network.hub)@\spxentry{Hub}\spxextra{class in src.models.hydrogen.network.hub}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.hydrogen.network.hub:src.models.hydrogen.network.hub.Hub}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{\DUrole{k}{class}\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{src.models.hydrogen.network.hub.}}\sphinxbfcode{\sphinxupquote{Hub}}}
{\sphinxparam{\DUrole{n}{name}}\sphinxparamcomma \sphinxparam{\DUrole{n}{region}}\sphinxparamcomma \sphinxparam{\DUrole{n}{data}\DUrole{o}{=}\DUrole{default_value}{None}}}
{}
\pysigstopsignatures\index{add\_inbound() (src.models.hydrogen.network.hub.Hub method)@\spxentry{add\_inbound()}\spxextra{src.models.hydrogen.network.hub.Hub method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.hydrogen.network.hub:src.models.hydrogen.network.hub.Hub.add_inbound}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{add\_inbound}}}
{\sphinxparam{\DUrole{n}{arc}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
add an inbound arc to hub
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{arc}} (\sphinxstyleliteralemphasis{\sphinxupquote{Arc}}) \textendash{} add an inbound arc to hub

\end{description}\end{quote}

\end{fulllineitems}

\index{add\_outbound() (src.models.hydrogen.network.hub.Hub method)@\spxentry{add\_outbound()}\spxextra{src.models.hydrogen.network.hub.Hub method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.hydrogen.network.hub:src.models.hydrogen.network.hub.Hub.add_outbound}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{add\_outbound}}}
{\sphinxparam{\DUrole{n}{arc}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
add an outbound arc to hub
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{arc}} (\sphinxstyleliteralemphasis{\sphinxupquote{Arc}}) \textendash{} arc to add

\end{description}\end{quote}

\end{fulllineitems}

\index{change\_region() (src.models.hydrogen.network.hub.Hub method)@\spxentry{change\_region()}\spxextra{src.models.hydrogen.network.hub.Hub method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.hydrogen.network.hub:src.models.hydrogen.network.hub.Hub.change_region}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{change\_region}}}
{\sphinxparam{\DUrole{n}{new\_region}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
move hub to new region
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{new\_region}} ({\hyperref[\detokenize{src.models.hydrogen.network.region:src.models.hydrogen.network.region.Region}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Region}}}}}) \textendash{} region hub should be moved to

\end{description}\end{quote}

\end{fulllineitems}

\index{cost() (src.models.hydrogen.network.hub.Hub method)@\spxentry{cost()}\spxextra{src.models.hydrogen.network.hub.Hub method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.hydrogen.network.hub:src.models.hydrogen.network.hub.Hub.cost}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{cost}}}
{\sphinxparam{\DUrole{n}{technology}}\sphinxparamcomma \sphinxparam{\DUrole{n}{year}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
return a cost value in terms of data fields
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{technology}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} technology type

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{year}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} year

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
a cost value

\sphinxlineitem{Return type}
\sphinxAtStartPar
float

\end{description}\end{quote}

\end{fulllineitems}

\index{display\_outbound() (src.models.hydrogen.network.hub.Hub method)@\spxentry{display\_outbound()}\spxextra{src.models.hydrogen.network.hub.Hub method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.hydrogen.network.hub:src.models.hydrogen.network.hub.Hub.display_outbound}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{display\_outbound}}}
{}
{}
\pysigstopsignatures
\sphinxAtStartPar
print all outbound arcs from hub

\end{fulllineitems}

\index{get\_data() (src.models.hydrogen.network.hub.Hub method)@\spxentry{get\_data()}\spxextra{src.models.hydrogen.network.hub.Hub method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.hydrogen.network.hub:src.models.hydrogen.network.hub.Hub.get_data}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{get\_data}}}
{\sphinxparam{\DUrole{n}{quantity}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
fetch quantity from hub data
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{quantity}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} name of data field to fetch

\sphinxlineitem{Returns}
\sphinxAtStartPar
quantity to be fetched

\sphinxlineitem{Return type}
\sphinxAtStartPar
float or str

\end{description}\end{quote}

\end{fulllineitems}

\index{remove\_inbound() (src.models.hydrogen.network.hub.Hub method)@\spxentry{remove\_inbound()}\spxextra{src.models.hydrogen.network.hub.Hub method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.hydrogen.network.hub:src.models.hydrogen.network.hub.Hub.remove_inbound}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{remove\_inbound}}}
{\sphinxparam{\DUrole{n}{arc}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
remove an inbound arc from hub
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{arc}} (\sphinxstyleliteralemphasis{\sphinxupquote{Arc}}) \textendash{} arc to remove

\end{description}\end{quote}

\end{fulllineitems}

\index{remove\_outbound() (src.models.hydrogen.network.hub.Hub method)@\spxentry{remove\_outbound()}\spxextra{src.models.hydrogen.network.hub.Hub method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.hydrogen.network.hub:src.models.hydrogen.network.hub.Hub.remove_outbound}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{remove\_outbound}}}
{\sphinxparam{\DUrole{n}{arc}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
remove an outbound arc from hub
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{arc}} (\sphinxstyleliteralemphasis{\sphinxupquote{Arc}}) \textendash{} arc to remove

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}


\sphinxstepscope


\subparagraph{src.models.hydrogen.network.region}
\label{\detokenize{src.models.hydrogen.network.region:module-src.models.hydrogen.network.region}}\label{\detokenize{src.models.hydrogen.network.region:src-models-hydrogen-network-region}}\label{\detokenize{src.models.hydrogen.network.region::doc}}\index{module@\spxentry{module}!src.models.hydrogen.network.region@\spxentry{src.models.hydrogen.network.region}}\index{src.models.hydrogen.network.region@\spxentry{src.models.hydrogen.network.region}!module@\spxentry{module}}

\subparagraph{REGION CLASS}
\label{\detokenize{src.models.hydrogen.network.region:region-class}}
\sphinxAtStartPar
Class objects are regions, which have a natural tree\sphinxhyphen{}structure. Each region can have a parent region
and child regions (subregions), a data object, and a set of hubs.
\subsubsection*{Functions}


\begin{savenotes}
\sphinxatlongtablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\makeatletter
  \LTleft \@totalleftmargin plus1fill
  \LTright\dimexpr\columnwidth-\@totalleftmargin-\linewidth\relax plus1fill
\makeatother
\begin{longtable}{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\endfirsthead

\multicolumn{2}{c}{\sphinxnorowcolor
    \makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}%
}\\
\sphinxtoprule
\endhead

\sphinxbottomrule
\multicolumn{2}{r}{\sphinxnorowcolor
    \makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}%
}\\
\endfoot

\endlastfoot
\sphinxtableatstartofbodyhook

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{getLogger}}({[}name{]})
&
\sphinxAtStartPar
Return a logger with the specified name, creating it if necessary.
\\
\sphinxbottomrule
\end{longtable}
\sphinxtableafterendhook
\sphinxatlongtableend
\end{savenotes}
\subsubsection*{Classes}


\begin{savenotes}
\sphinxatlongtablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\makeatletter
  \LTleft \@totalleftmargin plus1fill
  \LTright\dimexpr\columnwidth-\@totalleftmargin-\linewidth\relax plus1fill
\makeatother
\begin{longtable}{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\endfirsthead

\multicolumn{2}{c}{\sphinxnorowcolor
    \makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}%
}\\
\sphinxtoprule
\endhead

\sphinxbottomrule
\multicolumn{2}{r}{\sphinxnorowcolor
    \makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}%
}\\
\endfoot

\endlastfoot
\sphinxtableatstartofbodyhook

\sphinxAtStartPar
{\hyperref[\detokenize{src.models.hydrogen.network.region:src.models.hydrogen.network.region.Region}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Region}}}}}(name{[}, grid, kind, data, parent{]})
&
\sphinxAtStartPar

\\
\sphinxbottomrule
\end{longtable}
\sphinxtableafterendhook
\sphinxatlongtableend
\end{savenotes}
\index{Region (class in src.models.hydrogen.network.region)@\spxentry{Region}\spxextra{class in src.models.hydrogen.network.region}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.hydrogen.network.region:src.models.hydrogen.network.region.Region}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{\DUrole{k}{class}\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{src.models.hydrogen.network.region.}}\sphinxbfcode{\sphinxupquote{Region}}}
{\sphinxparam{\DUrole{n}{name}}\sphinxparamcomma \sphinxparam{\DUrole{n}{grid}\DUrole{o}{=}\DUrole{default_value}{None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{kind}\DUrole{o}{=}\DUrole{default_value}{None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{data}\DUrole{o}{=}\DUrole{default_value}{None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{parent}\DUrole{o}{=}\DUrole{default_value}{None}}}
{}
\pysigstopsignatures\index{absorb\_subregions() (src.models.hydrogen.network.region.Region method)@\spxentry{absorb\_subregions()}\spxextra{src.models.hydrogen.network.region.Region method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.hydrogen.network.region:src.models.hydrogen.network.region.Region.absorb_subregions}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{absorb\_subregions}}}
{}
{}
\pysigstopsignatures
\sphinxAtStartPar
delete subregions, acquire their hubs and subregions

\end{fulllineitems}

\index{absorb\_subregions\_deep() (src.models.hydrogen.network.region.Region method)@\spxentry{absorb\_subregions\_deep()}\spxextra{src.models.hydrogen.network.region.Region method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.hydrogen.network.region:src.models.hydrogen.network.region.Region.absorb_subregions_deep}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{absorb\_subregions\_deep}}}
{}
{}
\pysigstopsignatures
\sphinxAtStartPar
absorb subregions recursively so that region becomes to the deepest level in the hierarchy

\end{fulllineitems}

\index{add\_hub() (src.models.hydrogen.network.region.Region method)@\spxentry{add\_hub()}\spxextra{src.models.hydrogen.network.region.Region method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.hydrogen.network.region:src.models.hydrogen.network.region.Region.add_hub}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{add\_hub}}}
{\sphinxparam{\DUrole{n}{hub}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
add a hub to region
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{hub}} ({\hyperref[\detokenize{src.models.hydrogen.network.hub:src.models.hydrogen.network.hub.Hub}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Hub}}}}}) \textendash{} hub to add

\end{description}\end{quote}

\end{fulllineitems}

\index{add\_subregion() (src.models.hydrogen.network.region.Region method)@\spxentry{add\_subregion()}\spxextra{src.models.hydrogen.network.region.Region method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.hydrogen.network.region:src.models.hydrogen.network.region.Region.add_subregion}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{add\_subregion}}}
{\sphinxparam{\DUrole{n}{subregion}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
make a region a subregion of self
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{subregion}} ({\hyperref[\detokenize{src.models.hydrogen.network.region:src.models.hydrogen.network.region.Region}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Region}}}}}) \textendash{} new subregion

\end{description}\end{quote}

\end{fulllineitems}

\index{aggregate\_subregion\_data() (src.models.hydrogen.network.region.Region method)@\spxentry{aggregate\_subregion\_data()}\spxextra{src.models.hydrogen.network.region.Region method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.hydrogen.network.region:src.models.hydrogen.network.region.Region.aggregate_subregion_data}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{aggregate\_subregion\_data}}}
{\sphinxparam{\DUrole{n}{subregions}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
combine the data from subregions and assign it to self
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{subregions}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}) \textendash{} list of subregions

\end{description}\end{quote}

\end{fulllineitems}

\index{assigned\_names (src.models.hydrogen.network.region.Region attribute)@\spxentry{assigned\_names}\spxextra{src.models.hydrogen.network.region.Region attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.hydrogen.network.region:src.models.hydrogen.network.region.Region.assigned_names}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{assigned\_names}}\sphinxbfcode{\sphinxupquote{\DUrole{w}{ }\DUrole{p}{=}\DUrole{w}{ }\{\}}}}
\pysigstopsignatures
\end{fulllineitems}

\index{create\_subregion() (src.models.hydrogen.network.region.Region method)@\spxentry{create\_subregion()}\spxextra{src.models.hydrogen.network.region.Region method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.hydrogen.network.region:src.models.hydrogen.network.region.Region.create_subregion}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{create\_subregion}}}
{\sphinxparam{\DUrole{n}{name}}\sphinxparamcomma \sphinxparam{\DUrole{n}{data}\DUrole{o}{=}\DUrole{default_value}{None}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
create a subregion
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{name}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} subregion name

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{data}} (\sphinxstyleliteralemphasis{\sphinxupquote{DataFrame}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} subregion data. Defaults to None.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{delete() (src.models.hydrogen.network.region.Region method)@\spxentry{delete()}\spxextra{src.models.hydrogen.network.region.Region method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.hydrogen.network.region:src.models.hydrogen.network.region.Region.delete}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{delete}}}
{}
{}
\pysigstopsignatures
\sphinxAtStartPar
delete self, reassign hubs to parent, reassign children to parent

\end{fulllineitems}

\index{display\_children() (src.models.hydrogen.network.region.Region method)@\spxentry{display\_children()}\spxextra{src.models.hydrogen.network.region.Region method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.hydrogen.network.region:src.models.hydrogen.network.region.Region.display_children}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{display\_children}}}
{}
{}
\pysigstopsignatures
\sphinxAtStartPar
display child regions

\end{fulllineitems}

\index{display\_hubs() (src.models.hydrogen.network.region.Region method)@\spxentry{display\_hubs()}\spxextra{src.models.hydrogen.network.region.Region method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.hydrogen.network.region:src.models.hydrogen.network.region.Region.display_hubs}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{display\_hubs}}}
{}
{}
\pysigstopsignatures
\sphinxAtStartPar
display hubs

\end{fulllineitems}

\index{get\_data() (src.models.hydrogen.network.region.Region method)@\spxentry{get\_data()}\spxextra{src.models.hydrogen.network.region.Region method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.hydrogen.network.region:src.models.hydrogen.network.region.Region.get_data}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{get\_data}}}
{\sphinxparam{\DUrole{n}{quantity}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
pull data from region data
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{quantity}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} name of data field in region data

\sphinxlineitem{Returns}
\sphinxAtStartPar
value of data

\sphinxlineitem{Return type}
\sphinxAtStartPar
str, float

\end{description}\end{quote}

\end{fulllineitems}

\index{remove\_hub() (src.models.hydrogen.network.region.Region method)@\spxentry{remove\_hub()}\spxextra{src.models.hydrogen.network.region.Region method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.hydrogen.network.region:src.models.hydrogen.network.region.Region.remove_hub}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{remove\_hub}}}
{\sphinxparam{\DUrole{n}{hub}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
remove hub from region
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{hub}} ({\hyperref[\detokenize{src.models.hydrogen.network.hub:src.models.hydrogen.network.hub.Hub}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Hub}}}}}) \textendash{} hub to remove

\end{description}\end{quote}

\end{fulllineitems}

\index{remove\_subregion() (src.models.hydrogen.network.region.Region method)@\spxentry{remove\_subregion()}\spxextra{src.models.hydrogen.network.region.Region method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.hydrogen.network.region:src.models.hydrogen.network.region.Region.remove_subregion}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{remove\_subregion}}}
{\sphinxparam{\DUrole{n}{subregion}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
remove a subregion from self
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{subregion}} ({\hyperref[\detokenize{src.models.hydrogen.network.region:src.models.hydrogen.network.region.Region}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Region}}}}}) \textendash{} subregion to remove

\end{description}\end{quote}

\end{fulllineitems}

\index{update\_data() (src.models.hydrogen.network.region.Region method)@\spxentry{update\_data()}\spxextra{src.models.hydrogen.network.region.Region method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.hydrogen.network.region:src.models.hydrogen.network.region.Region.update_data}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{update\_data}}}
{\sphinxparam{\DUrole{n}{df}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
change region data
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{df}} (\sphinxstyleliteralemphasis{\sphinxupquote{DataFrame}}) \textendash{} new data

\end{description}\end{quote}

\end{fulllineitems}

\index{update\_parent() (src.models.hydrogen.network.region.Region method)@\spxentry{update\_parent()}\spxextra{src.models.hydrogen.network.region.Region method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.hydrogen.network.region:src.models.hydrogen.network.region.Region.update_parent}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{update\_parent}}}
{\sphinxparam{\DUrole{n}{new\_parent}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
change parent region
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{new\_parent}} ({\hyperref[\detokenize{src.models.hydrogen.network.region:src.models.hydrogen.network.region.Region}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Region}}}}}) \textendash{} new parent region

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}


\sphinxstepscope


\subparagraph{src.models.hydrogen.network.registry}
\label{\detokenize{src.models.hydrogen.network.registry:module-src.models.hydrogen.network.registry}}\label{\detokenize{src.models.hydrogen.network.registry:src-models-hydrogen-network-registry}}\label{\detokenize{src.models.hydrogen.network.registry::doc}}\index{module@\spxentry{module}!src.models.hydrogen.network.registry@\spxentry{src.models.hydrogen.network.registry}}\index{src.models.hydrogen.network.registry@\spxentry{src.models.hydrogen.network.registry}!module@\spxentry{module}}

\subparagraph{REGISTRY CLASS}
\label{\detokenize{src.models.hydrogen.network.registry:registry-class}}
\sphinxAtStartPar
This class is the central registry of all objects in a grid. It preserves them in dicts of
object\sphinxhyphen{}name:object so that they can be looked up by name. it also should serve as a place to save
data in different configurations for faster parsing \sphinxhyphen{} for example, depth is a dict that organizes
regions according to their depth in the region nesting tree.
\subsubsection*{Classes}


\begin{savenotes}
\sphinxatlongtablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\makeatletter
  \LTleft \@totalleftmargin plus1fill
  \LTright\dimexpr\columnwidth-\@totalleftmargin-\linewidth\relax plus1fill
\makeatother
\begin{longtable}{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\endfirsthead

\multicolumn{2}{c}{\sphinxnorowcolor
    \makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}%
}\\
\sphinxtoprule
\endhead

\sphinxbottomrule
\multicolumn{2}{r}{\sphinxnorowcolor
    \makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}%
}\\
\endfoot

\endlastfoot
\sphinxtableatstartofbodyhook

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Hub}}(name, region{[}, data{]})
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Region}}(name{[}, grid, kind, data, parent{]})
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.models.hydrogen.network.registry:src.models.hydrogen.network.registry.Registry}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Registry}}}}}()
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{TransportationArc}}(origin, destination, capacity)
&
\sphinxAtStartPar

\\
\sphinxbottomrule
\end{longtable}
\sphinxtableafterendhook
\sphinxatlongtableend
\end{savenotes}
\index{Registry (class in src.models.hydrogen.network.registry)@\spxentry{Registry}\spxextra{class in src.models.hydrogen.network.registry}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.hydrogen.network.registry:src.models.hydrogen.network.registry.Registry}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{\DUrole{k}{class}\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{src.models.hydrogen.network.registry.}}\sphinxbfcode{\sphinxupquote{Registry}}}
\pysigstopsignatures\index{add() (src.models.hydrogen.network.registry.Registry method)@\spxentry{add()}\spxextra{src.models.hydrogen.network.registry.Registry method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.hydrogen.network.registry:src.models.hydrogen.network.registry.Registry.add}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{add}}}
{\sphinxparam{\DUrole{n}{thing}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
add a thing to the registry. Thing can be Hub,Arc, or Region
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{thing}} (\sphinxstyleliteralemphasis{\sphinxupquote{Arc}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}{\hyperref[\detokenize{src.models.hydrogen.network.region:src.models.hydrogen.network.region.Region}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Region}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{, or }}{\hyperref[\detokenize{src.models.hydrogen.network.hub:src.models.hydrogen.network.hub.Hub}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Hub}}}}}) \textendash{} thing to add to registry

\sphinxlineitem{Returns}
\sphinxAtStartPar
thing being added gets returned

\sphinxlineitem{Return type}
\sphinxAtStartPar
Arc, {\hyperref[\detokenize{src.models.hydrogen.network.region:src.models.hydrogen.network.region.Region}]{\sphinxcrossref{Region}}}, or {\hyperref[\detokenize{src.models.hydrogen.network.hub:src.models.hydrogen.network.hub.Hub}]{\sphinxcrossref{Hub}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{remove() (src.models.hydrogen.network.registry.Registry method)@\spxentry{remove()}\spxextra{src.models.hydrogen.network.registry.Registry method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.hydrogen.network.registry:src.models.hydrogen.network.registry.Registry.remove}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{remove}}}
{\sphinxparam{\DUrole{n}{thing}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
remove thing from registry
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{thing}} (\sphinxstyleliteralemphasis{\sphinxupquote{Arc}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}{\hyperref[\detokenize{src.models.hydrogen.network.hub:src.models.hydrogen.network.hub.Hub}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Hub}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{, or }}{\hyperref[\detokenize{src.models.hydrogen.network.region:src.models.hydrogen.network.region.Region}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Region}}}}}) \textendash{} thing to remove

\end{description}\end{quote}

\end{fulllineitems}

\index{update\_levels() (src.models.hydrogen.network.registry.Registry method)@\spxentry{update\_levels()}\spxextra{src.models.hydrogen.network.registry.Registry method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.hydrogen.network.registry:src.models.hydrogen.network.registry.Registry.update_levels}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{update\_levels}}}
{}
{}
\pysigstopsignatures
\sphinxAtStartPar
update dictionary of regions by level

\end{fulllineitems}


\end{fulllineitems}


\sphinxstepscope


\subparagraph{src.models.hydrogen.network.transportation\_arc}
\label{\detokenize{src.models.hydrogen.network.transportation_arc:module-src.models.hydrogen.network.transportation_arc}}\label{\detokenize{src.models.hydrogen.network.transportation_arc:src-models-hydrogen-network-transportation-arc}}\label{\detokenize{src.models.hydrogen.network.transportation_arc::doc}}\index{module@\spxentry{module}!src.models.hydrogen.network.transportation\_arc@\spxentry{src.models.hydrogen.network.transportation\_arc}}\index{src.models.hydrogen.network.transportation\_arc@\spxentry{src.models.hydrogen.network.transportation\_arc}!module@\spxentry{module}}

\subparagraph{TRANSPORTATION ARC CLASS}
\label{\detokenize{src.models.hydrogen.network.transportation_arc:transportation-arc-class}}
\sphinxAtStartPar
objects in this class represent individual transportation arcs. An arc can exist with zero capacity,
so they only represent \sphinxstyleemphasis{possible} arcs.
\subsubsection*{Classes}


\begin{savenotes}
\sphinxatlongtablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\makeatletter
  \LTleft \@totalleftmargin plus1fill
  \LTright\dimexpr\columnwidth-\@totalleftmargin-\linewidth\relax plus1fill
\makeatother
\begin{longtable}{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\endfirsthead

\multicolumn{2}{c}{\sphinxnorowcolor
    \makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}%
}\\
\sphinxtoprule
\endhead

\sphinxbottomrule
\multicolumn{2}{r}{\sphinxnorowcolor
    \makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}%
}\\
\endfoot

\endlastfoot
\sphinxtableatstartofbodyhook

\sphinxAtStartPar
{\hyperref[\detokenize{src.models.hydrogen.network.transportation_arc:src.models.hydrogen.network.transportation_arc.TransportationArc}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{TransportationArc}}}}}(origin, destination, capacity)
&
\sphinxAtStartPar

\\
\sphinxbottomrule
\end{longtable}
\sphinxtableafterendhook
\sphinxatlongtableend
\end{savenotes}
\index{TransportationArc (class in src.models.hydrogen.network.transportation\_arc)@\spxentry{TransportationArc}\spxextra{class in src.models.hydrogen.network.transportation\_arc}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.hydrogen.network.transportation_arc:src.models.hydrogen.network.transportation_arc.TransportationArc}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{\DUrole{k}{class}\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{src.models.hydrogen.network.transportation\_arc.}}\sphinxbfcode{\sphinxupquote{TransportationArc}}}
{\sphinxparam{\DUrole{n}{origin}}\sphinxparamcomma \sphinxparam{\DUrole{n}{destination}}\sphinxparamcomma \sphinxparam{\DUrole{n}{capacity}}\sphinxparamcomma \sphinxparam{\DUrole{n}{cost}\DUrole{o}{=}\DUrole{default_value}{0}}}
{}
\pysigstopsignatures\index{change\_destination() (src.models.hydrogen.network.transportation\_arc.TransportationArc method)@\spxentry{change\_destination()}\spxextra{src.models.hydrogen.network.transportation\_arc.TransportationArc method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.hydrogen.network.transportation_arc:src.models.hydrogen.network.transportation_arc.TransportationArc.change_destination}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{change\_destination}}}
{\sphinxparam{\DUrole{n}{new\_destination}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
change the destination hub of arc
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{new\_destination}} ({\hyperref[\detokenize{src.models.hydrogen.network.hub:src.models.hydrogen.network.hub.Hub}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Hub}}}}}) \textendash{} new destination hub

\end{description}\end{quote}

\end{fulllineitems}

\index{change\_origin() (src.models.hydrogen.network.transportation\_arc.TransportationArc method)@\spxentry{change\_origin()}\spxextra{src.models.hydrogen.network.transportation\_arc.TransportationArc method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.hydrogen.network.transportation_arc:src.models.hydrogen.network.transportation_arc.TransportationArc.change_origin}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{change\_origin}}}
{\sphinxparam{\DUrole{n}{new\_origin}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
change the origin hub of arc
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{new\_origin}} ({\hyperref[\detokenize{src.models.hydrogen.network.hub:src.models.hydrogen.network.hub.Hub}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Hub}}}}}) \textendash{} new origin hub

\end{description}\end{quote}

\end{fulllineitems}

\index{disconnect() (src.models.hydrogen.network.transportation\_arc.TransportationArc method)@\spxentry{disconnect()}\spxextra{src.models.hydrogen.network.transportation\_arc.TransportationArc method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.hydrogen.network.transportation_arc:src.models.hydrogen.network.transportation_arc.TransportationArc.disconnect}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{disconnect}}}
{}
{}
\pysigstopsignatures
\sphinxAtStartPar
disconnect arc from it’s origin and destination

\end{fulllineitems}


\end{fulllineitems}


\sphinxstepscope


\paragraph{src.models.hydrogen.utilities}
\label{\detokenize{src.models.hydrogen.utilities:module-src.models.hydrogen.utilities}}\label{\detokenize{src.models.hydrogen.utilities:src-models-hydrogen-utilities}}\label{\detokenize{src.models.hydrogen.utilities::doc}}\index{module@\spxentry{module}!src.models.hydrogen.utilities@\spxentry{src.models.hydrogen.utilities}}\index{src.models.hydrogen.utilities@\spxentry{src.models.hydrogen.utilities}!module@\spxentry{module}}\subsubsection*{Modules}


\begin{savenotes}
\sphinxatlongtablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\makeatletter
  \LTleft \@totalleftmargin plus1fill
  \LTright\dimexpr\columnwidth-\@totalleftmargin-\linewidth\relax plus1fill
\makeatother
\begin{longtable}{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\endfirsthead

\multicolumn{2}{c}{\sphinxnorowcolor
    \makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}%
}\\
\sphinxtoprule
\endhead

\sphinxbottomrule
\multicolumn{2}{r}{\sphinxnorowcolor
    \makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}%
}\\
\endfoot

\endlastfoot
\sphinxtableatstartofbodyhook

\sphinxAtStartPar
{\hyperref[\detokenize{src.models.hydrogen.utilities.h2_functions:module-src.models.hydrogen.utilities.h2_functions}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{h2\_functions}}}}}
&
\sphinxAtStartPar
This file is a collection of functions that are used in support of the hydrogen model.
\\
\sphinxbottomrule
\end{longtable}
\sphinxtableafterendhook
\sphinxatlongtableend
\end{savenotes}

\sphinxstepscope


\subparagraph{src.models.hydrogen.utilities.h2\_functions}
\label{\detokenize{src.models.hydrogen.utilities.h2_functions:module-src.models.hydrogen.utilities.h2_functions}}\label{\detokenize{src.models.hydrogen.utilities.h2_functions:src-models-hydrogen-utilities-h2-functions}}\label{\detokenize{src.models.hydrogen.utilities.h2_functions::doc}}\index{module@\spxentry{module}!src.models.hydrogen.utilities.h2\_functions@\spxentry{src.models.hydrogen.utilities.h2\_functions}}\index{src.models.hydrogen.utilities.h2\_functions@\spxentry{src.models.hydrogen.utilities.h2\_functions}!module@\spxentry{module}}
\sphinxAtStartPar
This file is a collection of functions that are used in support of the hydrogen model.
\subsubsection*{Functions}


\begin{savenotes}
\sphinxatlongtablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\makeatletter
  \LTleft \@totalleftmargin plus1fill
  \LTright\dimexpr\columnwidth-\@totalleftmargin-\linewidth\relax plus1fill
\makeatother
\begin{longtable}{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\endfirsthead

\multicolumn{2}{c}{\sphinxnorowcolor
    \makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}%
}\\
\sphinxtoprule
\endhead

\sphinxbottomrule
\multicolumn{2}{r}{\sphinxnorowcolor
    \makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}%
}\\
\endfoot

\endlastfoot
\sphinxtableatstartofbodyhook

\sphinxAtStartPar
{\hyperref[\detokenize{src.models.hydrogen.utilities.h2_functions:src.models.hydrogen.utilities.h2_functions.get_demand}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_demand}}}}}(hm, region, time)
&
\sphinxAtStartPar
get demand for region at time.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.models.hydrogen.utilities.h2_functions:src.models.hydrogen.utilities.h2_functions.get_elec_price}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_elec\_price}}}}}(hm, region, year)
&
\sphinxAtStartPar
get electricity price in region, year
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.models.hydrogen.utilities.h2_functions:src.models.hydrogen.utilities.h2_functions.get_electricity_consumption_rate}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_electricity\_consumption\_rate}}}}}(hm, tech)
&
\sphinxAtStartPar
the electricity consumption rate for technology type tech
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.models.hydrogen.utilities.h2_functions:src.models.hydrogen.utilities.h2_functions.get_electricty_consumption}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_electricty\_consumption}}}}}(hm, region, year)
&
\sphinxAtStartPar
get electricity consumption for region, year
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.models.hydrogen.utilities.h2_functions:src.models.hydrogen.utilities.h2_functions.get_gas_price}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_gas\_price}}}}}(hm, region, year)
&
\sphinxAtStartPar
get gas price for region, year
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.models.hydrogen.utilities.h2_functions:src.models.hydrogen.utilities.h2_functions.get_production_cost}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_production\_cost}}}}}(hm, hub, tech, year)
&
\sphinxAtStartPar
return production cost for tech at hub in year
\\
\sphinxbottomrule
\end{longtable}
\sphinxtableafterendhook
\sphinxatlongtableend
\end{savenotes}
\index{get\_demand() (in module src.models.hydrogen.utilities.h2\_functions)@\spxentry{get\_demand()}\spxextra{in module src.models.hydrogen.utilities.h2\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.hydrogen.utilities.h2_functions:src.models.hydrogen.utilities.h2_functions.get_demand}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{src.models.hydrogen.utilities.h2\_functions.}}\sphinxbfcode{\sphinxupquote{get\_demand}}}
{\sphinxparam{\DUrole{n}{hm}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{{\hyperref[\detokenize{src.models.hydrogen.model.h2_model:src.models.hydrogen.model.h2_model.H2Model}]{\sphinxcrossref{H2Model}}}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{region}}\sphinxparamcomma \sphinxparam{\DUrole{n}{time}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
get demand for region at time. If mode not standard, just increase demand by 5\% per year
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{hm}} ({\hyperref[\detokenize{src.models.hydrogen.model.h2_model:src.models.hydrogen.model.h2_model.H2Model}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{H2Model}}}}}) \textendash{} model

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{region}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} region

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{time}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} year

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
demand

\sphinxlineitem{Return type}
\sphinxAtStartPar
float

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_elec\_price() (in module src.models.hydrogen.utilities.h2\_functions)@\spxentry{get\_elec\_price()}\spxextra{in module src.models.hydrogen.utilities.h2\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.hydrogen.utilities.h2_functions:src.models.hydrogen.utilities.h2_functions.get_elec_price}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{src.models.hydrogen.utilities.h2\_functions.}}\sphinxbfcode{\sphinxupquote{get\_elec\_price}}}
{\sphinxparam{\DUrole{n}{hm}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{{\hyperref[\detokenize{src.models.hydrogen.model.h2_model:src.models.hydrogen.model.h2_model.H2Model}]{\sphinxcrossref{H2Model}}}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{region}}\sphinxparamcomma \sphinxparam{\DUrole{n}{year}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
get electricity price in region, year
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{hm}} ({\hyperref[\detokenize{src.models.hydrogen.model.h2_model:src.models.hydrogen.model.h2_model.H2Model}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{H2Model}}}}}) \textendash{} \_model

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{region}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} region

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{year}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} year

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
electricity price in region and year

\sphinxlineitem{Return type}
\sphinxAtStartPar
float

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_electricity\_consumption\_rate() (in module src.models.hydrogen.utilities.h2\_functions)@\spxentry{get\_electricity\_consumption\_rate()}\spxextra{in module src.models.hydrogen.utilities.h2\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.hydrogen.utilities.h2_functions:src.models.hydrogen.utilities.h2_functions.get_electricity_consumption_rate}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{src.models.hydrogen.utilities.h2\_functions.}}\sphinxbfcode{\sphinxupquote{get\_electricity\_consumption\_rate}}}
{\sphinxparam{\DUrole{n}{hm}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{{\hyperref[\detokenize{src.models.hydrogen.model.h2_model:src.models.hydrogen.model.h2_model.H2Model}]{\sphinxcrossref{H2Model}}}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{tech}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
the electricity consumption rate for technology type tech
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{hm}} ({\hyperref[\detokenize{src.models.hydrogen.model.h2_model:src.models.hydrogen.model.h2_model.H2Model}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{H2Model}}}}}) \textendash{} model

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{tech}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} technology type

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
GWh per kg H2

\sphinxlineitem{Return type}
\sphinxAtStartPar
float

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_electricty\_consumption() (in module src.models.hydrogen.utilities.h2\_functions)@\spxentry{get\_electricty\_consumption()}\spxextra{in module src.models.hydrogen.utilities.h2\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.hydrogen.utilities.h2_functions:src.models.hydrogen.utilities.h2_functions.get_electricty_consumption}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{src.models.hydrogen.utilities.h2\_functions.}}\sphinxbfcode{\sphinxupquote{get\_electricty\_consumption}}}
{\sphinxparam{\DUrole{n}{hm}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{{\hyperref[\detokenize{src.models.hydrogen.model.h2_model:src.models.hydrogen.model.h2_model.H2Model}]{\sphinxcrossref{H2Model}}}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{region}}\sphinxparamcomma \sphinxparam{\DUrole{n}{year}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
get electricity consumption for region, year
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{hm}} ({\hyperref[\detokenize{src.models.hydrogen.model.h2_model:src.models.hydrogen.model.h2_model.H2Model}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{H2Model}}}}}) \textendash{} model

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{region}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} region

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{year}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} year

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
the elecctricity consumption for a region and year in the model

\sphinxlineitem{Return type}
\sphinxAtStartPar
float

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_gas\_price() (in module src.models.hydrogen.utilities.h2\_functions)@\spxentry{get\_gas\_price()}\spxextra{in module src.models.hydrogen.utilities.h2\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.hydrogen.utilities.h2_functions:src.models.hydrogen.utilities.h2_functions.get_gas_price}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{src.models.hydrogen.utilities.h2\_functions.}}\sphinxbfcode{\sphinxupquote{get\_gas\_price}}}
{\sphinxparam{\DUrole{n}{hm}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{{\hyperref[\detokenize{src.models.hydrogen.model.h2_model:src.models.hydrogen.model.h2_model.H2Model}]{\sphinxcrossref{H2Model}}}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{region}}\sphinxparamcomma \sphinxparam{\DUrole{n}{year}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
get gas price for region, year
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{hm}} ({\hyperref[\detokenize{src.models.hydrogen.model.h2_model:src.models.hydrogen.model.h2_model.H2Model}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{H2Model}}}}}) \textendash{} model

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{region}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} region

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{year}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} year

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
gas price in region and year

\sphinxlineitem{Return type}
\sphinxAtStartPar
float

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_production\_cost() (in module src.models.hydrogen.utilities.h2\_functions)@\spxentry{get\_production\_cost()}\spxextra{in module src.models.hydrogen.utilities.h2\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.hydrogen.utilities.h2_functions:src.models.hydrogen.utilities.h2_functions.get_production_cost}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{src.models.hydrogen.utilities.h2\_functions.}}\sphinxbfcode{\sphinxupquote{get\_production\_cost}}}
{\sphinxparam{\DUrole{n}{hm}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{{\hyperref[\detokenize{src.models.hydrogen.model.h2_model:src.models.hydrogen.model.h2_model.H2Model}]{\sphinxcrossref{H2Model}}}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{hub}}\sphinxparamcomma \sphinxparam{\DUrole{n}{tech}}\sphinxparamcomma \sphinxparam{\DUrole{n}{year}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
return production cost for tech at hub in year
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{hm}} ({\hyperref[\detokenize{src.models.hydrogen.model.h2_model:src.models.hydrogen.model.h2_model.H2Model}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{H2Model}}}}}) \textendash{} model

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{hub}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} hub

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{tech}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} technology type

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{year}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} year

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
production cost of H2 for tech at hub in year

\sphinxlineitem{Return type}
\sphinxAtStartPar
float

\end{description}\end{quote}

\end{fulllineitems}


\sphinxstepscope


\subsubsection{src.models.residential}
\label{\detokenize{src.models.residential:module-src.models.residential}}\label{\detokenize{src.models.residential:src-models-residential}}\label{\detokenize{src.models.residential::doc}}\index{module@\spxentry{module}!src.models.residential@\spxentry{src.models.residential}}\index{src.models.residential@\spxentry{src.models.residential}!module@\spxentry{module}}\subsubsection*{Modules}


\begin{savenotes}
\sphinxatlongtablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\makeatletter
  \LTleft \@totalleftmargin plus1fill
  \LTright\dimexpr\columnwidth-\@totalleftmargin-\linewidth\relax plus1fill
\makeatother
\begin{longtable}{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\endfirsthead

\multicolumn{2}{c}{\sphinxnorowcolor
    \makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}%
}\\
\sphinxtoprule
\endhead

\sphinxbottomrule
\multicolumn{2}{r}{\sphinxnorowcolor
    \makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}%
}\\
\endfoot

\endlastfoot
\sphinxtableatstartofbodyhook

\sphinxAtStartPar
{\hyperref[\detokenize{src.models.residential.preprocessor:module-src.models.residential.preprocessor}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{preprocessor}}}}}
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.models.residential.scripts:module-src.models.residential.scripts}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{scripts}}}}}
&
\sphinxAtStartPar

\\
\sphinxbottomrule
\end{longtable}
\sphinxtableafterendhook
\sphinxatlongtableend
\end{savenotes}

\sphinxstepscope


\paragraph{src.models.residential.preprocessor}
\label{\detokenize{src.models.residential.preprocessor:module-src.models.residential.preprocessor}}\label{\detokenize{src.models.residential.preprocessor:src-models-residential-preprocessor}}\label{\detokenize{src.models.residential.preprocessor::doc}}\index{module@\spxentry{module}!src.models.residential.preprocessor@\spxentry{src.models.residential.preprocessor}}\index{src.models.residential.preprocessor@\spxentry{src.models.residential.preprocessor}!module@\spxentry{module}}\subsubsection*{Modules}


\begin{savenotes}
\sphinxatlongtablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\makeatletter
  \LTleft \@totalleftmargin plus1fill
  \LTright\dimexpr\columnwidth-\@totalleftmargin-\linewidth\relax plus1fill
\makeatother
\begin{longtable}{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\endfirsthead

\multicolumn{2}{c}{\sphinxnorowcolor
    \makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}%
}\\
\sphinxtoprule
\endhead

\sphinxbottomrule
\multicolumn{2}{r}{\sphinxnorowcolor
    \makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}%
}\\
\endfoot

\endlastfoot
\sphinxtableatstartofbodyhook

\sphinxAtStartPar
{\hyperref[\detokenize{src.models.residential.preprocessor.generate_inputs:module-src.models.residential.preprocessor.generate_inputs}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{generate\_inputs}}}}}
&
\sphinxAtStartPar
This file contains the options to re\sphinxhyphen{}create the input files. It creates:
\\
\sphinxbottomrule
\end{longtable}
\sphinxtableafterendhook
\sphinxatlongtableend
\end{savenotes}

\sphinxstepscope


\subparagraph{src.models.residential.preprocessor.generate\_inputs}
\label{\detokenize{src.models.residential.preprocessor.generate_inputs:module-src.models.residential.preprocessor.generate_inputs}}\label{\detokenize{src.models.residential.preprocessor.generate_inputs:src-models-residential-preprocessor-generate-inputs}}\label{\detokenize{src.models.residential.preprocessor.generate_inputs::doc}}\index{module@\spxentry{module}!src.models.residential.preprocessor.generate\_inputs@\spxentry{src.models.residential.preprocessor.generate\_inputs}}\index{src.models.residential.preprocessor.generate\_inputs@\spxentry{src.models.residential.preprocessor.generate\_inputs}!module@\spxentry{module}}\begin{description}
\sphinxlineitem{This file contains the options to re\sphinxhyphen{}create the input files. It creates:}\begin{itemize}
\item {} 
\sphinxAtStartPar
Load.csv: electricity demand for all model years (used in residential and electricity)

\item {} 
\sphinxAtStartPar
BaseElecPrice.csv: electricity prices for initial model year (used in residential only)

\end{itemize}

\end{description}

\sphinxAtStartPar
Uncomment out the functions at the end of this file in the “if \_\_name\_\_ == ‘\_\_main\_\_’” statement
in order to generate new load or base electricity prices.
\subsubsection*{Functions}


\begin{savenotes}
\sphinxatlongtablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\makeatletter
  \LTleft \@totalleftmargin plus1fill
  \LTright\dimexpr\columnwidth-\@totalleftmargin-\linewidth\relax plus1fill
\makeatother
\begin{longtable}{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\endfirsthead

\multicolumn{2}{c}{\sphinxnorowcolor
    \makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}%
}\\
\sphinxtoprule
\endhead

\sphinxbottomrule
\multicolumn{2}{r}{\sphinxnorowcolor
    \makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}%
}\\
\endfoot

\endlastfoot
\sphinxtableatstartofbodyhook

\sphinxAtStartPar
{\hyperref[\detokenize{src.models.residential.preprocessor.generate_inputs:src.models.residential.preprocessor.generate_inputs.base_price}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{base\_price}}}}}()
&
\sphinxAtStartPar
Runs the electricity model with base price configuration settings and then merges the electricity prices and temporal crosswalk data produced from the run to generate base year electricity prices.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{main}}({[}settings{]})
&
\sphinxAtStartPar
Runs model as defined in settings
\\
\sphinxbottomrule
\end{longtable}
\sphinxtableafterendhook
\sphinxatlongtableend
\end{savenotes}
\subsubsection*{Classes}


\begin{savenotes}
\sphinxatlongtablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\makeatletter
  \LTleft \@totalleftmargin plus1fill
  \LTright\dimexpr\columnwidth-\@totalleftmargin-\linewidth\relax plus1fill
\makeatother
\begin{longtable}{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\endfirsthead

\multicolumn{2}{c}{\sphinxnorowcolor
    \makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}%
}\\
\sphinxtoprule
\endhead

\sphinxbottomrule
\multicolumn{2}{r}{\sphinxnorowcolor
    \makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}%
}\\
\endfoot

\endlastfoot
\sphinxtableatstartofbodyhook

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Path}}(*args, **kwargs)
&
\sphinxAtStartPar
PurePath subclass that can make system calls.
\\
\sphinxbottomrule
\end{longtable}
\sphinxtableafterendhook
\sphinxatlongtableend
\end{savenotes}
\index{base\_price() (in module src.models.residential.preprocessor.generate\_inputs)@\spxentry{base\_price()}\spxextra{in module src.models.residential.preprocessor.generate\_inputs}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.residential.preprocessor.generate_inputs:src.models.residential.preprocessor.generate_inputs.base_price}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{src.models.residential.preprocessor.generate\_inputs.}}\sphinxbfcode{\sphinxupquote{base\_price}}}
{}
{}
\pysigstopsignatures
\sphinxAtStartPar
Runs the electricity model with base price configuration settings and then
merges the electricity prices and temporal crosswalk data produced from the run
to generate base year electricity prices.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
dataframe that contains base year electricity prices for all regions/hours

\sphinxlineitem{Return type}
\sphinxAtStartPar
pandas.core.frame.DataFrame

\end{description}\end{quote}

\end{fulllineitems}


\sphinxstepscope


\paragraph{src.models.residential.scripts}
\label{\detokenize{src.models.residential.scripts:module-src.models.residential.scripts}}\label{\detokenize{src.models.residential.scripts:src-models-residential-scripts}}\label{\detokenize{src.models.residential.scripts::doc}}\index{module@\spxentry{module}!src.models.residential.scripts@\spxentry{src.models.residential.scripts}}\index{src.models.residential.scripts@\spxentry{src.models.residential.scripts}!module@\spxentry{module}}\subsubsection*{Modules}


\begin{savenotes}
\sphinxatlongtablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\makeatletter
  \LTleft \@totalleftmargin plus1fill
  \LTright\dimexpr\columnwidth-\@totalleftmargin-\linewidth\relax plus1fill
\makeatother
\begin{longtable}{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\endfirsthead

\multicolumn{2}{c}{\sphinxnorowcolor
    \makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}%
}\\
\sphinxtoprule
\endhead

\sphinxbottomrule
\multicolumn{2}{r}{\sphinxnorowcolor
    \makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}%
}\\
\endfoot

\endlastfoot
\sphinxtableatstartofbodyhook

\sphinxAtStartPar
{\hyperref[\detokenize{src.models.residential.scripts.residential:module-src.models.residential.scripts.residential}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{residential}}}}}
&
\sphinxAtStartPar
Residential Model.
\\
\sphinxbottomrule
\end{longtable}
\sphinxtableafterendhook
\sphinxatlongtableend
\end{savenotes}

\sphinxstepscope


\subparagraph{src.models.residential.scripts.residential}
\label{\detokenize{src.models.residential.scripts.residential:module-src.models.residential.scripts.residential}}\label{\detokenize{src.models.residential.scripts.residential:src-models-residential-scripts-residential}}\label{\detokenize{src.models.residential.scripts.residential::doc}}\index{module@\spxentry{module}!src.models.residential.scripts.residential@\spxentry{src.models.residential.scripts.residential}}\index{src.models.residential.scripts.residential@\spxentry{src.models.residential.scripts.residential}!module@\spxentry{module}}
\sphinxAtStartPar
Residential Model.
This file contains the residentialModule class which contains a representation of residential
electricity prices and demands.
\subsubsection*{Functions}


\begin{savenotes}
\sphinxatlongtablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\makeatletter
  \LTleft \@totalleftmargin plus1fill
  \LTright\dimexpr\columnwidth-\@totalleftmargin-\linewidth\relax plus1fill
\makeatother
\begin{longtable}{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\endfirsthead

\multicolumn{2}{c}{\sphinxnorowcolor
    \makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}%
}\\
\sphinxtoprule
\endhead

\sphinxbottomrule
\multicolumn{2}{r}{\sphinxnorowcolor
    \makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}%
}\\
\endfoot

\endlastfoot
\sphinxtableatstartofbodyhook

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{getLogger}}({[}name{]})
&
\sphinxAtStartPar
Return a logger with the specified name, creating it if necessary.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.models.residential.scripts.residential:src.models.residential.scripts.residential.run_residential}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{run\_residential}}}}}(settings)
&
\sphinxAtStartPar
This runs the residential model in stand\sphinxhyphen{}alone mode.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{scale\_load}}(data\_root)
&
\sphinxAtStartPar
Reads in BaseLoad.csv (load for all regions/hours for first year) and LoadScalar.csv (a multiplier for all model years).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{scale\_load\_with\_enduses}}(data\_root)
&
\sphinxAtStartPar
Reads in BaseLoad.csv (load for all regions/hours for first year), EnduseBaseShares.csv (the shares of demand for each enduse in the base year) and EnduseScalar.csv (a multiplier for all model years by enduse category).
\\
\sphinxbottomrule
\end{longtable}
\sphinxtableafterendhook
\sphinxatlongtableend
\end{savenotes}
\subsubsection*{Classes}


\begin{savenotes}
\sphinxatlongtablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\makeatletter
  \LTleft \@totalleftmargin plus1fill
  \LTright\dimexpr\columnwidth-\@totalleftmargin-\linewidth\relax plus1fill
\makeatother
\begin{longtable}{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\endfirsthead

\multicolumn{2}{c}{\sphinxnorowcolor
    \makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}%
}\\
\sphinxtoprule
\endhead

\sphinxbottomrule
\multicolumn{2}{r}{\sphinxnorowcolor
    \makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}%
}\\
\endfoot

\endlastfoot
\sphinxtableatstartofbodyhook

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Config\_settings}}(config\_path{[}, args, test{]})
&
\sphinxAtStartPar
Generates the model settings that are used to solve.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Path}}(*args, **kwargs)
&
\sphinxAtStartPar
PurePath subclass that can make system calls.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.models.residential.scripts.residential:src.models.residential.scripts.residential.residentialModule}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{residentialModule}}}}}({[}settings, loadFile, ...{]})
&
\sphinxAtStartPar
This contains the Residential model and its associated functions.
\\
\sphinxbottomrule
\end{longtable}
\sphinxtableafterendhook
\sphinxatlongtableend
\end{savenotes}
\index{residentialModule (class in src.models.residential.scripts.residential)@\spxentry{residentialModule}\spxextra{class in src.models.residential.scripts.residential}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.residential.scripts.residential:src.models.residential.scripts.residential.residentialModule}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{\DUrole{k}{class}\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{src.models.residential.scripts.residential.}}\sphinxbfcode{\sphinxupquote{residentialModule}}}
{\sphinxparam{\DUrole{n}{settings}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{{\hyperref[\detokenize{src.common.config_setup:src.common.config_setup.Config_settings}]{\sphinxcrossref{Config\_settings}}}\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }None}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{loadFile}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{str\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }None}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{load\_df}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{DataFrame\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }None}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{calibrate}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{bool\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }None}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{False}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
This contains the Residential model and its associated functions. Once an object is
instantiated, it can calculate new Load values for updated prices. It can also calculate
estimated changes to the Load if one of the input variables is changed by a specified percent.
The model will be created in a symbolic form to be easily manipulated, and then values can be
filled in for calculations.
\index{baseYear (src.models.residential.scripts.residential.residentialModule attribute)@\spxentry{baseYear}\spxextra{src.models.residential.scripts.residential.residentialModule attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.residential.scripts.residential:src.models.residential.scripts.residential.residentialModule.baseYear}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{baseYear}}\sphinxbfcode{\sphinxupquote{\DUrole{w}{ }\DUrole{p}{=}\DUrole{w}{ }0}}}
\pysigstopsignatures
\end{fulllineitems}

\index{complex\_step\_sensitivity() (src.models.residential.scripts.residential.residentialModule method)@\spxentry{complex\_step\_sensitivity()}\spxextra{src.models.residential.scripts.residential.residentialModule method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.residential.scripts.residential:src.models.residential.scripts.residential.residentialModule.complex_step_sensitivity}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{complex\_step\_sensitivity}}}
{\sphinxparam{\DUrole{n}{prices}}\sphinxparamcomma \sphinxparam{\DUrole{n}{change\_var}}\sphinxparamcomma \sphinxparam{\DUrole{n}{percent}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
This estimates how much the output Load will change due to a change in one of the input
variables. It can calculate these values for changes in price, price elasticity, income,
income elasticity, or long term trend. The Load calculation requires input prices, so this
function requires that as well for the base output Load. Then, an estimate for Load is
calculated for the case where the named ‘change\_var’ is changed by ‘percent’ \%.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{prices}} (\sphinxstyleliteralemphasis{\sphinxupquote{dataframe}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{Pyomo Indexed Parameter}}) \textendash{} Price values used to calculate the Load value

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{change\_var}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} \begin{description}
\sphinxlineitem{Name of variable of interest for sensitivity. This can be:}
\sphinxAtStartPar
’income’, ‘i\_elas’, ‘price’, ‘p\_elas’, ‘trendGR’

\end{description}


\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{percent}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} A value 0 \sphinxhyphen{} 100 for the percent that the variable of interest can change.

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
Indexed values for the calculated Load at the given prices, the Load if the variable
of interest is increased by ‘percent’\%, and the Load if the variable of interest is
decreased by ‘percent’\%

\sphinxlineitem{Return type}
\sphinxAtStartPar
dataframe

\end{description}\end{quote}

\end{fulllineitems}

\index{demandF() (src.models.residential.scripts.residential.residentialModule method)@\spxentry{demandF()}\spxextra{src.models.residential.scripts.residential.residentialModule method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.residential.scripts.residential:src.models.residential.scripts.residential.residentialModule.demandF}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{demandF}}}
{\sphinxparam{\DUrole{n}{price}}\sphinxparamcomma \sphinxparam{\DUrole{n}{load}}\sphinxparamcomma \sphinxparam{\DUrole{n}{year}}\sphinxparamcomma \sphinxparam{\DUrole{n}{basePrice}\DUrole{o}{=}\DUrole{default_value}{1}}\sphinxparamcomma \sphinxparam{\DUrole{n}{p\_elas}\DUrole{o}{=}\DUrole{default_value}{\sphinxhyphen{}0.1}}\sphinxparamcomma \sphinxparam{\DUrole{n}{baseYear}\DUrole{o}{=}\DUrole{default_value}{None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{baseIncome}\DUrole{o}{=}\DUrole{default_value}{1}}\sphinxparamcomma \sphinxparam{\DUrole{n}{income}\DUrole{o}{=}\DUrole{default_value}{1}}\sphinxparamcomma \sphinxparam{\DUrole{n}{i\_elas}\DUrole{o}{=}\DUrole{default_value}{1}}\sphinxparamcomma \sphinxparam{\DUrole{n}{trend}\DUrole{o}{=}\DUrole{default_value}{0}}\sphinxparamcomma \sphinxparam{\DUrole{n}{priceIndex}\DUrole{o}{=}\DUrole{default_value}{1}}\sphinxparamcomma \sphinxparam{\DUrole{n}{incomeIndex}\DUrole{o}{=}\DUrole{default_value}{1}}\sphinxparamcomma \sphinxparam{\DUrole{n}{p\_lag}\DUrole{o}{=}\DUrole{default_value}{1}}\sphinxparamcomma \sphinxparam{\DUrole{n}{i\_lag}\DUrole{o}{=}\DUrole{default_value}{1}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
The demand function.  Wraps the sympy demand function with some defaults
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{price}} (\sphinxstyleliteralemphasis{\sphinxupquote{\_type\_}}) \textendash{} \_description\_

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{load}} (\sphinxstyleliteralemphasis{\sphinxupquote{\_type\_}}) \textendash{} \_description\_

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{year}} (\sphinxstyleliteralemphasis{\sphinxupquote{\_type\_}}) \textendash{} \_description\_

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{basePrice}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} \_description\_, by default 1

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{p\_elas}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} \_description\_, by default \sphinxhyphen{}0.10

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{baseYear}} (\sphinxstyleliteralemphasis{\sphinxupquote{\_type\_}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} \_description\_, by default None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{baseIncome}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} \_description\_, by default 1

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{income}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} \_description\_, by default 1

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{i\_elas}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} \_description\_, by default 1

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{trend}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} \_description\_, by default 0

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{priceIndex}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} \_description\_, by default 1

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{incomeIndex}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} \_description\_, by default 1

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{p\_lag}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} \_description\_, by default 1

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{i\_lag}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} \_description\_, by default 1

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\_description\_

\sphinxlineitem{Return type}
\sphinxAtStartPar
\_type\_

\end{description}\end{quote}

\end{fulllineitems}

\index{hr\_map (src.models.residential.scripts.residential.residentialModule attribute)@\spxentry{hr\_map}\spxextra{src.models.residential.scripts.residential.residentialModule attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.residential.scripts.residential:src.models.residential.scripts.residential.residentialModule.hr_map}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{hr\_map}}\sphinxbfcode{\sphinxupquote{\DUrole{w}{ }\DUrole{p}{=}\DUrole{w}{ }Empty DataFrame Columns: {[}{]} Index: {[}{]}}}}
\pysigstopsignatures
\end{fulllineitems}

\index{loads (src.models.residential.scripts.residential.residentialModule attribute)@\spxentry{loads}\spxextra{src.models.residential.scripts.residential.residentialModule attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.residential.scripts.residential:src.models.residential.scripts.residential.residentialModule.loads}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{loads}}\sphinxbfcode{\sphinxupquote{\DUrole{w}{ }\DUrole{p}{=}\DUrole{w}{ }\{\}}}}
\pysigstopsignatures
\end{fulllineitems}

\index{make\_block() (src.models.residential.scripts.residential.residentialModule method)@\spxentry{make\_block()}\spxextra{src.models.residential.scripts.residential.residentialModule method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.residential.scripts.residential:src.models.residential.scripts.residential.residentialModule.make_block}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{make\_block}}}
{\sphinxparam{\DUrole{n}{prices}}\sphinxparamcomma \sphinxparam{\DUrole{n}{pricesindex}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Updates the value of ‘Load’ based on the new prices given.
The new prices are fed into the equations from the residential model.
The new calculated Loads are used to constrain ‘Load’ in pyomo blocks.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{prices}} (\sphinxstyleliteralemphasis{\sphinxupquote{pyo.Param}}) \textendash{} Pyomo Parameter of newly updated prices

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{pricesindex}} (\sphinxstyleliteralemphasis{\sphinxupquote{pyo.Set}}) \textendash{} Pyomo Set of indexes that matches the prices given

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
Block containing constraints that set ‘Load’ variable equal to the updated load values

\sphinxlineitem{Return type}
\sphinxAtStartPar
pyo.Block

\end{description}\end{quote}

\end{fulllineitems}

\index{prices (src.models.residential.scripts.residential.residentialModule attribute)@\spxentry{prices}\spxextra{src.models.residential.scripts.residential.residentialModule attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.residential.scripts.residential:src.models.residential.scripts.residential.residentialModule.prices}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{prices}}\sphinxbfcode{\sphinxupquote{\DUrole{w}{ }\DUrole{p}{=}\DUrole{w}{ }\{\}}}}
\pysigstopsignatures
\end{fulllineitems}

\index{sensitivity() (src.models.residential.scripts.residential.residentialModule method)@\spxentry{sensitivity()}\spxextra{src.models.residential.scripts.residential.residentialModule method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.residential.scripts.residential:src.models.residential.scripts.residential.residentialModule.sensitivity}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{sensitivity}}}
{\sphinxparam{\DUrole{n}{prices}}\sphinxparamcomma \sphinxparam{\DUrole{n}{change\_var}}\sphinxparamcomma \sphinxparam{\DUrole{n}{percent}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
This estimates how much the output Load will change due to a change in one of the input
variables. It can calculate these values for changes in price, price elasticity, income,
income elasticity, or long term trend. The Load calculation requires input prices, so this
function requires that as well for the base output Load. Then, an estimate for Load is
calculated for the case where the named ‘change\_var’ is changed by ‘percent’ \%.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{prices}} (\sphinxstyleliteralemphasis{\sphinxupquote{dataframe}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{Pyomo Indexed Parameter}}) \textendash{} Price values used to calculate the Load value

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{change\_var}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} \begin{description}
\sphinxlineitem{Name of variable of interest for sensitivity. This can be:}
\sphinxAtStartPar
’income’, ‘i\_elas’, ‘price’, ‘p\_elas’, ‘trendGR’

\end{description}


\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{percent}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} A value 0 \sphinxhyphen{} 100 for the percent that the variable of interest can change.

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
Indexed values for the calculated Load at the given prices, the Load if the variable of
interest is increased by ‘percent’\%, and the Load if the variable of interest is
decreased by ‘percent’\%

\sphinxlineitem{Return type}
\sphinxAtStartPar
dataframe

\end{description}\end{quote}

\end{fulllineitems}

\index{update\_load() (src.models.residential.scripts.residential.residentialModule method)@\spxentry{update\_load()}\spxextra{src.models.residential.scripts.residential.residentialModule method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.residential.scripts.residential:src.models.residential.scripts.residential.residentialModule.update_load}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{update\_load}}}
{\sphinxparam{\DUrole{n}{p}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Takes in Dual pyomo Parameters or dataframes to update Load values
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{p}} (\sphinxstyleliteralemphasis{\sphinxupquote{pyo.Param}}) \textendash{} Pyomo Parameter or dataframe of newly updated prices from Duals

\sphinxlineitem{Returns}
\sphinxAtStartPar
Load values indexed by region, year, and hour

\sphinxlineitem{Return type}
\sphinxAtStartPar
pandas DataFrame

\end{description}\end{quote}

\end{fulllineitems}

\index{view\_output\_load() (src.models.residential.scripts.residential.residentialModule method)@\spxentry{view\_output\_load()}\spxextra{src.models.residential.scripts.residential.residentialModule method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.residential.scripts.residential:src.models.residential.scripts.residential.residentialModule.view_output_load}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{view\_output\_load}}}
{\sphinxparam{\DUrole{n}{values}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{DataFrame}}\sphinxparamcomma \sphinxparam{\DUrole{n}{regions}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{list\DUrole{p}{{[}}int\DUrole{p}{{]}}}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{{[}1{]}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{years}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{list\DUrole{p}{{[}}int\DUrole{p}{{]}}}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{{[}2023{]}}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
This is used to display the updated Load values after calculation. It will create a
graph for each region and year combination.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{values}} (\sphinxstyleliteralemphasis{\sphinxupquote{pd.DataFrame}}) \textendash{} The Load values calculated in update\_load

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{regions}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} The regions to be displayed

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{years}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} The years to be displayed

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{view\_sensitivity() (src.models.residential.scripts.residential.residentialModule method)@\spxentry{view\_sensitivity()}\spxextra{src.models.residential.scripts.residential.residentialModule method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.residential.scripts.residential:src.models.residential.scripts.residential.residentialModule.view_sensitivity}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{view\_sensitivity}}}
{\sphinxparam{\DUrole{n}{values}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{DataFrame}}\sphinxparamcomma \sphinxparam{\DUrole{n}{regions}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{list\DUrole{p}{{[}}int\DUrole{p}{{]}}}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{{[}1{]}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{years}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{list\DUrole{p}{{[}}int\DUrole{p}{{]}}}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{{[}2023{]}}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
This is used by the sensitivity method to display graphs of the calculated values
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{values}} (\sphinxstyleliteralemphasis{\sphinxupquote{pd.DataFrame}}) \textendash{} indexed values for the Load, upper change, and lower change

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{regions}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} regions to be graphed

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{years}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} years to be graphed

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{run\_residential() (in module src.models.residential.scripts.residential)@\spxentry{run\_residential()}\spxextra{in module src.models.residential.scripts.residential}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.models.residential.scripts.residential:src.models.residential.scripts.residential.run_residential}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{src.models.residential.scripts.residential.}}\sphinxbfcode{\sphinxupquote{run\_residential}}}
{\sphinxparam{\DUrole{n}{settings}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{{\hyperref[\detokenize{src.common.config_setup:src.common.config_setup.Config_settings}]{\sphinxcrossref{Config\_settings}}}}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
This runs the residential model in stand\sphinxhyphen{}alone mode. It can run update\_load to calculate new
Load values based on prices, or it can calculate the new Load value along with estimates for
the Load if one of the input variables changes.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{settings}} ({\hyperref[\detokenize{src.common.config_setup:src.common.config_setup.Config_settings}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Config\_settings}}}}}) \textendash{} information given from run\_config to set several values

\end{description}\end{quote}

\end{fulllineitems}


\sphinxstepscope


\subsection{src}
\label{\detokenize{src:module-src}}\label{\detokenize{src:src}}\label{\detokenize{src::doc}}\index{module@\spxentry{module}!src@\spxentry{src}}\index{src@\spxentry{src}!module@\spxentry{module}}
\sphinxAtStartPar
This directory contains the subdirectory for the integrator module and the subdirectories for the sectoral modules. The integrator module contains code for the different solve methods (standalone, iterative, or unified). The sectoral modules currently represented in this prototype include the electricity model, hydrogen model, and residential model. For more details on each of these, please see the READMEs located within each subdirectory.
\subsubsection*{Modules}


\begin{savenotes}
\sphinxatlongtablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\makeatletter
  \LTleft \@totalleftmargin plus1fill
  \LTright\dimexpr\columnwidth-\@totalleftmargin-\linewidth\relax plus1fill
\makeatother
\begin{longtable}{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\endfirsthead

\multicolumn{2}{c}{\sphinxnorowcolor
    \makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}%
}\\
\sphinxtoprule
\endhead

\sphinxbottomrule
\multicolumn{2}{r}{\sphinxnorowcolor
    \makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}%
}\\
\endfoot

\endlastfoot
\sphinxtableatstartofbodyhook

\sphinxAtStartPar
{\hyperref[\detokenize{src.common:module-src.common}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{common}}}}}
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.integrator:module-src.integrator}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{integrator}}}}}
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.models:module-src.models}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{models}}}}}
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.sensitivity:module-src.sensitivity}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{sensitivity}}}}}
&
\sphinxAtStartPar

\\
\sphinxbottomrule
\end{longtable}
\sphinxtableafterendhook
\sphinxatlongtableend
\end{savenotes}

\sphinxstepscope


\subsubsection{src.common}
\label{\detokenize{src.common:module-src.common}}\label{\detokenize{src.common:src-common}}\label{\detokenize{src.common::doc}}\index{module@\spxentry{module}!src.common@\spxentry{src.common}}\index{src.common@\spxentry{src.common}!module@\spxentry{module}}\subsubsection*{Modules}


\begin{savenotes}
\sphinxatlongtablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\makeatletter
  \LTleft \@totalleftmargin plus1fill
  \LTright\dimexpr\columnwidth-\@totalleftmargin-\linewidth\relax plus1fill
\makeatother
\begin{longtable}{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\endfirsthead

\multicolumn{2}{c}{\sphinxnorowcolor
    \makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}%
}\\
\sphinxtoprule
\endhead

\sphinxbottomrule
\multicolumn{2}{r}{\sphinxnorowcolor
    \makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}%
}\\
\endfoot

\endlastfoot
\sphinxtableatstartofbodyhook

\sphinxAtStartPar
{\hyperref[\detokenize{src.common.config_setup:module-src.common.config_setup}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{config\_setup}}}}}
&
\sphinxAtStartPar
This file contains Config\_settings class.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.common.model:module-src.common.model}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{model}}}}}
&
\sphinxAtStartPar
Establish a base model class for the sectoral modules to inherit.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.common.utilities:module-src.common.utilities}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{utilities}}}}}
&
\sphinxAtStartPar
A gathering of utility functions for dealing with model interconnectivity
\\
\sphinxbottomrule
\end{longtable}
\sphinxtableafterendhook
\sphinxatlongtableend
\end{savenotes}

\sphinxstepscope


\paragraph{src.common.config\_setup}
\label{\detokenize{src.common.config_setup:module-src.common.config_setup}}\label{\detokenize{src.common.config_setup:src-common-config-setup}}\label{\detokenize{src.common.config_setup::doc}}\index{module@\spxentry{module}!src.common.config\_setup@\spxentry{src.common.config\_setup}}\index{src.common.config\_setup@\spxentry{src.common.config\_setup}!module@\spxentry{module}}
\sphinxAtStartPar
This file contains Config\_settings class. It establishes the main settings used when running
the model. It takes these settings from the run\_config.toml file. It has universal configurations
(e.g., configs that cut across modules and/or solve options) and module specific configs.
\subsubsection*{Functions}


\begin{savenotes}
\sphinxatlongtablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\makeatletter
  \LTleft \@totalleftmargin plus1fill
  \LTright\dimexpr\columnwidth-\@totalleftmargin-\linewidth\relax plus1fill
\makeatother
\begin{longtable}{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\endfirsthead

\multicolumn{2}{c}{\sphinxnorowcolor
    \makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}%
}\\
\sphinxtoprule
\endhead

\sphinxbottomrule
\multicolumn{2}{r}{\sphinxnorowcolor
    \makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}%
}\\
\endfoot

\endlastfoot
\sphinxtableatstartofbodyhook

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{create\_temporal\_mapping}}(sw\_temporal)
&
\sphinxAtStartPar
Combines the input mapping files within the electricity model to create a master temporal mapping dataframe.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{make\_dir}}(dir\_name)
&
\sphinxAtStartPar
generates an output directory to write model results, output directory is the date/time at the time this function executes.
\\
\sphinxbottomrule
\end{longtable}
\sphinxtableafterendhook
\sphinxatlongtableend
\end{savenotes}
\subsubsection*{Classes}


\begin{savenotes}
\sphinxatlongtablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\makeatletter
  \LTleft \@totalleftmargin plus1fill
  \LTright\dimexpr\columnwidth-\@totalleftmargin-\linewidth\relax plus1fill
\makeatother
\begin{longtable}{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\endfirsthead

\multicolumn{2}{c}{\sphinxnorowcolor
    \makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}%
}\\
\sphinxtoprule
\endhead

\sphinxbottomrule
\multicolumn{2}{r}{\sphinxnorowcolor
    \makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}%
}\\
\endfoot

\endlastfoot
\sphinxtableatstartofbodyhook

\sphinxAtStartPar
{\hyperref[\detokenize{src.common.config_setup:src.common.config_setup.Config_settings}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Config\_settings}}}}}(config\_path{[}, args, test{]})
&
\sphinxAtStartPar
Generates the model settings that are used to solve.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Path}}(*args, **kwargs)
&
\sphinxAtStartPar
PurePath subclass that can make system calls.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{datetime}}(year, month, day{[}, hour{[}, minute{[}, ...)
&
\sphinxAtStartPar
The year, month and day arguments are required.
\\
\sphinxbottomrule
\end{longtable}
\sphinxtableafterendhook
\sphinxatlongtableend
\end{savenotes}
\index{Config\_settings (class in src.common.config\_setup)@\spxentry{Config\_settings}\spxextra{class in src.common.config\_setup}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.common.config_setup:src.common.config_setup.Config_settings}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{\DUrole{k}{class}\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{src.common.config\_setup.}}\sphinxbfcode{\sphinxupquote{Config\_settings}}}
{\sphinxparam{\DUrole{n}{config\_path}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{Path}}\sphinxparamcomma \sphinxparam{\DUrole{n}{args}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{Namespace\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }None}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{test}\DUrole{o}{=}\DUrole{default_value}{False}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Generates the model settings that are used to solve. Settings include:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Iterative Solve Config Settings

\item {} 
\sphinxAtStartPar
Spatial Config Settings

\item {} 
\sphinxAtStartPar
Temporal Config Settings

\item {} 
\sphinxAtStartPar
Electricity Config Settings

\item {} 
\sphinxAtStartPar
Other

\end{itemize}
\index{\_additional\_year\_settings() (src.common.config\_setup.Config\_settings method)@\spxentry{\_additional\_year\_settings()}\spxextra{src.common.config\_setup.Config\_settings method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.common.config_setup:src.common.config_setup.Config_settings._additional_year_settings}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{\_additional\_year\_settings}}}
{\sphinxparam{\DUrole{n}{name}}\sphinxparamcomma \sphinxparam{\DUrole{n}{value}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Checks year related settings to see if values are within expected ranges and updates
other settings linked to years if years is changed.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{name}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} attribute name

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{value}} (\sphinxstyleliteralemphasis{\sphinxupquote{\_type\_}}) \textendash{} attribute value

\end{itemize}

\sphinxlineitem{Raises}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} Error

\end{description}\end{quote}

\end{fulllineitems}

\index{\_check\_elec\_expansion\_settings() (src.common.config\_setup.Config\_settings method)@\spxentry{\_check\_elec\_expansion\_settings()}\spxextra{src.common.config\_setup.Config\_settings method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.common.config_setup:src.common.config_setup.Config_settings._check_elec_expansion_settings}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{\_check\_elec\_expansion\_settings}}}
{\sphinxparam{\DUrole{n}{name}}\sphinxparamcomma \sphinxparam{\DUrole{n}{value}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Checks that switches for reserve margin and learning are on only if expansion is on.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{name}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} attribute name

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{value}} (\sphinxstyleliteralemphasis{\sphinxupquote{\_type\_}}) \textendash{} attribute value

\end{itemize}

\sphinxlineitem{Raises}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} Error

\end{description}\end{quote}

\end{fulllineitems}

\index{\_check\_int() (src.common.config\_setup.Config\_settings method)@\spxentry{\_check\_int()}\spxextra{src.common.config\_setup.Config\_settings method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.common.config_setup:src.common.config_setup.Config_settings._check_int}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{\_check\_int}}}
{\sphinxparam{\DUrole{n}{name}}\sphinxparamcomma \sphinxparam{\DUrole{n}{value}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Checks if attribute is an integer
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{name}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} attribute name

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{value}} (\sphinxstyleliteralemphasis{\sphinxupquote{\_type\_}}) \textendash{} attribute value

\end{itemize}

\sphinxlineitem{Raises}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} Error

\end{description}\end{quote}

\end{fulllineitems}

\index{\_check\_regions() (src.common.config\_setup.Config\_settings method)@\spxentry{\_check\_regions()}\spxextra{src.common.config\_setup.Config\_settings method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.common.config_setup:src.common.config_setup.Config_settings._check_regions}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{\_check\_regions}}}
{\sphinxparam{\DUrole{n}{name}}\sphinxparamcomma \sphinxparam{\DUrole{n}{value}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Checks to see if region is between the current default values of 1 and 25.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{name}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} attribute name

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{value}} (\sphinxstyleliteralemphasis{\sphinxupquote{\_type\_}}) \textendash{} attribute value

\end{itemize}

\sphinxlineitem{Raises}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} Error

\end{description}\end{quote}

\end{fulllineitems}

\index{\_check\_res\_settings() (src.common.config\_setup.Config\_settings method)@\spxentry{\_check\_res\_settings()}\spxextra{src.common.config\_setup.Config\_settings method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.common.config_setup:src.common.config_setup.Config_settings._check_res_settings}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{\_check\_res\_settings}}}
{\sphinxparam{\DUrole{n}{name}}\sphinxparamcomma \sphinxparam{\DUrole{n}{value}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Checks if view year or region settings are subsets of year or region
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{name}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} attribute name

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{value}} (\sphinxstyleliteralemphasis{\sphinxupquote{\_type\_}}) \textendash{} attribute value

\end{itemize}

\sphinxlineitem{Raises}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} Error

\end{description}\end{quote}

\end{fulllineitems}

\index{\_check\_true\_false() (src.common.config\_setup.Config\_settings method)@\spxentry{\_check\_true\_false()}\spxextra{src.common.config\_setup.Config\_settings method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.common.config_setup:src.common.config_setup.Config_settings._check_true_false}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{\_check\_true\_false}}}
{\sphinxparam{\DUrole{n}{name}}\sphinxparamcomma \sphinxparam{\DUrole{n}{value}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Checks if attribute is either true or false
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{name}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} attribute name

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{value}} (\sphinxstyleliteralemphasis{\sphinxupquote{\_type\_}}) \textendash{} attribute value

\end{itemize}

\sphinxlineitem{Raises}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} Error

\end{description}\end{quote}

\end{fulllineitems}

\index{\_check\_zero\_one() (src.common.config\_setup.Config\_settings method)@\spxentry{\_check\_zero\_one()}\spxextra{src.common.config\_setup.Config\_settings method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.common.config_setup:src.common.config_setup.Config_settings._check_zero_one}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{\_check\_zero\_one}}}
{\sphinxparam{\DUrole{n}{name}}\sphinxparamcomma \sphinxparam{\DUrole{n}{value}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Checks if attribute is either zero or one
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{name}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} attribute name

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{value}} (\sphinxstyleliteralemphasis{\sphinxupquote{\_type\_}}) \textendash{} attribute value

\end{itemize}

\sphinxlineitem{Raises}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} Error

\end{description}\end{quote}

\end{fulllineitems}

\index{\_has\_all\_attributes() (src.common.config\_setup.Config\_settings method)@\spxentry{\_has\_all\_attributes()}\spxextra{src.common.config\_setup.Config\_settings method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.common.config_setup:src.common.config_setup.Config_settings._has_all_attributes}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{\_has\_all\_attributes}}}
{\sphinxparam{\DUrole{n}{attrs}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{set}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Determines if all attributes within the set exist or not
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{attrs}} (\sphinxstyleliteralemphasis{\sphinxupquote{set}}) \textendash{} set of setting attributes

\sphinxlineitem{Returns}
\sphinxAtStartPar
True or False

\sphinxlineitem{Return type}
\sphinxAtStartPar
bool

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}


\sphinxstepscope


\paragraph{src.common.model}
\label{\detokenize{src.common.model:module-src.common.model}}\label{\detokenize{src.common.model:src-common-model}}\label{\detokenize{src.common.model::doc}}\index{module@\spxentry{module}!src.common.model@\spxentry{src.common.model}}\index{src.common.model@\spxentry{src.common.model}!module@\spxentry{module}}
\sphinxAtStartPar
Establish a base model class for the sectoral modules to inherit.
\subsubsection*{Functions}


\begin{savenotes}
\sphinxatlongtablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\makeatletter
  \LTleft \@totalleftmargin plus1fill
  \LTright\dimexpr\columnwidth-\@totalleftmargin-\linewidth\relax plus1fill
\makeatother
\begin{longtable}{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\endfirsthead

\multicolumn{2}{c}{\sphinxnorowcolor
    \makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}%
}\\
\sphinxtoprule
\endhead

\sphinxbottomrule
\multicolumn{2}{r}{\sphinxnorowcolor
    \makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}%
}\\
\endfoot

\endlastfoot
\sphinxtableatstartofbodyhook

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{getLogger}}({[}name{]})
&
\sphinxAtStartPar
Return a logger with the specified name, creating it if necessary.
\\
\sphinxbottomrule
\end{longtable}
\sphinxtableafterendhook
\sphinxatlongtableend
\end{savenotes}
\subsubsection*{Classes}


\begin{savenotes}
\sphinxatlongtablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\makeatletter
  \LTleft \@totalleftmargin plus1fill
  \LTright\dimexpr\columnwidth-\@totalleftmargin-\linewidth\relax plus1fill
\makeatother
\begin{longtable}{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\endfirsthead

\multicolumn{2}{c}{\sphinxnorowcolor
    \makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}%
}\\
\sphinxtoprule
\endhead

\sphinxbottomrule
\multicolumn{2}{r}{\sphinxnorowcolor
    \makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}%
}\\
\endfoot

\endlastfoot
\sphinxtableatstartofbodyhook

\sphinxAtStartPar
{\hyperref[\detokenize{src.common.model:src.common.model.Model}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Model}}}}}(*args, **kwds)
&
\sphinxAtStartPar
This is the base model class for the models.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{defaultdict}}
&
\sphinxAtStartPar
defaultdict(default\_factory=None, /, {[}...{]}) \sphinxhyphen{}\sphinxhyphen{}\textgreater{} dict with default factory
\\
\sphinxbottomrule
\end{longtable}
\sphinxtableafterendhook
\sphinxatlongtableend
\end{savenotes}
\index{Model (class in src.common.model)@\spxentry{Model}\spxextra{class in src.common.model}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.common.model:src.common.model.Model}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{\DUrole{k}{class}\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{src.common.model.}}\sphinxbfcode{\sphinxupquote{Model}}}
{\sphinxparam{\DUrole{o}{*}\DUrole{n}{args}}\sphinxparamcomma \sphinxparam{\DUrole{o}{**}\DUrole{n}{kwds}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
This is the base model class for the models.

\sphinxAtStartPar
This class contains methods for declaring pyomo components, extracting duals, and
decorating expressions. The model class methods and attributes provide functionality
for keeping track of index labels and ordering for all pyomo components; this is
essential for integration tasks without the use of hard\sphinxhyphen{}coded indices and allows for
easy post\sphinxhyphen{}processing tasks.
\index{Model.ConstraintExpression (class in src.common.model)@\spxentry{Model.ConstraintExpression}\spxextra{class in src.common.model}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.common.model:src.common.model.Model.ConstraintExpression}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{\DUrole{k}{class}\DUrole{w}{ }}}\sphinxbfcode{\sphinxupquote{ConstraintExpression}}}
{\sphinxparam{\DUrole{o}{*}\DUrole{n}{args}}\sphinxparamcomma \sphinxparam{\DUrole{o}{**}\DUrole{n}{kwargs}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Constraint Expression decorator that works the same as pyomo decorators, while keeping
column dictionary updated for any indexed parameters given.

\end{fulllineitems}

\index{Model.DefaultDecorator (class in src.common.model)@\spxentry{Model.DefaultDecorator}\spxextra{class in src.common.model}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.common.model:src.common.model.Model.DefaultDecorator}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{\DUrole{k}{class}\DUrole{w}{ }}}\sphinxbfcode{\sphinxupquote{DefaultDecorator}}}
{\sphinxparam{\DUrole{n}{model}}\sphinxparamcomma \sphinxparam{\DUrole{o}{*}\DUrole{n}{args}}\sphinxparamcomma \sphinxparam{\DUrole{o}{**}\DUrole{n}{kwargs}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Default decorator class that handles assignment of model scope/pointer in order to use
pyomo\sphinxhyphen{}style parameter and constraint decorators.

\sphinxAtStartPar
Upon initialization, the decorator handles model assignment at class level to ensure
inheriting classes have access to the models within local scope.
\index{assign\_model() (src.common.model.Model.DefaultDecorator class method)@\spxentry{assign\_model()}\spxextra{src.common.model.Model.DefaultDecorator class method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.common.model:src.common.model.Model.DefaultDecorator.assign_model}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{\DUrole{k}{classmethod}\DUrole{w}{ }}}\sphinxbfcode{\sphinxupquote{assign\_model}}}
{\sphinxparam{\DUrole{n}{model}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Class\sphinxhyphen{}method that assigns a model instance to DefaultDecorator
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{model}} (\sphinxstyleliteralemphasis{\sphinxupquote{pyo.ConcreteModel}}) \textendash{} A pyo model instance

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{Model.ParameterExpression (class in src.common.model)@\spxentry{Model.ParameterExpression}\spxextra{class in src.common.model}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.common.model:src.common.model.Model.ParameterExpression}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{\DUrole{k}{class}\DUrole{w}{ }}}\sphinxbfcode{\sphinxupquote{ParameterExpression}}}
{\sphinxparam{\DUrole{o}{*}\DUrole{n}{args}}\sphinxparamcomma \sphinxparam{\DUrole{o}{**}\DUrole{n}{kwargs}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Parameter Expression decorator that works the same as pyomo decorators, while keeping
column dictionary updated for any indexed parameters given.

\end{fulllineitems}

\index{\_active (src.common.model.Model attribute)@\spxentry{\_active}\spxextra{src.common.model.Model attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.common.model:src.common.model.Model._active}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{\_active}}}
\pysigstopsignatures
\end{fulllineitems}

\index{\_declare\_set\_with\_dict() (src.common.model.Model method)@\spxentry{\_declare\_set\_with\_dict()}\spxextra{src.common.model.Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.common.model:src.common.model.Model._declare_set_with_dict}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{\_declare\_set\_with\_dict}}}
{\sphinxparam{\DUrole{n}{sname}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{str}}\sphinxparamcomma \sphinxparam{\DUrole{n}{sdata}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{Dict\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }DefaultDict}}\sphinxparamcomma \sphinxparam{\DUrole{n}{scols}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{MutableSequence}}\sphinxparamcomma \sphinxparam{\DUrole{n}{return\_set}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{bool\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }None}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{False}}\sphinxparamcomma \sphinxparam{\DUrole{n}{switch}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{bool\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }None}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{True}}\sphinxparamcomma \sphinxparam{\DUrole{n}{create\_indexed\_set}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{bool\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }None}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{True}}\sphinxparamcomma \sphinxparam{\DUrole{n}{use\_values}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{bool\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }None}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{False}}}
{{ $\rightarrow$ Set}}
\pysigstopsignatures
\sphinxAtStartPar
Declares a pyomo Set object named ‘sname’ using input index values and labels.

\sphinxAtStartPar
Function takes a dictionary argument and creates pyomo set object from keys, values, or both.

\sphinxAtStartPar
If an indexed set is desired, set create\_indexed\_set to True; the function will create an
indexed set with its own indices set as keys. Otherwise, an Ordered Scalar Set will be
created, either from the keys or the values of ‘sdata’ depending on the value for
‘use\_values’ (False for keys, True for values).

\sphinxAtStartPar
Names for the indices handled by scols; user must provide.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{sname}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Name of set

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{sdata}} (\sphinxstyleliteralemphasis{\sphinxupquote{Dict}}) \textendash{} Data object that contains set values

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{scols}} (\sphinxstyleliteralemphasis{\sphinxupquote{Sequence}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} List of column names corresponding to index labels and position, by default None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{return\_set}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Return the set rather than assign within function, by default False

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{switch}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Return None if False, by default True

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{create\_indexed\_set}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Indicator for whether output set should include values as well as new index (IndexedSets), by default True

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{use\_values}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} If create\_indexed\_set is False, use the values of sdata rather than keys for pyo Set members, by default False

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
Pyomo Set Object

\sphinxlineitem{Return type}
\sphinxAtStartPar
pyo.Set

\end{description}\end{quote}

\end{fulllineitems}

\index{\_declare\_set\_with\_iterable() (src.common.model.Model method)@\spxentry{\_declare\_set\_with\_iterable()}\spxextra{src.common.model.Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.common.model:src.common.model.Model._declare_set_with_iterable}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{\_declare\_set\_with\_iterable}}}
{\sphinxparam{\DUrole{n}{sname}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{str}}\sphinxparamcomma \sphinxparam{\DUrole{n}{sdata}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{Sequence\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }Set\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }array}}\sphinxparamcomma \sphinxparam{\DUrole{n}{scols}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{Sequence\DUrole{p}{{[}}str\DUrole{p}{{]}}\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }None}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{return\_set}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{bool\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }None}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{False}}\sphinxparamcomma \sphinxparam{\DUrole{n}{switch}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{bool\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }None}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{True}}}
{{ $\rightarrow$ Set}}
\pysigstopsignatures
\sphinxAtStartPar
Declares a pyomo Set object named ‘sname’ using input index values and labels.

\sphinxAtStartPar
Function can take iterable objects such as tuples, lists, etc as data inputs. Note that if
the dimension of the index is larger than 1, user needs to provide a list of names for each
set dimension.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{sname}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Name of set

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{sdata}} (\sphinxstyleliteralemphasis{\sphinxupquote{Sequence}}) \textendash{} Data object that contains set values

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{scols}} (\sphinxstyleliteralemphasis{\sphinxupquote{Sequence}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} List of column names corresponding to index labels and position, by default None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{return\_set}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Return the set rather than assign within function, by default False

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{switch}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Return None if False, by default True

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
Pyomo Set Object

\sphinxlineitem{Return type}
\sphinxAtStartPar
pyo.Set

\end{description}\end{quote}

\end{fulllineitems}

\index{\_declare\_set\_with\_pandas() (src.common.model.Model method)@\spxentry{\_declare\_set\_with\_pandas()}\spxextra{src.common.model.Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.common.model:src.common.model.Model._declare_set_with_pandas}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{\_declare\_set\_with\_pandas}}}
{\sphinxparam{\DUrole{n}{sname}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{str}}\sphinxparamcomma \sphinxparam{\DUrole{n}{sdata}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{DataFrame\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }Series}}\sphinxparamcomma \sphinxparam{\DUrole{n}{return\_set}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{bool\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }None}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{False}}\sphinxparamcomma \sphinxparam{\DUrole{n}{switch}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{bool\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }None}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{True}}\sphinxparamcomma \sphinxparam{\DUrole{n}{use\_columns}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{bool\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }None}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{False}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Declares a pyomo Set object named ‘sname’ using input index values and labels from a
Pandas object.

\sphinxAtStartPar
Function assumes that the index values are the desired data to construct set object. User
can specify whether to create set with column values instead
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{sname}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Name of set

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{sdata}} (\sphinxstyleliteralemphasis{\sphinxupquote{MutableSequence}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} Data object that contains set indices

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{return\_set}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Return the set rather than assign within function, by default False

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{switch}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Return None if False, by default True

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{use\_columns}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Use columns as indices for pyo set rather than row index, by default False

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
Pyomo Set Object

\sphinxlineitem{Return type}
\sphinxAtStartPar
pyo.Set

\end{description}\end{quote}

\end{fulllineitems}

\index{build() (src.common.model.Model class method)@\spxentry{build()}\spxextra{src.common.model.Model class method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.common.model:src.common.model.Model.build}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{\DUrole{k}{classmethod}\DUrole{w}{ }}}\sphinxbfcode{\sphinxupquote{build}}}
{}
{}
\pysigstopsignatures
\sphinxAtStartPar
Default build command; class\sphinxhyphen{}level build to create and return an instance of Model.

\sphinxAtStartPar
This will work for any class inheriting the method, but it is recommended to replace this
with model\sphinxhyphen{}specific build instructions if this functionality is desired.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
Instance of Model object

\sphinxlineitem{Return type}
\sphinxAtStartPar
Object

\end{description}\end{quote}

\end{fulllineitems}

\index{declare\_ordered\_time\_set() (src.common.model.Model method)@\spxentry{declare\_ordered\_time\_set()}\spxextra{src.common.model.Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.common.model:src.common.model.Model.declare_ordered_time_set}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{declare\_ordered\_time\_set}}}
{\sphinxparam{\DUrole{n}{sname}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{str}}\sphinxparamcomma \sphinxparam{\DUrole{o}{*}\DUrole{n}{sets}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{Set}}\sphinxparamcomma \sphinxparam{\DUrole{n}{return\_set}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{bool\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }None}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{False}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Unnest the time sets into a single, unnested ordered, synchronous time set, an IndexedSet
object keyed by the values in the time set, and an IndexedSet object keyed by the combined,
original input sets.

\sphinxAtStartPar
These three set outputs are directly set as attributes of the model instance:

\sphinxAtStartPar
sname:               (1,) , (2, ), … ,(N)
sname\_time\_to\_index: (1,):{[}set1, set2, set3{]} , (2,):{[}set1, set2, set3{]}
sname\_index\_to\_time: (set1, set2, set3): {[}1{]} , (set1, set2, set3): {[}2{]}

\sphinxAtStartPar
In summary, this function creates three sets, creating a unique, ordered set from input sets
with the assumption that they are given to the function in hierarchical order. For example,
for a desired time set that orders Year, Month, Day values, the args for the function
should be provided as:

\sphinxAtStartPar
m.Year, m.Month, m.Day

\sphinxAtStartPar
Pyomo set products are used to unpack and create new set values that are ordered by the
hierarchy provided:

\sphinxAtStartPar
(year1, month1, day1) , (year1, month1, day2) , … , (year2, month1, day1) , … (yearY, monthM, dayD)
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{sname}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Desired root name for the new sets

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{sets}} (\sphinxstyleliteralemphasis{\sphinxupquote{pyo.Set}}) \textendash{} A series of unnamed arguments assumed to contain pyo.Set in order of temporal hierarchy

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{return\_set}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Return the set rather than assign within function, by default False

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
No return object; all sets assigned to model internally

\sphinxlineitem{Return type}
\sphinxAtStartPar
None

\sphinxlineitem{Raises}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ValueError}} \textendash{} “No sets provided in args; provide pyo.Set objects to use this function”

\end{description}\end{quote}

\end{fulllineitems}

\index{declare\_param() (src.common.model.Model method)@\spxentry{declare\_param()}\spxextra{src.common.model.Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.common.model:src.common.model.Model.declare_param}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{declare\_param}}}
{\sphinxparam{\DUrole{n}{pname}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{str}}\sphinxparamcomma \sphinxparam{\DUrole{n}{p\_set}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{Set\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{data}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{dict\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }DataFrame\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }Series\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }int\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }float}}\sphinxparamcomma \sphinxparam{\DUrole{n}{return\_param}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{bool\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }None}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{False}}\sphinxparamcomma \sphinxparam{\DUrole{n}{default}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{int\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }None}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{0}}\sphinxparamcomma \sphinxparam{\DUrole{n}{mutable}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{bool\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }None}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{False}}}
{{ $\rightarrow$ Param}}
\pysigstopsignatures
\sphinxAtStartPar
Declares a pyo Parameter component named ‘pname’ with the input data and index set.

\sphinxAtStartPar
Unpacks column dictionary of index set for param instance and creates pyo.Param; either
assigns the value internally or returns the object based on return\_param.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{pname}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Desired name of new pyo.Param instance

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{p\_set}} (\sphinxstyleliteralemphasis{\sphinxupquote{pyo.Set}}) \textendash{} Pyomo Set instance to index new Param

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{data}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{pd.DataFrame}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{pd.Series}}) \textendash{} Data to initialize Param instance

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{return\_param}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Return the param after function call rather than assign to self, by default False

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{default}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} pyo.Param keyword argument, by default 0

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mutable}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} pyo.Param keyword argument, by default False

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
A pyomo Parameter instance

\sphinxlineitem{Return type}
\sphinxAtStartPar
pyo.Param

\sphinxlineitem{Raises}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ValueError}} \textendash{} Raises error if input data not in format supported by function

\end{description}\end{quote}

\end{fulllineitems}

\index{declare\_set() (src.common.model.Model method)@\spxentry{declare\_set()}\spxextra{src.common.model.Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.common.model:src.common.model.Model.declare_set}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{declare\_set}}}
{\sphinxparam{\DUrole{n}{sname}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{str}}\sphinxparamcomma \sphinxparam{\DUrole{n}{sdata}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{MutableSequence\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }DataFrame\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }Series\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }Dict}}\sphinxparamcomma \sphinxparam{\DUrole{n}{scols}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{MutableSequence\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }None}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{return\_set}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{bool\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }None}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{False}}\sphinxparamcomma \sphinxparam{\DUrole{n}{switch}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{bool\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }None}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{True}}\sphinxparamcomma \sphinxparam{\DUrole{n}{create\_indexed\_set}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{bool\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }None}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{True}}\sphinxparamcomma \sphinxparam{\DUrole{n}{use\_values}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{bool\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }None}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{False}}\sphinxparamcomma \sphinxparam{\DUrole{n}{use\_columns}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{bool\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }None}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{False}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Declares a pyomo Set object named ‘sname’ using input index values and labels.

\sphinxAtStartPar
Function handles input values and calls appropriate declare\_set methods based on data
type of sdata
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{sname}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Name of set

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{sdata}} (\sphinxstyleliteralemphasis{\sphinxupquote{Dict}}) \textendash{} Data object that contains set values

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{scols}} (\sphinxstyleliteralemphasis{\sphinxupquote{Sequence}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} List of column names corresponding to index labels and position, by default None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{return\_set}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Return the set rather than assign within function, by default False

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{switch}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Return None if False, by default True

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{create\_indexed\_set}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} If dict, indicator for whether output set should include values as well as new index (IndexedSets), by default True

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{use\_values}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} If dict and create\_indexed\_set is False, use the values of sdata rather than keys for pyo Set members, by default False

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{use\_columns}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} If Pandas, use columns as indices for pyo set rather than row index, by default False

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
Pyomo Set Object

\sphinxlineitem{Return type}
\sphinxAtStartPar
pyo.Set

\end{description}\end{quote}

\end{fulllineitems}

\index{declare\_set\_with\_sets() (src.common.model.Model method)@\spxentry{declare\_set\_with\_sets()}\spxextra{src.common.model.Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.common.model:src.common.model.Model.declare_set_with_sets}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{declare\_set\_with\_sets}}}
{\sphinxparam{\DUrole{n}{sname}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{str}}\sphinxparamcomma \sphinxparam{\DUrole{o}{*}\DUrole{n}{sets}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{Set}}\sphinxparamcomma \sphinxparam{\DUrole{n}{return\_set}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{bool\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }None}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{False}}\sphinxparamcomma \sphinxparam{\DUrole{n}{switch}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{bool\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }None}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{True}}}
{{ $\rightarrow$ Set}}
\pysigstopsignatures
\sphinxAtStartPar
Declares a new set object using input sets as arguments.

\sphinxAtStartPar
Function creates a set product with set arguments to create a new set. This is how pyomo
handles set creation with multiple existing sets as arguments.

\sphinxAtStartPar
However, this function finds each pyomo set in column dictionary and unpacks the names,
so that the new set can be logged in the column dictionary too.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{sname}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Desired name of new set

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{*sets}} (\sphinxstyleliteralemphasis{\sphinxupquote{tuple}}\sphinxstyleliteralemphasis{\sphinxupquote{ of }}\sphinxstyleliteralemphasis{\sphinxupquote{pyo.Set}}) \textendash{} Unnamed arguments assumed to be pyomo sets

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{return\_set}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Return the set rather than assign within function, by default False

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{switch}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Return None if False, by default True

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
Pyomo Set Object

\sphinxlineitem{Return type}
\sphinxAtStartPar
pyo.Set

\end{description}\end{quote}

\end{fulllineitems}

\index{declare\_shifted\_time\_set() (src.common.model.Model method)@\spxentry{declare\_shifted\_time\_set()}\spxextra{src.common.model.Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.common.model:src.common.model.Model.declare_shifted_time_set}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{declare\_shifted\_time\_set}}}
{\sphinxparam{\DUrole{n}{sname}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{str}}\sphinxparamcomma \sphinxparam{\DUrole{n}{shift\_size}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{int}}\sphinxparamcomma \sphinxparam{\DUrole{n}{shift\_type}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{Literal\DUrole{p}{{[}}\DUrole{s}{\textquotesingle{}lag\textquotesingle{}}\DUrole{p}{,}\DUrole{w}{ }\DUrole{s}{\textquotesingle{}lead\textquotesingle{}}\DUrole{p}{{]}}}}\sphinxparamcomma \sphinxparam{\DUrole{o}{*}\DUrole{n}{sets}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{Set}}\sphinxparamcomma \sphinxparam{\DUrole{n}{return\_set}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{bool\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }None}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{False}}\sphinxparamcomma \sphinxparam{\DUrole{n}{shift\_sets}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{List\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }None}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{None}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
A generalize shifting function that creates sets compatible with leads or lags in pyomo
components.

\sphinxAtStartPar
For example, with a storage constraint where the current value is contrained to be equal to
the value of storage in the previous period:

\sphinxAtStartPar
model.storage{[}t{]} == model.storage{[}t\sphinxhyphen{}1{]} + …

\sphinxAtStartPar
The indexing set must be consistent with the storage variable, but not include elements that
are undefined for this constraint. In this example, the set containing values for t must not
include t = 1 (e.g. the lagged value must be defined). This function creates a shifted time
set by removing values from the input sets to comply with the lags or leads.

\sphinxAtStartPar
Function inputs require a shift size (in the example above, this would be 1), a shift type
(lead or lag), and the sets used to construct the new, shifted set (model.timestep). If a
lag or lead is required on a single dimension of the new set, the ‘shift\_sets’ argument can
include a list of pyo.set names (included in the arguments) to shift by the other args.

\sphinxAtStartPar
For example…

\sphinxAtStartPar
model.storage{[}hub, season{]} == model.storage{[}hub, season \sphinxhyphen{} 1{]}

\sphinxAtStartPar
In this case, season = 1 is always invalid due to the lag; so index (1, 2) or the value for
hub = 1 and season = 2 is valid, but (2, 1) remains an invalid argument as there is no
season = 0. A new set composed of hub and season, with shift\_sets = {[}“season”{]} and
sets = model.hub, model.season, is created to lag on one index value while leaving others
unchanged.

\sphinxAtStartPar
Default is to create set product of all input sets and lag/lead w/ resulting elements.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{sname}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Desired name for new set

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{shift\_size}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Size of shift in set

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{shift\_type}} (\sphinxstyleliteralemphasis{\sphinxupquote{str in}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{"lag"}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{"lead"}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Type of shift (e.g. t\sphinxhyphen{}1 or t+1)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{*sets}} (\sphinxstyleliteralemphasis{\sphinxupquote{Unnamed arguments}}) \textendash{} A series of unnamed arguments assumed to contain pyo.Set in order of temporal hierarchy

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{return\_set}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Return the set rather than assign within function, by default False

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{shift\_sets}} (\sphinxstyleliteralemphasis{\sphinxupquote{List}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} List of pyo.Set (by name) in {\color{red}\bfseries{}*}sets to shift, by default None

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
A pyomo Set

\sphinxlineitem{Return type}
\sphinxAtStartPar
pyo.Set

\sphinxlineitem{Raises}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ValueError}} \textendash{} Shift sets don’t align with {\color{red}\bfseries{}*}sets names

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ValueError}} \textendash{} Type argument is neither lead nor lag

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{declare\_var() (src.common.model.Model method)@\spxentry{declare\_var()}\spxextra{src.common.model.Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.common.model:src.common.model.Model.declare_var}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{declare\_var}}}
{\sphinxparam{\DUrole{n}{vname}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{str}}\sphinxparamcomma \sphinxparam{\DUrole{n}{v\_set}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{Set}}\sphinxparamcomma \sphinxparam{\DUrole{n}{return\_var}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{bool\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }None}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{False}}\sphinxparamcomma \sphinxparam{\DUrole{n}{within}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{Literal\DUrole{p}{{[}}\DUrole{s}{\textquotesingle{}NonNegativeReals\textquotesingle{}}\DUrole{p}{,}\DUrole{w}{ }\DUrole{s}{\textquotesingle{}Binary\textquotesingle{}}\DUrole{p}{,}\DUrole{w}{ }\DUrole{s}{\textquotesingle{}Reals\textquotesingle{}}\DUrole{p}{,}\DUrole{w}{ }\DUrole{s}{\textquotesingle{}NonNegativeIntegers\textquotesingle{}}\DUrole{p}{{]}}\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }None}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{\textquotesingle{}NonNegativeReals\textquotesingle{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{bound}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{tuple\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }None}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{(0, 1000000000)}}\sphinxparamcomma \sphinxparam{\DUrole{n}{switch}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{bool\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }None}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{True}}}
{{ $\rightarrow$ Var}}
\pysigstopsignatures
\sphinxAtStartPar
Declares a pyo Variable component named ‘vname’ with index set ‘v\_set’.

\sphinxAtStartPar
Creates variable indexed by previously defined pyo Set instance ‘v\_set’ and assigns to self;
function will return the component if return\_var is set to True. Other keywords passed to
pyo.Var are within and bound.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{vname}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Desired name of new pyo Variable

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{v\_set}} (\sphinxstyleliteralemphasis{\sphinxupquote{pyo.Set}}) \textendash{} Index set for new pyo Variable

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{return\_var}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Return component rather than assign internally, by default False

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{within}} (\sphinxstyleliteralemphasis{\sphinxupquote{str in}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{"NonNegativeReals"}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{"Binary"}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{"Reals"}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{"NonNegativeIntegers"}}\sphinxstyleliteralemphasis{\sphinxupquote{{]} }}\sphinxstyleliteralemphasis{\sphinxupquote{| }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} pyo.Var keyword argument, by default “NonNegativeReals”

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{bound}} (\sphinxstyleliteralemphasis{\sphinxupquote{tuple}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} pyo.Var keyword argument, by default (0, 1000000000)

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
A pyomo Variable instance

\sphinxlineitem{Return type}
\sphinxAtStartPar
pyo.Var

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_duals() (src.common.model.Model method)@\spxentry{get\_duals()}\spxextra{src.common.model.Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.common.model:src.common.model.Model.get_duals}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{get\_duals}}}
{\sphinxparam{\DUrole{n}{component\_name}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{str}}}
{{ $\rightarrow$ defaultdict}}
\pysigstopsignatures
\sphinxAtStartPar
Extract duals from a solved model instance
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{component\_name}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Name of constraint

\sphinxlineitem{Returns}
\sphinxAtStartPar
Dual values w/ index values

\sphinxlineitem{Return type}
\sphinxAtStartPar
defaultdict

\end{description}\end{quote}

\end{fulllineitems}

\index{populate\_sets\_rule() (src.common.model.Model method)@\spxentry{populate\_sets\_rule()}\spxextra{src.common.model.Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.common.model:src.common.model.Model.populate_sets_rule}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{populate\_sets\_rule}}}
{\sphinxparam{\DUrole{n}{sname}}\sphinxparamcomma \sphinxparam{\DUrole{n}{set\_base\_name}\DUrole{o}{=}\DUrole{default_value}{None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{set\_base2}\DUrole{o}{=}\DUrole{default_value}{None}}}
{{ $\rightarrow$ Set}}
\pysigstopsignatures
\sphinxAtStartPar
Generic function to create a new re\sphinxhyphen{}indexed set for a pyomo ConcreteModel instance which
should speed up build time. Must pass non\sphinxhyphen{}empty (either) set\_base\_name or set\_base2
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{m1}} (\sphinxstyleliteralemphasis{\sphinxupquote{pyo.ConcreteModel}}) \textendash{} pyomo model instance

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{sname}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} name of input pyomo set to base reindexing

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{set\_base\_name}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} the name of the set to be the base of the reindexing, if left blank, uses set\_base2, by default ‘’

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{set\_base2}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} the list of names of set columns to be the base of the reindexing, if left blank, should
use set\_base\_name, by default {[}{]} these will form the index set of the indexed set structure

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
reindexed set to be added to model

\sphinxlineitem{Return type}
\sphinxAtStartPar
pyomo set

\end{description}\end{quote}

\end{fulllineitems}

\index{reorganize\_index\_set() (src.common.model.Model method)@\spxentry{reorganize\_index\_set()}\spxextra{src.common.model.Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.common.model:src.common.model.Model.reorganize_index_set}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{reorganize\_index\_set}}}
{\sphinxparam{\DUrole{n}{sname}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{str}}\sphinxparamcomma \sphinxparam{\DUrole{n}{new\_sname}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{str}}\sphinxparamcomma \sphinxparam{\DUrole{n}{return\_set}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{bool\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }None}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{False}}\sphinxparamcomma \sphinxparam{\DUrole{n}{create\_indexed\_set}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{bool\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }None}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{False}}\sphinxparamcomma \sphinxparam{\DUrole{n}{reorg\_set\_cols}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{List\DUrole{p}{{[}}str\DUrole{p}{{]}}\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }None}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{reorg\_set\_sname}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{str\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }None}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{None}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Creates new pyomo sets based on an input set and a desired set of indices for an output
set. User should provide either names of columns desired for reorganized output set OR the
name of a set that mirrors the desired indexing.

\sphinxAtStartPar
For instance, an input set indexed by (yr, region, month, day) can be reorganized into an
output set:

\sphinxAtStartPar
(yr, region):{[}(month,day), (month,day), (month,day){]}

\sphinxAtStartPar
when {[}“yr”, “region”{]} is provided for reorg\_set\_cols.

\sphinxAtStartPar
If only the set keys are desired, without creating an indexed set object as illustrated
above, the user can set ‘create\_indexed\_set’ to false. If true, the output is a
pyo.IndexedSet, with each element of the IndexedSet containing the values of other indices
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{sname}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Name of input set

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{new\_sname}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Name of output set or IndexedSet

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{create\_indexed\_set}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Indicator for whether output set should include values as well as new index (IndexedSets), by default False

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{return\_set}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Indicator for whether to return the constructed set

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{reorg\_set\_cols}} (\sphinxstyleliteralemphasis{\sphinxupquote{List}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{{]} }}\sphinxstyleliteralemphasis{\sphinxupquote{| }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} List of columns to index output set contained in ‘sname’, by default None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{reorg\_set\_sname}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Name of set to use for identifying output set indices, by default None

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
Pyomo Set or IndexedSet object reorganized based on input set

\sphinxlineitem{Return type}
\sphinxAtStartPar
Pyo.Set

\sphinxlineitem{Raises}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ValueError}} \textendash{} Populate function is either\sphinxhyphen{}or for reorg\_set\_cols and reorg\_set\_sname, received both

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ValueError}} \textendash{} Populate function is either\sphinxhyphen{}or for reorg\_set\_cols and reorg\_set\_sname, received neither

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ValueError}} \textendash{} Elements missing from input set desired in new set

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{unpack\_set\_arguments() (src.common.model.Model method)@\spxentry{unpack\_set\_arguments()}\spxextra{src.common.model.Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.common.model:src.common.model.Model.unpack_set_arguments}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{unpack\_set\_arguments}}}
{\sphinxparam{\DUrole{n}{sname}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{str}}\sphinxparamcomma \sphinxparam{\DUrole{n}{sets}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{Tuple\DUrole{p}{{[}}Set\DUrole{p}{{]}}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{return\_set\_product}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{bool\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }None}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{True}}}
{{ $\rightarrow$ Set}}
\pysigstopsignatures
\sphinxAtStartPar
Handles unnamed pyo.Set arguments for multiple declaration functions.

\sphinxAtStartPar
For an arbitrarily large number of set inputs, this function unpacks the names for each set
stored in the column dictionary, creates a new list of the index labels and ordering, and
then provides the pyo.Set product result as an output.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{sname}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Name of new set

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{sets}} (\sphinxstyleliteralemphasis{\sphinxupquote{tuple}}\sphinxstyleliteralemphasis{\sphinxupquote{ of }}\sphinxstyleliteralemphasis{\sphinxupquote{pyo.Set}}) \textendash{} Tuple of pyo.Set arguments to be used to generate new set

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{return\_set\_product}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} If True, return the unpacked set product

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\sphinxstylestrong{new\_set} \textendash{} Set product result from input sets, by order of sets arguments

\sphinxlineitem{Return type}
\sphinxAtStartPar
pyo.Set

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}


\sphinxstepscope


\paragraph{src.common.utilities}
\label{\detokenize{src.common.utilities:module-src.common.utilities}}\label{\detokenize{src.common.utilities:src-common-utilities}}\label{\detokenize{src.common.utilities::doc}}\index{module@\spxentry{module}!src.common.utilities@\spxentry{src.common.utilities}}\index{src.common.utilities@\spxentry{src.common.utilities}!module@\spxentry{module}}
\sphinxAtStartPar
A gathering of utility functions for dealing with model interconnectivity
\subsubsection*{Functions}


\begin{savenotes}
\sphinxatlongtablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\makeatletter
  \LTleft \@totalleftmargin plus1fill
  \LTright\dimexpr\columnwidth-\@totalleftmargin-\linewidth\relax plus1fill
\makeatother
\begin{longtable}{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\endfirsthead

\multicolumn{2}{c}{\sphinxnorowcolor
    \makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}%
}\\
\sphinxtoprule
\endhead

\sphinxbottomrule
\multicolumn{2}{r}{\sphinxnorowcolor
    \makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}%
}\\
\endfoot

\endlastfoot
\sphinxtableatstartofbodyhook

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{getLogger}}({[}name{]})
&
\sphinxAtStartPar
Return a logger with the specified name, creating it if necessary.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.common.utilities:src.common.utilities.get_args}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_args}}}}}()
&
\sphinxAtStartPar
Parses args
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.common.utilities:src.common.utilities.make_dir}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{make\_dir}}}}}(dir\_name)
&
\sphinxAtStartPar
generates an output directory to write model results, output directory is the date/time at the time this function executes.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.common.utilities:src.common.utilities.scale_load}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{scale\_load}}}}}(data\_root)
&
\sphinxAtStartPar
Reads in BaseLoad.csv (load for all regions/hours for first year) and LoadScalar.csv (a multiplier for all model years).
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.common.utilities:src.common.utilities.scale_load_with_enduses}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{scale\_load\_with\_enduses}}}}}(data\_root)
&
\sphinxAtStartPar
Reads in BaseLoad.csv (load for all regions/hours for first year), EnduseBaseShares.csv (the shares of demand for each enduse in the base year) and EnduseScalar.csv (a multiplier for all model years by enduse category).
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.common.utilities:src.common.utilities.setup_logger}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{setup\_logger}}}}}(settings)
&
\sphinxAtStartPar
initiates logging, sets up logger in the output directory specified
\\
\sphinxbottomrule
\end{longtable}
\sphinxtableafterendhook
\sphinxatlongtableend
\end{savenotes}
\subsubsection*{Classes}


\begin{savenotes}
\sphinxatlongtablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\makeatletter
  \LTleft \@totalleftmargin plus1fill
  \LTright\dimexpr\columnwidth-\@totalleftmargin-\linewidth\relax plus1fill
\makeatother
\begin{longtable}{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\endfirsthead

\multicolumn{2}{c}{\sphinxnorowcolor
    \makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}%
}\\
\sphinxtoprule
\endhead

\sphinxbottomrule
\multicolumn{2}{r}{\sphinxnorowcolor
    \makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}%
}\\
\endfoot

\endlastfoot
\sphinxtableatstartofbodyhook

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Path}}(*args, **kwargs)
&
\sphinxAtStartPar
PurePath subclass that can make system calls.
\\
\sphinxbottomrule
\end{longtable}
\sphinxtableafterendhook
\sphinxatlongtableend
\end{savenotes}
\index{get\_args() (in module src.common.utilities)@\spxentry{get\_args()}\spxextra{in module src.common.utilities}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.common.utilities:src.common.utilities.get_args}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{src.common.utilities.}}\sphinxbfcode{\sphinxupquote{get\_args}}}
{}
{}
\pysigstopsignatures
\sphinxAtStartPar
Parses args
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
\sphinxstylestrong{args} \textendash{} Contains arguments pass to main.py executable

\sphinxlineitem{Return type}
\sphinxAtStartPar
Namespace

\end{description}\end{quote}

\end{fulllineitems}

\index{make\_dir() (in module src.common.utilities)@\spxentry{make\_dir()}\spxextra{in module src.common.utilities}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.common.utilities:src.common.utilities.make_dir}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{src.common.utilities.}}\sphinxbfcode{\sphinxupquote{make\_dir}}}
{\sphinxparam{\DUrole{n}{dir\_name}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
generates an output directory to write model results, output directory is the date/time
at the time this function executes. It includes subdirs for vars, params, constraints.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
the name of the output directory

\sphinxlineitem{Return type}
\sphinxAtStartPar
string

\end{description}\end{quote}

\end{fulllineitems}

\index{scale\_load() (in module src.common.utilities)@\spxentry{scale\_load()}\spxextra{in module src.common.utilities}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.common.utilities:src.common.utilities.scale_load}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{src.common.utilities.}}\sphinxbfcode{\sphinxupquote{scale\_load}}}
{\sphinxparam{\DUrole{n}{data\_root}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Reads in BaseLoad.csv (load for all regions/hours for first year)
and LoadScalar.csv (a multiplier for all model years). Merges the
data and multiplies the load by the scalar to generate new load
estimates for all model years.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
dataframe that contains load for all regions/years/hours

\sphinxlineitem{Return type}
\sphinxAtStartPar
pandas.core.frame.DataFrame

\end{description}\end{quote}

\end{fulllineitems}

\index{scale\_load\_with\_enduses() (in module src.common.utilities)@\spxentry{scale\_load\_with\_enduses()}\spxextra{in module src.common.utilities}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.common.utilities:src.common.utilities.scale_load_with_enduses}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{src.common.utilities.}}\sphinxbfcode{\sphinxupquote{scale\_load\_with\_enduses}}}
{\sphinxparam{\DUrole{n}{data\_root}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Reads in BaseLoad.csv (load for all regions/hours for first year), EnduseBaseShares.csv
(the shares of demand for each enduse in the base year) and EnduseScalar.csv (a multiplier
for all model years by enduse category). Merges the data and multiplies the load by the
adjusted enduse scalar and then sums up to new load estimates for all model years.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
dataframe that contains load for all regions/years/hours

\sphinxlineitem{Return type}
\sphinxAtStartPar
pandas.core.frame.DataFrame

\end{description}\end{quote}

\end{fulllineitems}

\index{setup\_logger() (in module src.common.utilities)@\spxentry{setup\_logger()}\spxextra{in module src.common.utilities}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.common.utilities:src.common.utilities.setup_logger}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{src.common.utilities.}}\sphinxbfcode{\sphinxupquote{setup\_logger}}}
{\sphinxparam{\DUrole{n}{settings}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
initiates logging, sets up logger in the output directory specified
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{output\_dir}} (\sphinxstyleliteralemphasis{\sphinxupquote{path}}) \textendash{} output directory path

\end{description}\end{quote}

\end{fulllineitems}


\sphinxstepscope


\subsubsection{src.integrator}
\label{\detokenize{src.integrator:module-src.integrator}}\label{\detokenize{src.integrator:src-integrator}}\label{\detokenize{src.integrator::doc}}\index{module@\spxentry{module}!src.integrator@\spxentry{src.integrator}}\index{src.integrator@\spxentry{src.integrator}!module@\spxentry{module}}\subsubsection*{Modules}


\begin{savenotes}
\sphinxatlongtablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\makeatletter
  \LTleft \@totalleftmargin plus1fill
  \LTright\dimexpr\columnwidth-\@totalleftmargin-\linewidth\relax plus1fill
\makeatother
\begin{longtable}{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\endfirsthead

\multicolumn{2}{c}{\sphinxnorowcolor
    \makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}%
}\\
\sphinxtoprule
\endhead

\sphinxbottomrule
\multicolumn{2}{r}{\sphinxnorowcolor
    \makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}%
}\\
\endfoot

\endlastfoot
\sphinxtableatstartofbodyhook

\sphinxAtStartPar
{\hyperref[\detokenize{src.integrator.gaussseidel:module-src.integrator.gaussseidel}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{gaussseidel}}}}}
&
\sphinxAtStartPar
Iteratively solve 2 models with GS methodology
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.integrator.progress_plot:module-src.integrator.progress_plot}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{progress\_plot}}}}}
&
\sphinxAtStartPar
A plotter that can be used for combined solves
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.integrator.runner:module-src.integrator.runner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{runner}}}}}
&
\sphinxAtStartPar
A gathering of functions for running models solo
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.integrator.unified:module-src.integrator.unified}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{unified}}}}}
&
\sphinxAtStartPar
Unifying the solve of both H2 and Elec and Res
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.integrator.utilities:module-src.integrator.utilities}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{utilities}}}}}
&
\sphinxAtStartPar
A gathering of utility functions for dealing with model interconnectivity
\\
\sphinxbottomrule
\end{longtable}
\sphinxtableafterendhook
\sphinxatlongtableend
\end{savenotes}

\sphinxstepscope


\paragraph{src.integrator.gaussseidel}
\label{\detokenize{src.integrator.gaussseidel:module-src.integrator.gaussseidel}}\label{\detokenize{src.integrator.gaussseidel:src-integrator-gaussseidel}}\label{\detokenize{src.integrator.gaussseidel::doc}}\index{module@\spxentry{module}!src.integrator.gaussseidel@\spxentry{src.integrator.gaussseidel}}\index{src.integrator.gaussseidel@\spxentry{src.integrator.gaussseidel}!module@\spxentry{module}}
\sphinxAtStartPar
Iteratively solve 2 models with GS methodology

\sphinxAtStartPar
see README for process explanation
\subsubsection*{Functions}


\begin{savenotes}
\sphinxatlongtablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\makeatletter
  \LTleft \@totalleftmargin plus1fill
  \LTright\dimexpr\columnwidth-\@totalleftmargin-\linewidth\relax plus1fill
\makeatother
\begin{longtable}{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\endfirsthead

\multicolumn{2}{c}{\sphinxnorowcolor
    \makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}%
}\\
\sphinxtoprule
\endhead

\sphinxbottomrule
\multicolumn{2}{r}{\sphinxnorowcolor
    \makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}%
}\\
\endfoot

\endlastfoot
\sphinxtableatstartofbodyhook

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{convert\_elec\_price\_to\_lut}}(prices)
&
\sphinxAtStartPar
convert electricity prices to dictionary, look up table
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{convert\_h2\_price\_records}}(records)
&
\sphinxAtStartPar
simple coversion from list of records to a dictionary LUT repeat entries should not occur and will generate an error
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{getLogger}}({[}name{]})
&
\sphinxAtStartPar
Return a logger with the specified name, creating it if necessary.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{get\_elec\_price}}(instance{[}, block{]})
&
\sphinxAtStartPar
pulls hourly electricity prices from completed PowerModel and de\sphinxhyphen{}weights them.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{init\_old\_cap}}(instance)
&
\sphinxAtStartPar
initialize capacity for 0th iteration
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{namedtuple}}(typename, field\_names, *{[}, ...{]})
&
\sphinxAtStartPar
Returns a new subclass of tuple with named fields.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{plot\_it}}(OUTPUT\_ROOT{[}, h2\_price\_records, ...{]})
&
\sphinxAtStartPar
cheap plotter of iterative progress
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{poll\_h2\_demand}}(model)
&
\sphinxAtStartPar
Get the hydrogen demand by rep\_year and region
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{poll\_h2\_prices\_from\_elec}}(model, tech, regions)
&
\sphinxAtStartPar
poll the step\sphinxhyphen{}1 H2 price currently in the model for region/year, averaged over any steps
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{poll\_hydrogen\_price}}(model{[}, block{]})
&
\sphinxAtStartPar
Retrieve the price of H2 from the H2 model
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{regional\_annual\_prices}}(m{[}, block{]})
&
\sphinxAtStartPar
pulls all regional annual weighted electricity prices
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{run\_elec\_model}}(settings{[}, solve{]})
&
\sphinxAtStartPar
build electricity model (and solve if solve=True) after passing in settings
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.integrator.gaussseidel:src.integrator.gaussseidel.run_gs}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{run\_gs}}}}}(settings)
&
\sphinxAtStartPar
Start the iterative GS process
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{select\_solver}}(instance)
&
\sphinxAtStartPar
Select solver based on learning method
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{set\_new\_cap}}(instance)
&
\sphinxAtStartPar
calculate new capacity after solve iteration
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{simple\_solve}}(m)
&
\sphinxAtStartPar
a simple solve routine
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{simple\_solve\_no\_opt}}(m, opt)
&
\sphinxAtStartPar
Solve concrete model using solver factory object
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{update\_cost}}(instance)
&
\sphinxAtStartPar
update capital cost based on new capacity learning
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{update\_h2\_prices}}(model, h2\_prices)
&
\sphinxAtStartPar
Update the H2 prices held in the model
\\
\sphinxbottomrule
\end{longtable}
\sphinxtableafterendhook
\sphinxatlongtableend
\end{savenotes}
\subsubsection*{Classes}


\begin{savenotes}
\sphinxatlongtablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\makeatletter
  \LTleft \@totalleftmargin plus1fill
  \LTright\dimexpr\columnwidth-\@totalleftmargin-\linewidth\relax plus1fill
\makeatother
\begin{longtable}{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\endfirsthead

\multicolumn{2}{c}{\sphinxnorowcolor
    \makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}%
}\\
\sphinxtoprule
\endhead

\sphinxbottomrule
\multicolumn{2}{r}{\sphinxnorowcolor
    \makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}%
}\\
\endfoot

\endlastfoot
\sphinxtableatstartofbodyhook

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{EI}}(region, year, hour)
&
\sphinxAtStartPar
(region, year, hour)
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Path}}(*args, **kwargs)
&
\sphinxAtStartPar
PurePath subclass that can make system calls.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{residentialModule}}({[}settings, loadFile, ...{]})
&
\sphinxAtStartPar
This contains the Residential model and its associated functions.
\\
\sphinxbottomrule
\end{longtable}
\sphinxtableafterendhook
\sphinxatlongtableend
\end{savenotes}
\index{run\_gs() (in module src.integrator.gaussseidel)@\spxentry{run\_gs()}\spxextra{in module src.integrator.gaussseidel}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.integrator.gaussseidel:src.integrator.gaussseidel.run_gs}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{src.integrator.gaussseidel.}}\sphinxbfcode{\sphinxupquote{run\_gs}}}
{\sphinxparam{\DUrole{n}{settings}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Start the iterative GS process
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{settings}} (\sphinxstyleliteralemphasis{\sphinxupquote{obj}}) \textendash{} Config\_settings object that holds module choices and settings

\end{description}\end{quote}

\end{fulllineitems}


\sphinxstepscope


\paragraph{src.integrator.progress\_plot}
\label{\detokenize{src.integrator.progress_plot:module-src.integrator.progress_plot}}\label{\detokenize{src.integrator.progress_plot:src-integrator-progress-plot}}\label{\detokenize{src.integrator.progress_plot::doc}}\index{module@\spxentry{module}!src.integrator.progress\_plot@\spxentry{src.integrator.progress\_plot}}\index{src.integrator.progress\_plot@\spxentry{src.integrator.progress\_plot}!module@\spxentry{module}}
\sphinxAtStartPar
A plotter that can be used for combined solves
\subsubsection*{Functions}


\begin{savenotes}
\sphinxatlongtablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\makeatletter
  \LTleft \@totalleftmargin plus1fill
  \LTright\dimexpr\columnwidth-\@totalleftmargin-\linewidth\relax plus1fill
\makeatother
\begin{longtable}{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\endfirsthead

\multicolumn{2}{c}{\sphinxnorowcolor
    \makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}%
}\\
\sphinxtoprule
\endhead

\sphinxbottomrule
\multicolumn{2}{r}{\sphinxnorowcolor
    \makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}%
}\\
\endfoot

\endlastfoot
\sphinxtableatstartofbodyhook

\sphinxAtStartPar
{\hyperref[\detokenize{src.integrator.progress_plot:src.integrator.progress_plot.plot_it}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{plot\_it}}}}}(OUTPUT\_ROOT{[}, h2\_price\_records, ...{]})
&
\sphinxAtStartPar
cheap plotter of iterative progress
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.integrator.progress_plot:src.integrator.progress_plot.plot_price_distro}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{plot\_price\_distro}}}}}(OUTPUT\_ROOT, price\_records)
&
\sphinxAtStartPar
cheap/quick analyisis and plot of the price records
\\
\sphinxbottomrule
\end{longtable}
\sphinxtableafterendhook
\sphinxatlongtableend
\end{savenotes}
\subsubsection*{Classes}


\begin{savenotes}
\sphinxatlongtablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\makeatletter
  \LTleft \@totalleftmargin plus1fill
  \LTright\dimexpr\columnwidth-\@totalleftmargin-\linewidth\relax plus1fill
\makeatother
\begin{longtable}{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\endfirsthead

\multicolumn{2}{c}{\sphinxnorowcolor
    \makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}%
}\\
\sphinxtoprule
\endhead

\sphinxbottomrule
\multicolumn{2}{r}{\sphinxnorowcolor
    \makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}%
}\\
\endfoot

\endlastfoot
\sphinxtableatstartofbodyhook

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Path}}(*args, **kwargs)
&
\sphinxAtStartPar
PurePath subclass that can make system calls.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{datetime}}(year, month, day{[}, hour{[}, minute{[}, ...)
&
\sphinxAtStartPar
The year, month and day arguments are required.
\\
\sphinxbottomrule
\end{longtable}
\sphinxtableafterendhook
\sphinxatlongtableend
\end{savenotes}
\index{plot\_it() (in module src.integrator.progress\_plot)@\spxentry{plot\_it()}\spxextra{in module src.integrator.progress\_plot}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.integrator.progress_plot:src.integrator.progress_plot.plot_it}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{src.integrator.progress\_plot.}}\sphinxbfcode{\sphinxupquote{plot\_it}}}
{\sphinxparam{\DUrole{n}{OUTPUT\_ROOT}}\sphinxparamcomma \sphinxparam{\DUrole{n}{h2\_price\_records}\DUrole{o}{=}\DUrole{default_value}{{[}{]}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{elec\_price\_records}\DUrole{o}{=}\DUrole{default_value}{{[}{]}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{h2\_obj\_records}\DUrole{o}{=}\DUrole{default_value}{{[}{]}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{elec\_obj\_records}\DUrole{o}{=}\DUrole{default_value}{{[}{]}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{h2\_demand\_records}\DUrole{o}{=}\DUrole{default_value}{{[}{]}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{elec\_demand\_records}\DUrole{o}{=}\DUrole{default_value}{{[}{]}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{load\_records}\DUrole{o}{=}\DUrole{default_value}{{[}{]}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{elec\_price\_to\_res\_records}\DUrole{o}{=}\DUrole{default_value}{{[}{]}}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
cheap plotter of iterative progress

\end{fulllineitems}

\index{plot\_price\_distro() (in module src.integrator.progress\_plot)@\spxentry{plot\_price\_distro()}\spxextra{in module src.integrator.progress\_plot}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.integrator.progress_plot:src.integrator.progress_plot.plot_price_distro}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{src.integrator.progress\_plot.}}\sphinxbfcode{\sphinxupquote{plot\_price\_distro}}}
{\sphinxparam{\DUrole{n}{OUTPUT\_ROOT}}\sphinxparamcomma \sphinxparam{\DUrole{n}{price\_records}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{list\DUrole{p}{{[}}float\DUrole{p}{{]}}}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
cheap/quick analyisis and plot of the price records

\end{fulllineitems}


\sphinxstepscope


\paragraph{src.integrator.runner}
\label{\detokenize{src.integrator.runner:module-src.integrator.runner}}\label{\detokenize{src.integrator.runner:src-integrator-runner}}\label{\detokenize{src.integrator.runner::doc}}\index{module@\spxentry{module}!src.integrator.runner@\spxentry{src.integrator.runner}}\index{src.integrator.runner@\spxentry{src.integrator.runner}!module@\spxentry{module}}
\sphinxAtStartPar
A gathering of functions for running models solo
\subsubsection*{Functions}


\begin{savenotes}
\sphinxatlongtablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\makeatletter
  \LTleft \@totalleftmargin plus1fill
  \LTright\dimexpr\columnwidth-\@totalleftmargin-\linewidth\relax plus1fill
\makeatother
\begin{longtable}{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\endfirsthead

\multicolumn{2}{c}{\sphinxnorowcolor
    \makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}%
}\\
\sphinxtoprule
\endhead

\sphinxbottomrule
\multicolumn{2}{r}{\sphinxnorowcolor
    \makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}%
}\\
\endfoot

\endlastfoot
\sphinxtableatstartofbodyhook

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{getLogger}}({[}name{]})
&
\sphinxAtStartPar
Return a logger with the specified name, creating it if necessary.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{plot\_price\_distro}}(OUTPUT\_ROOT, price\_records)
&
\sphinxAtStartPar
cheap/quick analyisis and plot of the price records
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{run\_elec\_model}}(settings{[}, solve{]})
&
\sphinxAtStartPar
build electricity model (and solve if solve=True) after passing in settings
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.integrator.runner:src.integrator.runner.run_elec_solo}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{run\_elec\_solo}}}}}({[}settings{]})
&
\sphinxAtStartPar
Runs electricity model by itself as defined in settings
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.integrator.runner:src.integrator.runner.run_h2_solo}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{run\_h2\_solo}}}}}({[}settings{]})
&
\sphinxAtStartPar
Runs hydrogen model by itself as defined in settings
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{run\_hydrogen\_model}}(settings)
&
\sphinxAtStartPar
run hydrogen model in standalone
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{run\_residential}}(settings)
&
\sphinxAtStartPar
This runs the residential model in stand\sphinxhyphen{}alone mode.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.integrator.runner:src.integrator.runner.run_residential_solo}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{run\_residential\_solo}}}}}({[}settings{]})
&
\sphinxAtStartPar
Runs residential model by itself as defined in settings
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.integrator.runner:src.integrator.runner.run_standalone}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{run\_standalone}}}}}(settings)
&
\sphinxAtStartPar
Runs standalone methods based on settings selections; running 1 or more modules
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{value}}(obj{[}, exception{]})
&
\sphinxAtStartPar
A utility function that returns the value of a Pyomo object or expression.
\\
\sphinxbottomrule
\end{longtable}
\sphinxtableafterendhook
\sphinxatlongtableend
\end{savenotes}
\subsubsection*{Classes}


\begin{savenotes}
\sphinxatlongtablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\makeatletter
  \LTleft \@totalleftmargin plus1fill
  \LTright\dimexpr\columnwidth-\@totalleftmargin-\linewidth\relax plus1fill
\makeatother
\begin{longtable}{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\endfirsthead

\multicolumn{2}{c}{\sphinxnorowcolor
    \makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}%
}\\
\sphinxtoprule
\endhead

\sphinxbottomrule
\multicolumn{2}{r}{\sphinxnorowcolor
    \makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}%
}\\
\endfoot

\endlastfoot
\sphinxtableatstartofbodyhook

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Config\_settings}}(config\_path{[}, args, test{]})
&
\sphinxAtStartPar
Generates the model settings that are used to solve.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Path}}(*args, **kwargs)
&
\sphinxAtStartPar
PurePath subclass that can make system calls.
\\
\sphinxbottomrule
\end{longtable}
\sphinxtableafterendhook
\sphinxatlongtableend
\end{savenotes}
\index{run\_elec\_solo() (in module src.integrator.runner)@\spxentry{run\_elec\_solo()}\spxextra{in module src.integrator.runner}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.integrator.runner:src.integrator.runner.run_elec_solo}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{src.integrator.runner.}}\sphinxbfcode{\sphinxupquote{run\_elec\_solo}}}
{\sphinxparam{\DUrole{n}{settings}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{{\hyperref[\detokenize{src.common.config_setup:src.common.config_setup.Config_settings}]{\sphinxcrossref{Config\_settings}}}\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }None}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{None}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Runs electricity model by itself as defined in settings
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{settings}} ({\hyperref[\detokenize{src.common.config_setup:src.common.config_setup.Config_settings}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Config\_settings}}}}}) \textendash{} Contains configuration settings for which regions, years, and switches to run

\end{description}\end{quote}

\end{fulllineitems}

\index{run\_h2\_solo() (in module src.integrator.runner)@\spxentry{run\_h2\_solo()}\spxextra{in module src.integrator.runner}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.integrator.runner:src.integrator.runner.run_h2_solo}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{src.integrator.runner.}}\sphinxbfcode{\sphinxupquote{run\_h2\_solo}}}
{\sphinxparam{\DUrole{n}{settings}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{{\hyperref[\detokenize{src.common.config_setup:src.common.config_setup.Config_settings}]{\sphinxcrossref{Config\_settings}}}\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }None}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{None}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Runs hydrogen model by itself as defined in settings
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{settings}} ({\hyperref[\detokenize{src.common.config_setup:src.common.config_setup.Config_settings}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Config\_settings}}}}}) \textendash{} Contains configuration settings for which regions and years to run

\end{description}\end{quote}

\end{fulllineitems}

\index{run\_residential\_solo() (in module src.integrator.runner)@\spxentry{run\_residential\_solo()}\spxextra{in module src.integrator.runner}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.integrator.runner:src.integrator.runner.run_residential_solo}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{src.integrator.runner.}}\sphinxbfcode{\sphinxupquote{run\_residential\_solo}}}
{\sphinxparam{\DUrole{n}{settings}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{{\hyperref[\detokenize{src.common.config_setup:src.common.config_setup.Config_settings}]{\sphinxcrossref{Config\_settings}}}\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }None}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{None}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Runs residential model by itself as defined in settings
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{settings}} ({\hyperref[\detokenize{src.common.config_setup:src.common.config_setup.Config_settings}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Config\_settings}}}}}) \textendash{} Contains configuration settings for which regions and years to run

\end{description}\end{quote}

\end{fulllineitems}

\index{run\_standalone() (in module src.integrator.runner)@\spxentry{run\_standalone()}\spxextra{in module src.integrator.runner}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.integrator.runner:src.integrator.runner.run_standalone}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{src.integrator.runner.}}\sphinxbfcode{\sphinxupquote{run\_standalone}}}
{\sphinxparam{\DUrole{n}{settings}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{{\hyperref[\detokenize{src.common.config_setup:src.common.config_setup.Config_settings}]{\sphinxcrossref{Config\_settings}}}}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Runs standalone methods based on settings selections; running 1 or more modules
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{settings}} ({\hyperref[\detokenize{src.common.config_setup:src.common.config_setup.Config_settings}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Config\_settings}}}}}) \textendash{} Instance of config\_settings containing run options, mode and settings

\end{description}\end{quote}

\end{fulllineitems}


\sphinxstepscope


\paragraph{src.integrator.unified}
\label{\detokenize{src.integrator.unified:module-src.integrator.unified}}\label{\detokenize{src.integrator.unified:src-integrator-unified}}\label{\detokenize{src.integrator.unified::doc}}\index{module@\spxentry{module}!src.integrator.unified@\spxentry{src.integrator.unified}}\index{src.integrator.unified@\spxentry{src.integrator.unified}!module@\spxentry{module}}
\sphinxAtStartPar
Unifying the solve of both H2 and Elec and Res

\sphinxAtStartPar
Dev Notes:

\sphinxAtStartPar
1. The “annual demand” constraint that is present and INACTIVE is omitted here for clarity.
It may likely be needed \sphinxhyphen{} in some form \sphinxhyphen{} at a later time. Recall, the key linkages to share the
electrical demand primary variable are:
\begin{itemize}
\item {} 
\sphinxAtStartPar
an annual level demand constraint

\item {} 
\sphinxAtStartPar
an accurate price\sphinxhyphen{}pulling function that can consider weighted duals from both constraints

\end{itemize}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
\sphinxAtStartPar
This model has a 2\sphinxhyphen{}solve update cycle as commented on near the termination check

\end{enumerate}
\begin{itemize}
\item {} 
\sphinxAtStartPar
elec\_prices gleaned from cycle{[}n{]} results \sphinxhyphen{}\textgreater{} solve cycle{[}n+1{]}

\item {} 
\sphinxAtStartPar
new\_load gleaned from cycle{[}n+1{]} results \sphinxhyphen{}\textgreater{} solve cycle{[}n+2{]}

\item {} 
\sphinxAtStartPar
elec\_pices gleaned from cycle{[}n+2{]}

\end{itemize}
\subsubsection*{Functions}


\begin{savenotes}
\sphinxatlongtablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\makeatletter
  \LTleft \@totalleftmargin plus1fill
  \LTright\dimexpr\columnwidth-\@totalleftmargin-\linewidth\relax plus1fill
\makeatother
\begin{longtable}{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\endfirsthead

\multicolumn{2}{c}{\sphinxnorowcolor
    \makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}%
}\\
\sphinxtoprule
\endhead

\sphinxbottomrule
\multicolumn{2}{r}{\sphinxnorowcolor
    \makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}%
}\\
\endfoot

\endlastfoot
\sphinxtableatstartofbodyhook

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{convert\_elec\_price\_to\_lut}}(prices)
&
\sphinxAtStartPar
convert electricity prices to dictionary, look up table
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{convert\_h2\_price\_records}}(records)
&
\sphinxAtStartPar
simple coversion from list of records to a dictionary LUT repeat entries should not occur and will generate an error
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{getLogger}}({[}name{]})
&
\sphinxAtStartPar
Return a logger with the specified name, creating it if necessary.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{get\_elec\_price}}(instance{[}, block{]})
&
\sphinxAtStartPar
pulls hourly electricity prices from completed PowerModel and de\sphinxhyphen{}weights them.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{init\_old\_cap}}(instance)
&
\sphinxAtStartPar
initialize capacity for 0th iteration
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{poll\_h2\_demand}}(model)
&
\sphinxAtStartPar
Get the hydrogen demand by rep\_year and region
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{poll\_hydrogen\_price}}(model{[}, block{]})
&
\sphinxAtStartPar
Retrieve the price of H2 from the H2 model
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{regional\_annual\_prices}}(m{[}, block{]})
&
\sphinxAtStartPar
pulls all regional annual weighted electricity prices
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{run\_elec\_model}}(settings{[}, solve{]})
&
\sphinxAtStartPar
build electricity model (and solve if solve=True) after passing in settings
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.integrator.unified:src.integrator.unified.run_unified}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{run\_unified}}}}}(settings)
&
\sphinxAtStartPar
Runs unified solve method based on
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{select\_solver}}(instance)
&
\sphinxAtStartPar
Select solver based on learning method
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{set\_new\_cap}}(instance)
&
\sphinxAtStartPar
calculate new capacity after solve iteration
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{simple\_solve}}(m)
&
\sphinxAtStartPar
a simple solve routine
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{simple\_solve\_no\_opt}}(m, opt)
&
\sphinxAtStartPar
Solve concrete model using solver factory object
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{update\_cost}}(instance)
&
\sphinxAtStartPar
update capital cost based on new capacity learning
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{update\_h2\_prices}}(model, h2\_prices)
&
\sphinxAtStartPar
Update the H2 prices held in the model
\\
\sphinxbottomrule
\end{longtable}
\sphinxtableafterendhook
\sphinxatlongtableend
\end{savenotes}
\subsubsection*{Classes}


\begin{savenotes}
\sphinxatlongtablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\makeatletter
  \LTleft \@totalleftmargin plus1fill
  \LTright\dimexpr\columnwidth-\@totalleftmargin-\linewidth\relax plus1fill
\makeatother
\begin{longtable}{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\endfirsthead

\multicolumn{2}{c}{\sphinxnorowcolor
    \makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}%
}\\
\sphinxtoprule
\endhead

\sphinxbottomrule
\multicolumn{2}{r}{\sphinxnorowcolor
    \makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}%
}\\
\endfoot

\endlastfoot
\sphinxtableatstartofbodyhook

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Config\_settings}}(config\_path{[}, args, test{]})
&
\sphinxAtStartPar
Generates the model settings that are used to solve.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{EI}}(region, year, hour)
&
\sphinxAtStartPar
(region, year, hour)
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{HI}}(region, year)
&
\sphinxAtStartPar
(region, year)
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{defaultdict}}
&
\sphinxAtStartPar
defaultdict(default\_factory=None, /, {[}...{]}) \sphinxhyphen{}\sphinxhyphen{}\textgreater{} dict with default factory
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{deque}}
&
\sphinxAtStartPar
deque({[}iterable{[}, maxlen{]}{]}) \sphinxhyphen{}\sphinxhyphen{}\textgreater{} deque object
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{residentialModule}}({[}settings, loadFile, ...{]})
&
\sphinxAtStartPar
This contains the Residential model and its associated functions.
\\
\sphinxbottomrule
\end{longtable}
\sphinxtableafterendhook
\sphinxatlongtableend
\end{savenotes}
\index{run\_unified() (in module src.integrator.unified)@\spxentry{run\_unified()}\spxextra{in module src.integrator.unified}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.integrator.unified:src.integrator.unified.run_unified}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{src.integrator.unified.}}\sphinxbfcode{\sphinxupquote{run\_unified}}}
{\sphinxparam{\DUrole{n}{settings}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{{\hyperref[\detokenize{src.common.config_setup:src.common.config_setup.Config_settings}]{\sphinxcrossref{Config\_settings}}}}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Runs unified solve method based on
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{settings}} ({\hyperref[\detokenize{src.common.config_setup:src.common.config_setup.Config_settings}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Config\_settings}}}}}) \textendash{} Instance of config\_settings containing run options, mode and settings

\end{description}\end{quote}

\end{fulllineitems}


\sphinxstepscope


\paragraph{src.integrator.utilities}
\label{\detokenize{src.integrator.utilities:module-src.integrator.utilities}}\label{\detokenize{src.integrator.utilities:src-integrator-utilities}}\label{\detokenize{src.integrator.utilities::doc}}\index{module@\spxentry{module}!src.integrator.utilities@\spxentry{src.integrator.utilities}}\index{src.integrator.utilities@\spxentry{src.integrator.utilities}!module@\spxentry{module}}
\sphinxAtStartPar
A gathering of utility functions for dealing with model interconnectivity

\sphinxAtStartPar
Dev Note:  At some review point, some decisions may move these back \& forth with parent
models after it is decided if it is a utility job to do …. or a class method.

\sphinxAtStartPar
Additionally, there is probably some renaming due here for consistency
\subsubsection*{Module Attributes}


\begin{savenotes}
\sphinxatlongtablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\makeatletter
  \LTleft \@totalleftmargin plus1fill
  \LTright\dimexpr\columnwidth-\@totalleftmargin-\linewidth\relax plus1fill
\makeatother
\begin{longtable}{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\endfirsthead

\multicolumn{2}{c}{\sphinxnorowcolor
    \makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}%
}\\
\sphinxtoprule
\endhead

\sphinxbottomrule
\multicolumn{2}{r}{\sphinxnorowcolor
    \makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}%
}\\
\endfoot

\endlastfoot
\sphinxtableatstartofbodyhook

\sphinxAtStartPar
{\hyperref[\detokenize{src.integrator.utilities:src.integrator.utilities.EI}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{EI}}}}}(region, year, hour)
&
\sphinxAtStartPar
(region, year, hour)
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.integrator.utilities:src.integrator.utilities.HI}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{HI}}}}}(region, year)
&
\sphinxAtStartPar
(region, year)
\\
\sphinxbottomrule
\end{longtable}
\sphinxtableafterendhook
\sphinxatlongtableend
\end{savenotes}
\subsubsection*{Functions}


\begin{savenotes}
\sphinxatlongtablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\makeatletter
  \LTleft \@totalleftmargin plus1fill
  \LTright\dimexpr\columnwidth-\@totalleftmargin-\linewidth\relax plus1fill
\makeatother
\begin{longtable}{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\endfirsthead

\multicolumn{2}{c}{\sphinxnorowcolor
    \makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}%
}\\
\sphinxtoprule
\endhead

\sphinxbottomrule
\multicolumn{2}{r}{\sphinxnorowcolor
    \makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}%
}\\
\endfoot

\endlastfoot
\sphinxtableatstartofbodyhook

\sphinxAtStartPar
{\hyperref[\detokenize{src.integrator.utilities:src.integrator.utilities.convert_elec_price_to_lut}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{convert\_elec\_price\_to\_lut}}}}}(prices)
&
\sphinxAtStartPar
convert electricity prices to dictionary, look up table
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.integrator.utilities:src.integrator.utilities.convert_h2_price_records}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{convert\_h2\_price\_records}}}}}(records)
&
\sphinxAtStartPar
simple coversion from list of records to a dictionary LUT repeat entries should not occur and will generate an error
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.integrator.utilities:src.integrator.utilities.create_temporal_mapping}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{create\_temporal\_mapping}}}}}(sw\_temporal)
&
\sphinxAtStartPar
Combines the input mapping files within the electricity model to create a master temporal mapping dataframe.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{getLogger}}({[}name{]})
&
\sphinxAtStartPar
Return a logger with the specified name, creating it if necessary.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.integrator.utilities:src.integrator.utilities.get_annual_wt_avg}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_annual\_wt\_avg}}}}}(elec\_price)
&
\sphinxAtStartPar
takes annual weighted average of hourly electricity prices
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.integrator.utilities:src.integrator.utilities.get_elec_price}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_elec\_price}}}}}(instance{[}, block{]})
&
\sphinxAtStartPar
pulls hourly electricity prices from completed PowerModel and de\sphinxhyphen{}weights them.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{namedtuple}}(typename, field\_names, *{[}, ...{]})
&
\sphinxAtStartPar
Returns a new subclass of tuple with named fields.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.integrator.utilities:src.integrator.utilities.poll_h2_demand}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{poll\_h2\_demand}}}}}(model)
&
\sphinxAtStartPar
Get the hydrogen demand by rep\_year and region
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.integrator.utilities:src.integrator.utilities.poll_h2_prices_from_elec}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{poll\_h2\_prices\_from\_elec}}}}}(model, tech, regions)
&
\sphinxAtStartPar
poll the step\sphinxhyphen{}1 H2 price currently in the model for region/year, averaged over any steps
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.integrator.utilities:src.integrator.utilities.poll_hydrogen_price}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{poll\_hydrogen\_price}}}}}(model{[}, block{]})
&
\sphinxAtStartPar
Retrieve the price of H2 from the H2 model
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.integrator.utilities:src.integrator.utilities.poll_year_avg_elec_price}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{poll\_year\_avg\_elec\_price}}}}}(price\_list)
&
\sphinxAtStartPar
retrieve a REPRESENTATIVE price at the annual level from a listing of prices
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.integrator.utilities:src.integrator.utilities.regional_annual_prices}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{regional\_annual\_prices}}}}}(m{[}, block{]})
&
\sphinxAtStartPar
pulls all regional annual weighted electricity prices
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.integrator.utilities:src.integrator.utilities.select_solver}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{select\_solver}}}}}(instance)
&
\sphinxAtStartPar
Select solver based on learning method
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.integrator.utilities:src.integrator.utilities.simple_solve}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{simple\_solve}}}}}(m)
&
\sphinxAtStartPar
a simple solve routine
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.integrator.utilities:src.integrator.utilities.simple_solve_no_opt}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{simple\_solve\_no\_opt}}}}}(m, opt)
&
\sphinxAtStartPar
Solve concrete model using solver factory object
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.integrator.utilities:src.integrator.utilities.update_elec_demand}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{update\_elec\_demand}}}}}(self, elec\_demand)
&
\sphinxAtStartPar
Update the external electical demand parameter with demands from the H2 model
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.integrator.utilities:src.integrator.utilities.update_h2_prices}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{update\_h2\_prices}}}}}(model, h2\_prices)
&
\sphinxAtStartPar
Update the H2 prices held in the model
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{value}}(obj{[}, exception{]})
&
\sphinxAtStartPar
A utility function that returns the value of a Pyomo object or expression.
\\
\sphinxbottomrule
\end{longtable}
\sphinxtableafterendhook
\sphinxatlongtableend
\end{savenotes}
\subsubsection*{Classes}


\begin{savenotes}
\sphinxatlongtablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\makeatletter
  \LTleft \@totalleftmargin plus1fill
  \LTright\dimexpr\columnwidth-\@totalleftmargin-\linewidth\relax plus1fill
\makeatother
\begin{longtable}{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\endfirsthead

\multicolumn{2}{c}{\sphinxnorowcolor
    \makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}%
}\\
\sphinxtoprule
\endhead

\sphinxbottomrule
\multicolumn{2}{r}{\sphinxnorowcolor
    \makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}%
}\\
\endfoot

\endlastfoot
\sphinxtableatstartofbodyhook

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ConcreteModel}}(*args, **kwds)
&
\sphinxAtStartPar
A concrete optimization model that does not defer construction of components.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.integrator.utilities:src.integrator.utilities.EI}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{EI}}}}}(region, year, hour)
&
\sphinxAtStartPar
(region, year, hour)
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.integrator.utilities:src.integrator.utilities.HI}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{HI}}}}}(region, year)
&
\sphinxAtStartPar
(region, year)
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Path}}(*args, **kwargs)
&
\sphinxAtStartPar
PurePath subclass that can make system calls.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{defaultdict}}
&
\sphinxAtStartPar
defaultdict(default\_factory=None, /, {[}...{]}) \sphinxhyphen{}\sphinxhyphen{}\textgreater{} dict with default factory
\\
\sphinxbottomrule
\end{longtable}
\sphinxtableafterendhook
\sphinxatlongtableend
\end{savenotes}
\index{EI (class in src.integrator.utilities)@\spxentry{EI}\spxextra{class in src.integrator.utilities}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.integrator.utilities:src.integrator.utilities.EI}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{\DUrole{k}{class}\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{src.integrator.utilities.}}\sphinxbfcode{\sphinxupquote{EI}}}
{\sphinxparam{\DUrole{n}{region}}\sphinxparamcomma \sphinxparam{\DUrole{n}{year}}\sphinxparamcomma \sphinxparam{\DUrole{n}{hour}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
(region, year, hour)
\index{\_asdict() (src.integrator.utilities.EI method)@\spxentry{\_asdict()}\spxextra{src.integrator.utilities.EI method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.integrator.utilities:src.integrator.utilities.EI._asdict}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{\_asdict}}}
{}
{}
\pysigstopsignatures
\sphinxAtStartPar
Return a new dict which maps field names to their values.

\end{fulllineitems}

\index{\_field\_defaults (src.integrator.utilities.EI attribute)@\spxentry{\_field\_defaults}\spxextra{src.integrator.utilities.EI attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.integrator.utilities:src.integrator.utilities.EI._field_defaults}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{\_field\_defaults}}\sphinxbfcode{\sphinxupquote{\DUrole{w}{ }\DUrole{p}{=}\DUrole{w}{ }\{\}}}}
\pysigstopsignatures
\end{fulllineitems}

\index{\_fields (src.integrator.utilities.EI attribute)@\spxentry{\_fields}\spxextra{src.integrator.utilities.EI attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.integrator.utilities:src.integrator.utilities.EI._fields}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{\_fields}}\sphinxbfcode{\sphinxupquote{\DUrole{w}{ }\DUrole{p}{=}\DUrole{w}{ }(\textquotesingle{}region\textquotesingle{}, \textquotesingle{}year\textquotesingle{}, \textquotesingle{}hour\textquotesingle{})}}}
\pysigstopsignatures
\end{fulllineitems}

\index{\_make() (src.integrator.utilities.EI class method)@\spxentry{\_make()}\spxextra{src.integrator.utilities.EI class method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.integrator.utilities:src.integrator.utilities.EI._make}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{\DUrole{k}{classmethod}\DUrole{w}{ }}}\sphinxbfcode{\sphinxupquote{\_make}}}
{\sphinxparam{\DUrole{n}{iterable}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Make a new EI object from a sequence or iterable

\end{fulllineitems}

\index{\_replace() (src.integrator.utilities.EI method)@\spxentry{\_replace()}\spxextra{src.integrator.utilities.EI method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.integrator.utilities:src.integrator.utilities.EI._replace}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{\_replace}}}
{\sphinxparam{\DUrole{o}{**}\DUrole{n}{kwds}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Return a new EI object replacing specified fields with new values

\end{fulllineitems}

\index{hour (src.integrator.utilities.EI attribute)@\spxentry{hour}\spxextra{src.integrator.utilities.EI attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.integrator.utilities:src.integrator.utilities.EI.hour}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{hour}}}
\pysigstopsignatures
\sphinxAtStartPar
Alias for field number 2

\end{fulllineitems}

\index{region (src.integrator.utilities.EI attribute)@\spxentry{region}\spxextra{src.integrator.utilities.EI attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.integrator.utilities:src.integrator.utilities.EI.region}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{region}}}
\pysigstopsignatures
\sphinxAtStartPar
Alias for field number 0

\end{fulllineitems}

\index{year (src.integrator.utilities.EI attribute)@\spxentry{year}\spxextra{src.integrator.utilities.EI attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.integrator.utilities:src.integrator.utilities.EI.year}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{year}}}
\pysigstopsignatures
\sphinxAtStartPar
Alias for field number 1

\end{fulllineitems}


\end{fulllineitems}

\index{HI (class in src.integrator.utilities)@\spxentry{HI}\spxextra{class in src.integrator.utilities}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.integrator.utilities:src.integrator.utilities.HI}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{\DUrole{k}{class}\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{src.integrator.utilities.}}\sphinxbfcode{\sphinxupquote{HI}}}
{\sphinxparam{\DUrole{n}{region}}\sphinxparamcomma \sphinxparam{\DUrole{n}{year}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
(region, year)
\index{\_asdict() (src.integrator.utilities.HI method)@\spxentry{\_asdict()}\spxextra{src.integrator.utilities.HI method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.integrator.utilities:src.integrator.utilities.HI._asdict}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{\_asdict}}}
{}
{}
\pysigstopsignatures
\sphinxAtStartPar
Return a new dict which maps field names to their values.

\end{fulllineitems}

\index{\_field\_defaults (src.integrator.utilities.HI attribute)@\spxentry{\_field\_defaults}\spxextra{src.integrator.utilities.HI attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.integrator.utilities:src.integrator.utilities.HI._field_defaults}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{\_field\_defaults}}\sphinxbfcode{\sphinxupquote{\DUrole{w}{ }\DUrole{p}{=}\DUrole{w}{ }\{\}}}}
\pysigstopsignatures
\end{fulllineitems}

\index{\_fields (src.integrator.utilities.HI attribute)@\spxentry{\_fields}\spxextra{src.integrator.utilities.HI attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.integrator.utilities:src.integrator.utilities.HI._fields}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{\_fields}}\sphinxbfcode{\sphinxupquote{\DUrole{w}{ }\DUrole{p}{=}\DUrole{w}{ }(\textquotesingle{}region\textquotesingle{}, \textquotesingle{}year\textquotesingle{})}}}
\pysigstopsignatures
\end{fulllineitems}

\index{\_make() (src.integrator.utilities.HI class method)@\spxentry{\_make()}\spxextra{src.integrator.utilities.HI class method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.integrator.utilities:src.integrator.utilities.HI._make}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{\DUrole{k}{classmethod}\DUrole{w}{ }}}\sphinxbfcode{\sphinxupquote{\_make}}}
{\sphinxparam{\DUrole{n}{iterable}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Make a new HI object from a sequence or iterable

\end{fulllineitems}

\index{\_replace() (src.integrator.utilities.HI method)@\spxentry{\_replace()}\spxextra{src.integrator.utilities.HI method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.integrator.utilities:src.integrator.utilities.HI._replace}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{\_replace}}}
{\sphinxparam{\DUrole{o}{**}\DUrole{n}{kwds}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Return a new HI object replacing specified fields with new values

\end{fulllineitems}

\index{region (src.integrator.utilities.HI attribute)@\spxentry{region}\spxextra{src.integrator.utilities.HI attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.integrator.utilities:src.integrator.utilities.HI.region}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{region}}}
\pysigstopsignatures
\sphinxAtStartPar
Alias for field number 0

\end{fulllineitems}

\index{year (src.integrator.utilities.HI attribute)@\spxentry{year}\spxextra{src.integrator.utilities.HI attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.integrator.utilities:src.integrator.utilities.HI.year}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{year}}}
\pysigstopsignatures
\sphinxAtStartPar
Alias for field number 1

\end{fulllineitems}


\end{fulllineitems}

\index{convert\_elec\_price\_to\_lut() (in module src.integrator.utilities)@\spxentry{convert\_elec\_price\_to\_lut()}\spxextra{in module src.integrator.utilities}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.integrator.utilities:src.integrator.utilities.convert_elec_price_to_lut}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{src.integrator.utilities.}}\sphinxbfcode{\sphinxupquote{convert\_elec\_price\_to\_lut}}}
{\sphinxparam{\DUrole{n}{prices}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{list\DUrole{p}{{[}}tuple\DUrole{p}{{[}}{\hyperref[\detokenize{src.integrator.utilities:src.integrator.utilities.EI}]{\sphinxcrossref{EI}}}\DUrole{p}{,}\DUrole{w}{ }float\DUrole{p}{{]}}\DUrole{p}{{]}}}}}
{{ $\rightarrow$ dict\DUrole{p}{{[}}{\hyperref[\detokenize{src.integrator.utilities:src.integrator.utilities.EI}]{\sphinxcrossref{EI}}}\DUrole{p}{,}\DUrole{w}{ }float\DUrole{p}{{]}}}}
\pysigstopsignatures
\sphinxAtStartPar
convert electricity prices to dictionary, look up table
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{prices}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{tuple}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}{\hyperref[\detokenize{src.integrator.utilities:src.integrator.utilities.EI}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{EI}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} list of prices

\sphinxlineitem{Returns}
\sphinxAtStartPar
dict of prices

\sphinxlineitem{Return type}
\sphinxAtStartPar
dict{[}{\hyperref[\detokenize{src.integrator.utilities:src.integrator.utilities.EI}]{\sphinxcrossref{EI}}}, float{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{convert\_h2\_price\_records() (in module src.integrator.utilities)@\spxentry{convert\_h2\_price\_records()}\spxextra{in module src.integrator.utilities}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.integrator.utilities:src.integrator.utilities.convert_h2_price_records}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{src.integrator.utilities.}}\sphinxbfcode{\sphinxupquote{convert\_h2\_price\_records}}}
{\sphinxparam{\DUrole{n}{records}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{list\DUrole{p}{{[}}tuple\DUrole{p}{{[}}{\hyperref[\detokenize{src.integrator.utilities:src.integrator.utilities.HI}]{\sphinxcrossref{HI}}}\DUrole{p}{,}\DUrole{w}{ }float\DUrole{p}{{]}}\DUrole{p}{{]}}}}}
{{ $\rightarrow$ dict\DUrole{p}{{[}}{\hyperref[\detokenize{src.integrator.utilities:src.integrator.utilities.HI}]{\sphinxcrossref{HI}}}\DUrole{p}{,}\DUrole{w}{ }float\DUrole{p}{{]}}}}
\pysigstopsignatures
\sphinxAtStartPar
simple coversion from list of records to a dictionary LUT
repeat entries should not occur and will generate an error

\end{fulllineitems}

\index{create\_temporal\_mapping() (in module src.integrator.utilities)@\spxentry{create\_temporal\_mapping()}\spxextra{in module src.integrator.utilities}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.integrator.utilities:src.integrator.utilities.create_temporal_mapping}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{src.integrator.utilities.}}\sphinxbfcode{\sphinxupquote{create\_temporal\_mapping}}}
{\sphinxparam{\DUrole{n}{sw\_temporal}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Combines the input mapping files within the electricity model to create a master temporal
mapping dataframe. The df is used to build multiple temporal parameters used within the  model.
It creates a single dataframe that has 8760 rows for each hour in the year.
Each hour in the year is assigned a season type, day type, and hour type used in the model.
This defines the number of time periods the model will use based on cw\_s\_day and cw\_hr inputs.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
a dataframe with 8760 rows that include each hour, hour type, day, day type, and season.
It also includes the weights for each day type and hour type.

\sphinxlineitem{Return type}
\sphinxAtStartPar
dataframe

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_annual\_wt\_avg() (in module src.integrator.utilities)@\spxentry{get\_annual\_wt\_avg()}\spxextra{in module src.integrator.utilities}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.integrator.utilities:src.integrator.utilities.get_annual_wt_avg}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{src.integrator.utilities.}}\sphinxbfcode{\sphinxupquote{get\_annual\_wt\_avg}}}
{\sphinxparam{\DUrole{n}{elec\_price}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{DataFrame}}}
{{ $\rightarrow$ dict\DUrole{p}{{[}}{\hyperref[\detokenize{src.integrator.utilities:src.integrator.utilities.HI}]{\sphinxcrossref{HI}}}\DUrole{p}{,}\DUrole{w}{ }float\DUrole{p}{{]}}}}
\pysigstopsignatures
\sphinxAtStartPar
takes annual weighted average of hourly electricity prices
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{elec\_price}} (\sphinxstyleliteralemphasis{\sphinxupquote{pd.DataFrame}}) \textendash{} hourly electricity prices

\sphinxlineitem{Returns}
\sphinxAtStartPar
annual weighted average electricity prices

\sphinxlineitem{Return type}
\sphinxAtStartPar
dict{[}{\hyperref[\detokenize{src.integrator.utilities:src.integrator.utilities.HI}]{\sphinxcrossref{HI}}}, float{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_elec\_price() (in module src.integrator.utilities)@\spxentry{get\_elec\_price()}\spxextra{in module src.integrator.utilities}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.integrator.utilities:src.integrator.utilities.get_elec_price}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{src.integrator.utilities.}}\sphinxbfcode{\sphinxupquote{get\_elec\_price}}}
{\sphinxparam{\DUrole{n}{instance}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{{\hyperref[\detokenize{src.models.electricity.scripts.electricity_model:src.models.electricity.scripts.electricity_model.PowerModel}]{\sphinxcrossref{PowerModel}}}\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }ConcreteModel}}\sphinxparamcomma \sphinxparam{\DUrole{n}{block}\DUrole{o}{=}\DUrole{default_value}{None}}}
{{ $\rightarrow$ DataFrame}}
\pysigstopsignatures
\sphinxAtStartPar
pulls hourly electricity prices from completed PowerModel and de\sphinxhyphen{}weights them.

\sphinxAtStartPar
Prices from the duals are weighted by the day and year weights applied in the OBJ function
This function retrieves the prices for all hours and removes the day and annual weights to
return raw prices (and the day weights to use as needed)
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{instance}} ({\hyperref[\detokenize{src.models.electricity.scripts.electricity_model:src.models.electricity.scripts.electricity_model.PowerModel}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{PowerModel}}}}}) \textendash{} solved electricity model

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{block}} (\sphinxstyleliteralemphasis{\sphinxupquote{ConcreteModel}}) \textendash{} reference to the block if the electricity model is a block within a larger model

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
df of raw prices and the day weights to re\sphinxhyphen{}apply (if needed)
columns: {[}r, y, hour, day\_weight, raw\_price{]}

\sphinxlineitem{Return type}
\sphinxAtStartPar
pd.DataFrame

\end{description}\end{quote}

\end{fulllineitems}

\index{poll\_h2\_demand() (in module src.integrator.utilities)@\spxentry{poll\_h2\_demand()}\spxextra{in module src.integrator.utilities}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.integrator.utilities:src.integrator.utilities.poll_h2_demand}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{src.integrator.utilities.}}\sphinxbfcode{\sphinxupquote{poll\_h2\_demand}}}
{\sphinxparam{\DUrole{n}{model}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{{\hyperref[\detokenize{src.models.electricity.scripts.electricity_model:src.models.electricity.scripts.electricity_model.PowerModel}]{\sphinxcrossref{PowerModel}}}}}}
{{ $\rightarrow$ dict\DUrole{p}{{[}}{\hyperref[\detokenize{src.integrator.utilities:src.integrator.utilities.HI}]{\sphinxcrossref{HI}}}\DUrole{p}{,}\DUrole{w}{ }float\DUrole{p}{{]}}}}
\pysigstopsignatures
\sphinxAtStartPar
Get the hydrogen demand by rep\_year and region

\sphinxAtStartPar
Use the Generation variable for h2 techs

\sphinxAtStartPar
NOTE:  Not sure about day weighting calculation here!!
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
dictionary of prices by H2 Index: price

\sphinxlineitem{Return type}
\sphinxAtStartPar
dict{[}{\hyperref[\detokenize{src.integrator.utilities:src.integrator.utilities.HI}]{\sphinxcrossref{HI}}}, float{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{poll\_h2\_prices\_from\_elec() (in module src.integrator.utilities)@\spxentry{poll\_h2\_prices\_from\_elec()}\spxextra{in module src.integrator.utilities}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.integrator.utilities:src.integrator.utilities.poll_h2_prices_from_elec}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{src.integrator.utilities.}}\sphinxbfcode{\sphinxupquote{poll\_h2\_prices\_from\_elec}}}
{\sphinxparam{\DUrole{n}{model}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{{\hyperref[\detokenize{src.models.electricity.scripts.electricity_model:src.models.electricity.scripts.electricity_model.PowerModel}]{\sphinxcrossref{PowerModel}}}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{tech}}\sphinxparamcomma \sphinxparam{\DUrole{n}{regions}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{Iterable}}}
{{ $\rightarrow$ dict\DUrole{p}{{[}}Any\DUrole{p}{,}\DUrole{w}{ }float\DUrole{p}{{]}}}}
\pysigstopsignatures
\sphinxAtStartPar
poll the step\sphinxhyphen{}1 H2 price currently in the model for region/year, averaged over any steps
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{model}} ({\hyperref[\detokenize{src.models.electricity.scripts.electricity_model:src.models.electricity.scripts.electricity_model.PowerModel}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{PowerModel}}}}}) \textendash{} solved PowerModel

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{tech}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} h2 tech

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{regions}} (\sphinxstyleliteralemphasis{\sphinxupquote{Iterable}})

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
a dictionary of (region, seasons, year): price

\sphinxlineitem{Return type}
\sphinxAtStartPar
dict{[}\sphinxstyleemphasis{Any}, float{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{poll\_hydrogen\_price() (in module src.integrator.utilities)@\spxentry{poll\_hydrogen\_price()}\spxextra{in module src.integrator.utilities}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.integrator.utilities:src.integrator.utilities.poll_hydrogen_price}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{src.integrator.utilities.}}\sphinxbfcode{\sphinxupquote{poll\_hydrogen\_price}}}
{\sphinxparam{\DUrole{n}{model}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{{\hyperref[\detokenize{src.models.hydrogen.model.h2_model:src.models.hydrogen.model.h2_model.H2Model}]{\sphinxcrossref{H2Model}}}\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }ConcreteModel}}\sphinxparamcomma \sphinxparam{\DUrole{n}{block}\DUrole{o}{=}\DUrole{default_value}{None}}}
{{ $\rightarrow$ list\DUrole{p}{{[}}tuple\DUrole{p}{{[}}{\hyperref[\detokenize{src.integrator.utilities:src.integrator.utilities.HI}]{\sphinxcrossref{HI}}}\DUrole{p}{,}\DUrole{w}{ }float\DUrole{p}{{]}}\DUrole{p}{{]}}}}
\pysigstopsignatures
\sphinxAtStartPar
Retrieve the price of H2 from the H2 model
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{model}} ({\hyperref[\detokenize{src.models.hydrogen.model.h2_model:src.models.hydrogen.model.h2_model.H2Model}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{H2Model}}}}}) \textendash{} the model to poll

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{block}} (\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} block model to poll

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
list of H2 Index, price tuples

\sphinxlineitem{Return type}
\sphinxAtStartPar
list{[}tuple{[}{\hyperref[\detokenize{src.integrator.utilities:src.integrator.utilities.HI}]{\sphinxcrossref{HI}}}, float{]}{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{poll\_year\_avg\_elec\_price() (in module src.integrator.utilities)@\spxentry{poll\_year\_avg\_elec\_price()}\spxextra{in module src.integrator.utilities}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.integrator.utilities:src.integrator.utilities.poll_year_avg_elec_price}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{src.integrator.utilities.}}\sphinxbfcode{\sphinxupquote{poll\_year\_avg\_elec\_price}}}
{\sphinxparam{\DUrole{n}{price\_list}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{list\DUrole{p}{{[}}tuple\DUrole{p}{{[}}{\hyperref[\detokenize{src.integrator.utilities:src.integrator.utilities.EI}]{\sphinxcrossref{EI}}}\DUrole{p}{,}\DUrole{w}{ }float\DUrole{p}{{]}}\DUrole{p}{{]}}}}}
{{ $\rightarrow$ dict\DUrole{p}{{[}}{\hyperref[\detokenize{src.integrator.utilities:src.integrator.utilities.HI}]{\sphinxcrossref{HI}}}\DUrole{p}{,}\DUrole{w}{ }float\DUrole{p}{{]}}}}
\pysigstopsignatures
\sphinxAtStartPar
retrieve a REPRESENTATIVE price at the annual level from a listing of prices

\sphinxAtStartPar
This function computes the AVERAGE elec price for each region\sphinxhyphen{}year combo
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{price\_list}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{tuple}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}{\hyperref[\detokenize{src.integrator.utilities:src.integrator.utilities.EI}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{EI}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} input price list

\sphinxlineitem{Returns}
\sphinxAtStartPar
a dictionary of (region, year): price

\sphinxlineitem{Return type}
\sphinxAtStartPar
dict{[}{\hyperref[\detokenize{src.integrator.utilities:src.integrator.utilities.HI}]{\sphinxcrossref{HI}}}, float{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{regional\_annual\_prices() (in module src.integrator.utilities)@\spxentry{regional\_annual\_prices()}\spxextra{in module src.integrator.utilities}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.integrator.utilities:src.integrator.utilities.regional_annual_prices}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{src.integrator.utilities.}}\sphinxbfcode{\sphinxupquote{regional\_annual\_prices}}}
{\sphinxparam{\DUrole{n}{m}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{{\hyperref[\detokenize{src.models.electricity.scripts.electricity_model:src.models.electricity.scripts.electricity_model.PowerModel}]{\sphinxcrossref{PowerModel}}}\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }ConcreteModel}}\sphinxparamcomma \sphinxparam{\DUrole{n}{block}\DUrole{o}{=}\DUrole{default_value}{None}}}
{{ $\rightarrow$ dict\DUrole{p}{{[}}{\hyperref[\detokenize{src.integrator.utilities:src.integrator.utilities.HI}]{\sphinxcrossref{HI}}}\DUrole{p}{,}\DUrole{w}{ }float\DUrole{p}{{]}}}}
\pysigstopsignatures
\sphinxAtStartPar
pulls all regional annual weighted electricity prices
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{m}} (\sphinxstyleliteralemphasis{\sphinxupquote{Union}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{\textquotesingle{}PowerModel\textquotesingle{}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{ConcreteModel}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} solved PowerModel

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{block}} (\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} solved block model if applicable, by default None

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
dict with regional annual electricity prices

\sphinxlineitem{Return type}
\sphinxAtStartPar
dict{[}{\hyperref[\detokenize{src.integrator.utilities:src.integrator.utilities.HI}]{\sphinxcrossref{HI}}}, float{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{select\_solver() (in module src.integrator.utilities)@\spxentry{select\_solver()}\spxextra{in module src.integrator.utilities}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.integrator.utilities:src.integrator.utilities.select_solver}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{src.integrator.utilities.}}\sphinxbfcode{\sphinxupquote{select\_solver}}}
{\sphinxparam{\DUrole{n}{instance}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{ConcreteModel}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Select solver based on learning method
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{instance}} ({\hyperref[\detokenize{src.models.electricity.scripts.electricity_model:src.models.electricity.scripts.electricity_model.PowerModel}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{PowerModel}}}}}) \textendash{} electricity pyomo model

\sphinxlineitem{Returns}
\sphinxAtStartPar
The pyomo solver

\sphinxlineitem{Return type}
\sphinxAtStartPar
solver type (?)

\end{description}\end{quote}

\end{fulllineitems}

\index{simple\_solve() (in module src.integrator.utilities)@\spxentry{simple\_solve()}\spxextra{in module src.integrator.utilities}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.integrator.utilities:src.integrator.utilities.simple_solve}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{src.integrator.utilities.}}\sphinxbfcode{\sphinxupquote{simple\_solve}}}
{\sphinxparam{\DUrole{n}{m}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{ConcreteModel}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
a simple solve routine

\end{fulllineitems}

\index{simple\_solve\_no\_opt() (in module src.integrator.utilities)@\spxentry{simple\_solve\_no\_opt()}\spxextra{in module src.integrator.utilities}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.integrator.utilities:src.integrator.utilities.simple_solve_no_opt}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{src.integrator.utilities.}}\sphinxbfcode{\sphinxupquote{simple\_solve\_no\_opt}}}
{\sphinxparam{\DUrole{n}{m: \textasciitilde{}pyomo.core.base.PyomoModel.ConcreteModel}}\sphinxparamcomma \sphinxparam{\DUrole{n}{opt: \textless{}pyomo.opt.base.solvers.SolverFactoryClass object at 0x00000241DC23D880\textgreater{}}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Solve concrete model using solver factory object
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{m}} (\sphinxstyleliteralemphasis{\sphinxupquote{ConcreteModel}}) \textendash{} Pyomo model

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{opt}} (\sphinxstyleliteralemphasis{\sphinxupquote{SolverFactory}}) \textendash{} Solver object initiated prior to solve

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{update\_elec\_demand() (in module src.integrator.utilities)@\spxentry{update\_elec\_demand()}\spxextra{in module src.integrator.utilities}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.integrator.utilities:src.integrator.utilities.update_elec_demand}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{src.integrator.utilities.}}\sphinxbfcode{\sphinxupquote{update\_elec\_demand}}}
{\sphinxparam{\DUrole{n}{self}}\sphinxparamcomma \sphinxparam{\DUrole{n}{elec\_demand}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{dict\DUrole{p}{{[}}{\hyperref[\detokenize{src.integrator.utilities:src.integrator.utilities.HI}]{\sphinxcrossref{HI}}}\DUrole{p}{,}\DUrole{w}{ }float\DUrole{p}{{]}}}}}
{{ $\rightarrow$ None}}
\pysigstopsignatures
\sphinxAtStartPar
Update the external electical demand parameter with demands from the H2 model
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{elec\_demand}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}{\hyperref[\detokenize{src.integrator.utilities:src.integrator.utilities.HI}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{HI}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} the new demands broken out by hyd index (region, year)

\end{description}\end{quote}

\end{fulllineitems}

\index{update\_h2\_prices() (in module src.integrator.utilities)@\spxentry{update\_h2\_prices()}\spxextra{in module src.integrator.utilities}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.integrator.utilities:src.integrator.utilities.update_h2_prices}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{src.integrator.utilities.}}\sphinxbfcode{\sphinxupquote{update\_h2\_prices}}}
{\sphinxparam{\DUrole{n}{model}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{{\hyperref[\detokenize{src.models.electricity.scripts.electricity_model:src.models.electricity.scripts.electricity_model.PowerModel}]{\sphinxcrossref{PowerModel}}}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{h2\_prices}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{dict\DUrole{p}{{[}}{\hyperref[\detokenize{src.integrator.utilities:src.integrator.utilities.HI}]{\sphinxcrossref{HI}}}\DUrole{p}{,}\DUrole{w}{ }float\DUrole{p}{{]}}}}}
{{ $\rightarrow$ None}}
\pysigstopsignatures
\sphinxAtStartPar
Update the H2 prices held in the model
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{h2\_prices}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{tuple}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}{\hyperref[\detokenize{src.integrator.utilities:src.integrator.utilities.HI}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{HI}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} new prices

\end{description}\end{quote}

\end{fulllineitems}


\sphinxstepscope


\subsubsection{src.sensitivity}
\label{\detokenize{src.sensitivity:module-src.sensitivity}}\label{\detokenize{src.sensitivity:src-sensitivity}}\label{\detokenize{src.sensitivity::doc}}\index{module@\spxentry{module}!src.sensitivity@\spxentry{src.sensitivity}}\index{src.sensitivity@\spxentry{src.sensitivity}!module@\spxentry{module}}\subsubsection*{Modules}


\begin{savenotes}
\sphinxatlongtablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\makeatletter
  \LTleft \@totalleftmargin plus1fill
  \LTright\dimexpr\columnwidth-\@totalleftmargin-\linewidth\relax plus1fill
\makeatother
\begin{longtable}{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\endfirsthead

\multicolumn{2}{c}{\sphinxnorowcolor
    \makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}%
}\\
\sphinxtoprule
\endhead

\sphinxbottomrule
\multicolumn{2}{r}{\sphinxnorowcolor
    \makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}%
}\\
\endfoot

\endlastfoot
\sphinxtableatstartofbodyhook

\sphinxAtStartPar
{\hyperref[\detokenize{src.sensitivity.babymodel:module-src.sensitivity.babymodel}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{babymodel}}}}}
&
\sphinxAtStartPar
Baby Model This file contains the TestBabyModel class, which is a subclass of ConcreteModel, along with scripts that help generate the model parameters and structure.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.sensitivity.faster_sensitivity:module-src.sensitivity.faster_sensitivity}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{faster\_sensitivity}}}}}
&
\sphinxAtStartPar
faster\_sensitivity
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.sensitivity.sensitivity_tools:module-src.sensitivity.sensitivity_tools}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{sensitivity\_tools}}}}}
&
\sphinxAtStartPar
Sensitivity Tools This file contains the AutoSympy, SensitivityMatrix, CoordMap, and DifferentialMapping classes.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.sensitivity.speed_test:module-src.sensitivity.speed_test}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{speed\_test}}}}}
&
\sphinxAtStartPar
Speed Test This is a script with some functions to run speed and accuracy tests on test models constructed with babymodel.
\\
\sphinxbottomrule
\end{longtable}
\sphinxtableafterendhook
\sphinxatlongtableend
\end{savenotes}

\sphinxstepscope


\paragraph{src.sensitivity.babymodel}
\label{\detokenize{src.sensitivity.babymodel:module-src.sensitivity.babymodel}}\label{\detokenize{src.sensitivity.babymodel:src-sensitivity-babymodel}}\label{\detokenize{src.sensitivity.babymodel::doc}}\index{module@\spxentry{module}!src.sensitivity.babymodel@\spxentry{src.sensitivity.babymodel}}\index{src.sensitivity.babymodel@\spxentry{src.sensitivity.babymodel}!module@\spxentry{module}}
\sphinxAtStartPar
Baby Model
This file contains the TestBabyModel class, which is a subclass of ConcreteModel, along with scripts that
help generate the model parameters and structure.

\sphinxAtStartPar
The model structure is randomly generated through the functions generate and connect\_subregions, with
model parameters as input.
\subsubsection*{Functions}


\begin{savenotes}
\sphinxatlongtablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\makeatletter
  \LTleft \@totalleftmargin plus1fill
  \LTright\dimexpr\columnwidth-\@totalleftmargin-\linewidth\relax plus1fill
\makeatother
\begin{longtable}{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\endfirsthead

\multicolumn{2}{c}{\sphinxnorowcolor
    \makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}%
}\\
\sphinxtoprule
\endhead

\sphinxbottomrule
\multicolumn{2}{r}{\sphinxnorowcolor
    \makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}%
}\\
\endfoot

\endlastfoot
\sphinxtableatstartofbodyhook

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{E1}}(z)
&
\sphinxAtStartPar
Classical case of the generalized exponential integral.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Eijk}}(*args, **kwargs)
&
\sphinxAtStartPar
Represent the Levi\sphinxhyphen{}Civita symbol.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{GramSchmidt}}(vlist{[}, orthonormal{]})
&
\sphinxAtStartPar
Apply the Gram\sphinxhyphen{}Schmidt process to a set of vectors.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{LC}}(f, *gens, **args)
&
\sphinxAtStartPar
Return the leading coefficient of \sphinxcode{\sphinxupquote{f}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{LM}}(f, *gens, **args)
&
\sphinxAtStartPar
Return the leading monomial of \sphinxcode{\sphinxupquote{f}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{LT}}(f, *gens, **args)
&
\sphinxAtStartPar
Return the leading term of \sphinxcode{\sphinxupquote{f}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{N}}(x{[}, n{]})
&
\sphinxAtStartPar
Calls x.evalf(n, **options).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{POSform}}(variables, minterms{[}, dontcares{]})
&
\sphinxAtStartPar
The POSform function uses simplified\_pairs and a redundant\sphinxhyphen{}group eliminating algorithm to convert the list of all input combinations that generate \textquotesingle{}1\textquotesingle{} (the minterms) into the smallest product\sphinxhyphen{}of\sphinxhyphen{}sums form.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SOPform}}(variables, minterms{[}, dontcares{]})
&
\sphinxAtStartPar
The SOPform function uses simplified\_pairs and a redundant group\sphinxhyphen{} eliminating algorithm to convert the list of all input combos that generate \textquotesingle{}1\textquotesingle{} (the minterms) into the smallest sum\sphinxhyphen{}of\sphinxhyphen{}products form.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Ynm\_c}}(n, m, theta, phi)
&
\sphinxAtStartPar
Conjugate spherical harmonics defined as
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{abundance}}(n)
&
\sphinxAtStartPar
Returns the difference between the sum of the positive proper divisors of a number and the number.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{apart}}(f{[}, x, full{]})
&
\sphinxAtStartPar
Compute partial fraction decomposition of a rational function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{apart\_list}}(f{[}, x, dummies{]})
&
\sphinxAtStartPar
Compute partial fraction decomposition of a rational function and return the result in structured form.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{apply\_finite\_diff}}(order, x\_list, y\_list{[}, x0{]})
&
\sphinxAtStartPar
Calculates the finite difference approximation of the derivative of requested order at \sphinxcode{\sphinxupquote{x0}} from points provided in \sphinxcode{\sphinxupquote{x\_list}} and \sphinxcode{\sphinxupquote{y\_list}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{approximants}}(l{[}, X, simplify{]})
&
\sphinxAtStartPar
Return a generator for consecutive Pade approximants for a series.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{are\_similar}}(e1, e2)
&
\sphinxAtStartPar
Are two geometrical entities similar.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{arity}}(cls)
&
\sphinxAtStartPar
Return the arity of the function if it is known, else None.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ask}}(proposition{[}, assumptions, context{]})
&
\sphinxAtStartPar
Function to evaluate the proposition with assumptions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{assemble\_partfrac\_list}}(partial\_list)
&
\sphinxAtStartPar
Reassemble a full partial fraction decomposition from a structured result obtained by the function \sphinxcode{\sphinxupquote{apart\_list}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{assuming}}(*assumptions)
&
\sphinxAtStartPar
Context manager for assumptions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{banded}}(*args, **kwargs)
&
\sphinxAtStartPar
Returns a SparseMatrix from the given dictionary describing the diagonals of the matrix.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{besselsimp}}(expr)
&
\sphinxAtStartPar
Simplify bessel\sphinxhyphen{}type functions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{binomial\_coefficients}}(n)
&
\sphinxAtStartPar
Return a dictionary containing pairs \({(k1,k2) : C_kn}\) where \(C_kn\) are binomial coefficients and \(n=k1+k2\).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{binomial\_coefficients\_list}}(n)
&
\sphinxAtStartPar
Return a list of binomial coefficients as rows of the Pascal\textquotesingle{}s triangle.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{block\_collapse}}(expr)
&
\sphinxAtStartPar
Evaluates a block matrix expression
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{blockcut}}(expr, rowsizes, colsizes)
&
\sphinxAtStartPar
Cut a matrix expression into Blocks
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{bool\_map}}(bool1, bool2)
&
\sphinxAtStartPar
Return the simplified version of \sphinxstyleemphasis{bool1}, and the mapping of variables that makes the two expressions \sphinxstyleemphasis{bool1} and \sphinxstyleemphasis{bool2} represent the same logical behaviour for some correspondence between the variables of each.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{bottom\_up}}(rv, F{[}, atoms, nonbasic{]})
&
\sphinxAtStartPar
Apply \sphinxcode{\sphinxupquote{F}} to all expressions in an expression tree from the bottom up.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{bspline\_basis}}(d, knots, n, x)
&
\sphinxAtStartPar
The \$n\$\sphinxhyphen{}th B\sphinxhyphen{}spline at \$x\$ of degree \$d\$ with knots.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{bspline\_basis\_set}}(d, knots, x)
&
\sphinxAtStartPar
Return the \sphinxcode{\sphinxupquote{len(knots)\sphinxhyphen{}d\sphinxhyphen{}1}} B\sphinxhyphen{}splines at \sphinxstyleemphasis{x} of degree \sphinxstyleemphasis{d} with \sphinxstyleemphasis{knots}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{cacheit}}(func)
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{cancel}}(f, *gens{[}, \_signsimp{]})
&
\sphinxAtStartPar
Cancel common factors in a rational function \sphinxcode{\sphinxupquote{f}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{capture}}(func)
&
\sphinxAtStartPar
Return the printed output of func().
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{casoratian}}(seqs, n{[}, zero{]})
&
\sphinxAtStartPar
Given linear difference operator L of order \textquotesingle{}k\textquotesingle{} and homogeneous equation Ly = 0 we want to compute kernel of L, which is a set of \textquotesingle{}k\textquotesingle{} sequences: a(n), b(n), .
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{cbrt}}(arg{[}, evaluate{]})
&
\sphinxAtStartPar
Returns the principal cube root.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ccode}}(expr{[}, assign\_to, standard{]})
&
\sphinxAtStartPar
Converts an expr to a string of c code
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{centroid}}(*args)
&
\sphinxAtStartPar
Find the centroid (center of mass) of the collection containing only Points, Segments or Polygons.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{chebyshevt\_poly}}(n{[}, x, polys{]})
&
\sphinxAtStartPar
Generates the Chebyshev polynomial of the first kind \sphinxtitleref{T\_n(x)}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{chebyshevu\_poly}}(n{[}, x, polys{]})
&
\sphinxAtStartPar
Generates the Chebyshev polynomial of the second kind \sphinxtitleref{U\_n(x)}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{check\_assumptions}}(expr{[}, against{]})
&
\sphinxAtStartPar
Checks whether assumptions of \sphinxcode{\sphinxupquote{expr}} match the T/F assumptions given (or possessed by \sphinxcode{\sphinxupquote{against}}).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{checkodesol}}(ode, sol{[}, func, order, ...{]})
&
\sphinxAtStartPar
Substitutes \sphinxcode{\sphinxupquote{sol}} into \sphinxcode{\sphinxupquote{ode}} and checks that the result is \sphinxcode{\sphinxupquote{0}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{checkpdesol}}(pde, sol{[}, func, solve\_for\_func{]})
&
\sphinxAtStartPar
Checks if the given solution satisfies the partial differential equation.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{checksol}}(f, symbol{[}, sol{]})
&
\sphinxAtStartPar
Checks whether sol is a solution of equation f == 0.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{classify\_ode}}(eq{[}, func, dict, ics, prep, ...{]})
&
\sphinxAtStartPar
Returns a tuple of possible \sphinxcode{\sphinxupquote{dsolve()}} classifications for an ODE.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{classify\_pde}}(eq{[}, func, dict, prep{]})
&
\sphinxAtStartPar
Returns a tuple of possible pdsolve() classifications for a PDE.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{closest\_points}}(*args)
&
\sphinxAtStartPar
Return the subset of points from a set of points that were the closest to each other in the 2D plane.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{cofactors}}(f, g, *gens, **args)
&
\sphinxAtStartPar
Compute GCD and cofactors of \sphinxcode{\sphinxupquote{f}} and \sphinxcode{\sphinxupquote{g}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{collect}}(expr, syms{[}, func, evaluate, exact, ...{]})
&
\sphinxAtStartPar
Collect additive terms of an expression.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{collect\_const}}(expr, *vars{[}, Numbers{]})
&
\sphinxAtStartPar
A non\sphinxhyphen{}greedy collection of terms with similar number coefficients in an Add expr.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{combsimp}}(expr)
&
\sphinxAtStartPar
Simplify combinatorial expressions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{comp}}(z1, z2{[}, tol{]})
&
\sphinxAtStartPar
Return a bool indicating whether the error between z1 and z2 is \$le\$ \sphinxcode{\sphinxupquote{tol}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{compose}}(f, g, *gens, **args)
&
\sphinxAtStartPar
Compute functional composition \sphinxcode{\sphinxupquote{f(g)}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{composite}}(nth)
&
\sphinxAtStartPar
Return the nth composite number, with the composite numbers indexed as composite(1) = 4, composite(2) = 6, etc....
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{compositepi}}(n)
&
\sphinxAtStartPar
Return the number of positive composite numbers less than or equal to n.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.sensitivity.babymodel:src.sensitivity.babymodel.connect_regions}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{connect\_regions}}}}}(region\_map, hubmap, ...)
&
\sphinxAtStartPar
given a mapping of regions to lists of hubs, and hubs to regions, creates a set of arcs between hubs such that:
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{construct\_domain}}(obj, **args)
&
\sphinxAtStartPar
Construct a minimal domain for a list of expressions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{content}}(f, *gens, **args)
&
\sphinxAtStartPar
Compute GCD of coefficients of \sphinxcode{\sphinxupquote{f}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{continued\_fraction}}(a)
&
\sphinxAtStartPar
Return the continued fraction representation of a Rational or quadratic irrational.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{continued\_fraction\_convergents}}(cf)
&
\sphinxAtStartPar
Return an iterator over the convergents of a continued fraction (cf).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{continued\_fraction\_iterator}}(x)
&
\sphinxAtStartPar
Return continued fraction expansion of x as iterator.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{continued\_fraction\_periodic}}(p, q{[}, d, s{]})
&
\sphinxAtStartPar
Find the periodic continued fraction expansion of a quadratic irrational.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{continued\_fraction\_reduce}}(cf)
&
\sphinxAtStartPar
Reduce a continued fraction to a rational or quadratic irrational.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{convex\_hull}}(*args{[}, polygon{]})
&
\sphinxAtStartPar
The convex hull surrounding the Points contained in the list of entities.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{convolution}}(a, b{[}, cycle, dps, prime, ...{]})
&
\sphinxAtStartPar
Performs convolution by determining the type of desired convolution using hints.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{cosine\_transform}}(f, x, k, **hints)
&
\sphinxAtStartPar
Compute the unitary, ordinary\sphinxhyphen{}frequency cosine transform of \sphinxtitleref{f}, defined as
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{count\_ops}}(expr{[}, visual{]})
&
\sphinxAtStartPar
Return a representation (integer or expression) of the operations in expr.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{count\_roots}}(f{[}, inf, sup{]})
&
\sphinxAtStartPar
Return the number of roots of \sphinxcode{\sphinxupquote{f}} in \sphinxcode{\sphinxupquote{{[}inf, sup{]}}} interval.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{covering\_product}}(a, b)
&
\sphinxAtStartPar
Returns the covering product of given sequences.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{cse}}(exprs{[}, symbols, optimizations, ...{]})
&
\sphinxAtStartPar
Perform common subexpression elimination on an expression.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{cxxcode}}(expr{[}, assign\_to, standard{]})
&
\sphinxAtStartPar
C++ equivalent of \sphinxcode{\sphinxupquote{ccode()}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{cycle\_length}}(f, x0{[}, nmax, values{]})
&
\sphinxAtStartPar
For a given iterated sequence, return a generator that gives the length of the iterated cycle (lambda) and the length of terms before the cycle begins (mu); if \sphinxcode{\sphinxupquote{values}} is True then the terms of the sequence will be returned instead.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{cyclotomic\_poly}}(n{[}, x, polys{]})
&
\sphinxAtStartPar
Generates cyclotomic polynomial of order \sphinxtitleref{n} in \sphinxtitleref{x}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{decompogen}}(f, symbol)
&
\sphinxAtStartPar
Computes General functional decomposition of \sphinxcode{\sphinxupquote{f}}. Given an expression \sphinxcode{\sphinxupquote{f}}, returns a list \sphinxcode{\sphinxupquote{{[}f\_1, f\_2, ..., f\_n{]}}}, where::           f = f\_1 o f\_2 o ... f\_n = f\_1(f\_2(... f\_n)).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{decompose}}(f, *gens, **args)
&
\sphinxAtStartPar
Compute functional decomposition of \sphinxcode{\sphinxupquote{f}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{default\_sort\_key}}(item{[}, order{]})
&
\sphinxAtStartPar
Return a key that can be used for sorting.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{deg}}(r)
&
\sphinxAtStartPar
Return the degree value for the given radians (pi = 180 degrees).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{degree}}(f{[}, gen{]})
&
\sphinxAtStartPar
Return the degree of \sphinxcode{\sphinxupquote{f}} in the given variable.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{degree\_list}}(f, *gens, **args)
&
\sphinxAtStartPar
Return a list of degrees of \sphinxcode{\sphinxupquote{f}} in all variables.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{denom}}(expr)
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{derive\_by\_array}}(expr, dx)
&
\sphinxAtStartPar
Derivative by arrays.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{det}}(matexpr)
&
\sphinxAtStartPar
Matrix Determinant
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{det\_quick}}(M{[}, method{]})
&
\sphinxAtStartPar
Return \sphinxcode{\sphinxupquote{det(M)}} assuming that either there are lots of zeros or the size of the matrix is small.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{diag}}(*values{[}, strict, unpack{]})
&
\sphinxAtStartPar
Returns a matrix with the provided values placed on the diagonal.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{diagonalize\_vector}}(vector)
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{dict\_merge}}(*dicts)
&
\sphinxAtStartPar
Merge dictionaries into a single dictionary.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{diff}}(f, *symbols, **kwargs)
&
\sphinxAtStartPar
Differentiate f with respect to symbols.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{difference\_delta}}(expr{[}, n, step{]})
&
\sphinxAtStartPar
Difference Operator.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{differentiate\_finite}}(expr, *symbols{[}, ...{]})
&
\sphinxAtStartPar
Differentiate expr and replace Derivatives with finite differences.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{diophantine}}(eq{[}, param, syms, permute{]})
&
\sphinxAtStartPar
Simplify the solution procedure of diophantine equation \sphinxcode{\sphinxupquote{eq}} by converting it into a product of terms which should equal zero.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{discrete\_log}}(n, a, b{[}, order, prime\_order{]})
&
\sphinxAtStartPar
Compute the discrete logarithm of \sphinxcode{\sphinxupquote{a}} to the base \sphinxcode{\sphinxupquote{b}} modulo \sphinxcode{\sphinxupquote{n}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{discriminant}}(f, *gens, **args)
&
\sphinxAtStartPar
Compute discriminant of \sphinxcode{\sphinxupquote{f}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{div}}(f, g, *gens, **args)
&
\sphinxAtStartPar
Compute polynomial division of \sphinxcode{\sphinxupquote{f}} and \sphinxcode{\sphinxupquote{g}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{divisor\_count}}(n{[}, modulus, proper{]})
&
\sphinxAtStartPar
Return the number of divisors of \sphinxcode{\sphinxupquote{n}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{divisors}}(n{[}, generator, proper{]})
&
\sphinxAtStartPar
Return all divisors of n sorted from 1..n by default.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{dotprint}}(expr{[}, styles, atom, maxdepth, ...{]})
&
\sphinxAtStartPar
DOT description of a SymPy expression tree
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{dsolve}}(eq{[}, func, hint, simplify, ics, xi, ...{]})
&
\sphinxAtStartPar
Solves any (supported) kind of ordinary differential equation and system of ordinary differential equations.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{egyptian\_fraction}}(r{[}, algorithm{]})
&
\sphinxAtStartPar
Return the list of denominators of an Egyptian fraction expansion {\color{red}\bfseries{}{[}1{]}\_} of the said rational \sphinxtitleref{r}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{epath}}(path{[}, expr, func, args, kwargs{]})
&
\sphinxAtStartPar
Manipulate parts of an expression selected by a path.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{euler\_equations}}(L{[}, funcs, vars{]})
&
\sphinxAtStartPar
Find the Euler\sphinxhyphen{}Lagrange equations {\color{red}\bfseries{}{[}1{]}\_} for a given Lagrangian.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{evaluate}}(x)
&
\sphinxAtStartPar
Control automatic evaluation
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{expand}}(e{[}, deep, modulus, power\_base, ...{]})
&
\sphinxAtStartPar
Expand an expression using methods given as hints.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{expand\_complex}}(expr{[}, deep{]})
&
\sphinxAtStartPar
Wrapper around expand that only uses the complex hint.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{expand\_func}}(expr{[}, deep{]})
&
\sphinxAtStartPar
Wrapper around expand that only uses the func hint.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{expand\_log}}(expr{[}, deep, force, factor{]})
&
\sphinxAtStartPar
Wrapper around expand that only uses the log hint.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{expand\_mul}}(expr{[}, deep{]})
&
\sphinxAtStartPar
Wrapper around expand that only uses the mul hint.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{expand\_multinomial}}(expr{[}, deep{]})
&
\sphinxAtStartPar
Wrapper around expand that only uses the multinomial hint.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{expand\_power\_base}}(expr{[}, deep, force{]})
&
\sphinxAtStartPar
Wrapper around expand that only uses the power\_base hint.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{expand\_power\_exp}}(expr{[}, deep{]})
&
\sphinxAtStartPar
Wrapper around expand that only uses the power\_exp hint.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{expand\_trig}}(expr{[}, deep{]})
&
\sphinxAtStartPar
Wrapper around expand that only uses the trig hint.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{exptrigsimp}}(expr)
&
\sphinxAtStartPar
Simplifies exponential / trigonometric / hyperbolic functions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{exquo}}(f, g, *gens, **args)
&
\sphinxAtStartPar
Compute polynomial exact quotient of \sphinxcode{\sphinxupquote{f}} and \sphinxcode{\sphinxupquote{g}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{eye}}(*args, **kwargs)
&
\sphinxAtStartPar
Create square identity matrix n x n
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{factor}}(f, *gens{[}, deep{]})
&
\sphinxAtStartPar
Compute the factorization of expression, \sphinxcode{\sphinxupquote{f}}, into irreducibles.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{factor\_list}}(f, *gens, **args)
&
\sphinxAtStartPar
Compute a list of irreducible factors of \sphinxcode{\sphinxupquote{f}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{factor\_nc}}(expr)
&
\sphinxAtStartPar
Return the factored form of \sphinxcode{\sphinxupquote{expr}} while handling non\sphinxhyphen{}commutative expressions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{factor\_terms}}(expr{[}, radical, clear, ...{]})
&
\sphinxAtStartPar
Remove common factors from terms in all arguments without changing the underlying structure of the expr.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{factorint}}(n{[}, limit, use\_trial, use\_rho, ...{]})
&
\sphinxAtStartPar
Given a positive integer \sphinxcode{\sphinxupquote{n}}, \sphinxcode{\sphinxupquote{factorint(n)}} returns a dict containing the prime factors of \sphinxcode{\sphinxupquote{n}} as keys and their respective multiplicities as values.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{factorrat}}(rat{[}, limit, use\_trial, use\_rho, ...{]})
&
\sphinxAtStartPar
Given a Rational \sphinxcode{\sphinxupquote{r}}, \sphinxcode{\sphinxupquote{factorrat(r)}} returns a dict containing the prime factors of \sphinxcode{\sphinxupquote{r}} as keys and their respective multiplicities as values.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{failing\_assumptions}}(expr, **assumptions)
&
\sphinxAtStartPar
Return a dictionary containing assumptions with values not matching those of the passed assumptions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{farthest\_points}}(*args)
&
\sphinxAtStartPar
Return the subset of points from a set of points that were the furthest apart from each other in the 2D plane.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{fcode}}(expr{[}, assign\_to{]})
&
\sphinxAtStartPar
Converts an expr to a string of fortran code
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{fft}}(seq{[}, dps{]})
&
\sphinxAtStartPar
Performs the Discrete Fourier Transform (\sphinxstylestrong{DFT}) in the complex domain.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{field}}(symbols, domain{[}, order{]})
&
\sphinxAtStartPar
Construct new rational function field returning (field, x1, ..., xn).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{field\_isomorphism}}(a, b, *{[}, fast{]})
&
\sphinxAtStartPar
Find an embedding of one number field into another.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{filldedent}}(s{[}, w{]})
&
\sphinxAtStartPar
Strips leading and trailing empty lines from a copy of \sphinxcode{\sphinxupquote{s}}, then dedents, fills and returns it.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{finite\_diff\_weights}}(order, x\_list{[}, x0{]})
&
\sphinxAtStartPar
Calculates the finite difference weights for an arbitrarily spaced one\sphinxhyphen{}dimensional grid (\sphinxcode{\sphinxupquote{x\_list}}) for derivatives at \sphinxcode{\sphinxupquote{x0}} of order 0, 1, ..., up to \sphinxcode{\sphinxupquote{order}} using a recursive formula.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{flatten}}(iterable{[}, levels, cls{]})
&
\sphinxAtStartPar
Recursively denest iterable containers.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{fourier\_series}}(f{[}, limits, finite{]})
&
\sphinxAtStartPar
Computes the Fourier trigonometric series expansion.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{fourier\_transform}}(f, x, k, **hints)
&
\sphinxAtStartPar
Compute the unitary, ordinary\sphinxhyphen{}frequency Fourier transform of \sphinxcode{\sphinxupquote{f}}, defined as
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{fps}}(f{[}, x, x0, dir, hyper, order, rational, ...{]})
&
\sphinxAtStartPar
Generates Formal Power Series of \sphinxcode{\sphinxupquote{f}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{fraction}}(expr{[}, exact{]})
&
\sphinxAtStartPar
Returns a pair with expression\textquotesingle{}s numerator and denominator.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{fu}}(rv{[}, measure{]})
&
\sphinxAtStartPar
Attempt to simplify expression by using transformation rules given in the algorithm by Fu et al.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{fwht}}(seq)
&
\sphinxAtStartPar
Performs the Walsh Hadamard Transform (\sphinxstylestrong{WHT}), and uses Hadamard ordering for the sequence.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{galois\_group}}(f, *gens{[}, by\_name, max\_tries, ...{]})
&
\sphinxAtStartPar
Compute the Galois group for polynomials \sphinxstyleemphasis{f} up to degree 6.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{gammasimp}}(expr)
&
\sphinxAtStartPar
Simplify expressions with gamma functions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{gcd}}(f{[}, g{]})
&
\sphinxAtStartPar
Compute GCD of \sphinxcode{\sphinxupquote{f}} and \sphinxcode{\sphinxupquote{g}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{gcd\_list}}(seq, *gens, **args)
&
\sphinxAtStartPar
Compute GCD of a list of polynomials.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{gcd\_terms}}(terms{[}, isprimitive, clear, fraction{]})
&
\sphinxAtStartPar
Compute the GCD of \sphinxcode{\sphinxupquote{terms}} and put them together.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{gcdex}}(f, g, *gens, **args)
&
\sphinxAtStartPar
Extended Euclidean algorithm of \sphinxcode{\sphinxupquote{f}} and \sphinxcode{\sphinxupquote{g}}.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.sensitivity.babymodel:src.sensitivity.babymodel.generate}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{generate}}}}}({[}num\_regions, hubs\_per\_region, ...{]})
&
\sphinxAtStartPar
generates a random network with all parameters required to initialize a ToyBabyModel
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{getLogger}}({[}name{]})
&
\sphinxAtStartPar
Return a logger with the specified name, creating it if necessary.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{get\_contraction\_structure}}(expr)
&
\sphinxAtStartPar
Determine dummy indices of \sphinxcode{\sphinxupquote{expr}} and describe its structure
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{get\_indices}}(expr)
&
\sphinxAtStartPar
Determine the outer indices of expression \sphinxcode{\sphinxupquote{expr}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{gff}}(f, *gens, **args)
&
\sphinxAtStartPar
Compute greatest factorial factorization of \sphinxcode{\sphinxupquote{f}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{gff\_list}}(f, *gens, **args)
&
\sphinxAtStartPar
Compute a list of greatest factorial factors of \sphinxcode{\sphinxupquote{f}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{glsl\_code}}(expr{[}, assign\_to{]})
&
\sphinxAtStartPar
Converts an expr to a string of GLSL code
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{groebner}}(F, *gens, **args)
&
\sphinxAtStartPar
Computes the reduced Groebner basis for a set of polynomials.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ground\_roots}}(f, *gens, **args)
&
\sphinxAtStartPar
Compute roots of \sphinxcode{\sphinxupquote{f}} by factorization in the ground domain.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{group}}(seq{[}, multiple{]})
&
\sphinxAtStartPar
Splits a sequence into a list of lists of equal, adjacent elements.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{gruntz}}(e, z, z0{[}, dir{]})
&
\sphinxAtStartPar
Compute the limit of e(z) at the point z0 using the Gruntz algorithm.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hadamard\_product}}(*matrices)
&
\sphinxAtStartPar
Return the elementwise (aka Hadamard) product of matrices.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{half\_gcdex}}(f, g, *gens, **args)
&
\sphinxAtStartPar
Half extended Euclidean algorithm of \sphinxcode{\sphinxupquote{f}} and \sphinxcode{\sphinxupquote{g}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hankel\_transform}}(f, r, k, nu, **hints)
&
\sphinxAtStartPar
Compute the Hankel transform of \sphinxtitleref{f}, defined as
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{has\_dups}}(seq)
&
\sphinxAtStartPar
Return True if there are any duplicate elements in \sphinxcode{\sphinxupquote{seq}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{has\_variety}}(seq)
&
\sphinxAtStartPar
Return True if there are any different elements in \sphinxcode{\sphinxupquote{seq}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hermite\_poly}}(n{[}, x, polys{]})
&
\sphinxAtStartPar
Generates the Hermite polynomial \sphinxtitleref{H\_n(x)}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hermite\_prob\_poly}}(n{[}, x, polys{]})
&
\sphinxAtStartPar
Generates the probabilist\textquotesingle{}s Hermite polynomial \sphinxtitleref{He\_n(x)}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hessian}}(f, varlist{[}, constraints{]})
&
\sphinxAtStartPar
Compute Hessian matrix for a function f wrt parameters in varlist which may be given as a sequence or a row/column vector.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{homogeneous\_order}}(eq, *symbols)
&
\sphinxAtStartPar
Returns the order \sphinxtitleref{n} if \sphinxtitleref{g} is homogeneous and \sphinxcode{\sphinxupquote{None}} if it is not homogeneous.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{horner}}(f, *gens, **args)
&
\sphinxAtStartPar
Rewrite a polynomial in Horner form.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hyperexpand}}(f{[}, allow\_hyper, rewrite, place{]})
&
\sphinxAtStartPar
Expand hypergeometric functions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hypersimilar}}(f, g, k)
&
\sphinxAtStartPar
Returns True if \sphinxcode{\sphinxupquote{f}} and \sphinxcode{\sphinxupquote{g}} are hyper\sphinxhyphen{}similar.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hypersimp}}(f, k)
&
\sphinxAtStartPar
Given combinatorial term f(k) simplify its consecutive term ratio i.e. f(k+1)/f(k).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{idiff}}(eq, y, x{[}, n{]})
&
\sphinxAtStartPar
Return \sphinxcode{\sphinxupquote{dy/dx}} assuming that \sphinxcode{\sphinxupquote{eq == 0}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ifft}}(seq{[}, dps{]})
&
\sphinxAtStartPar
Performs the Discrete Fourier Transform (\sphinxstylestrong{DFT}) in the complex domain.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ifwht}}(seq)
&
\sphinxAtStartPar
Performs the Walsh Hadamard Transform (\sphinxstylestrong{WHT}), and uses Hadamard ordering for the sequence.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{igcd}}(*args)
&
\sphinxAtStartPar
Computes nonnegative integer greatest common divisor.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ilcm}}(*args)
&
\sphinxAtStartPar
Computes integer least common multiple.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{imageset}}(*args)
&
\sphinxAtStartPar
Return an image of the set under transformation \sphinxcode{\sphinxupquote{f}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{init\_printing}}({[}pretty\_print, order, ...{]})
&
\sphinxAtStartPar
Initializes pretty\sphinxhyphen{}printer depending on the environment.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{init\_session}}({[}ipython, pretty\_print, order, ...{]})
&
\sphinxAtStartPar
Initialize an embedded IPython or Python session.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{integer\_log}}(y, x)
&
\sphinxAtStartPar
Returns \sphinxcode{\sphinxupquote{(e, bool)}} where e is the largest nonnegative integer such that \(|y| \geq |x^e|\) and \sphinxcode{\sphinxupquote{bool}} is True if \$y = x\textasciicircum{}e\$.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{integer\_nthroot}}(y, n)
&
\sphinxAtStartPar
Return a tuple containing x = floor(y**(1/n)) and a boolean indicating whether the result is exact (that is, whether x**n == y).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{integrate}}(f, var, ...)
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{interactive\_traversal}}(expr)
&
\sphinxAtStartPar
Traverse a tree asking a user which branch to choose.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{interpolate}}(data, x)
&
\sphinxAtStartPar
Construct an interpolating polynomial for the data points evaluated at point x (which can be symbolic or numeric).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{interpolating\_poly}}(n, x{[}, X, Y{]})
&
\sphinxAtStartPar
Construct Lagrange interpolating polynomial for \sphinxcode{\sphinxupquote{n}} data points.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{interpolating\_spline}}(d, x, X, Y)
&
\sphinxAtStartPar
Return spline of degree \sphinxstyleemphasis{d}, passing through the given \sphinxstyleemphasis{X} and \sphinxstyleemphasis{Y} values.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{intersecting\_product}}(a, b)
&
\sphinxAtStartPar
Returns the intersecting product of given sequences.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{intersection}}(*entities{[}, pairwise{]})
&
\sphinxAtStartPar
The intersection of a collection of GeometryEntity instances.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{intervals}}(F{[}, all, eps, inf, sup, strict, ...{]})
&
\sphinxAtStartPar
Compute isolating intervals for roots of \sphinxcode{\sphinxupquote{f}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{intt}}(seq, prime)
&
\sphinxAtStartPar
Performs the Number Theoretic Transform (\sphinxstylestrong{NTT}), which specializes the Discrete Fourier Transform (\sphinxstylestrong{DFT}) over quotient ring \sphinxtitleref{Z/pZ} for prime \sphinxtitleref{p} instead of complex numbers \sphinxtitleref{C}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{inv\_quick}}(M)
&
\sphinxAtStartPar
Return the inverse of \sphinxcode{\sphinxupquote{M}}, assuming that either there are lots of zeros or the size of the matrix is small.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{inverse\_cosine\_transform}}(F, k, x, **hints)
&
\sphinxAtStartPar
Compute the unitary, ordinary\sphinxhyphen{}frequency inverse cosine transform of \sphinxtitleref{F}, defined as
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{inverse\_fourier\_transform}}(F, k, x, **hints)
&
\sphinxAtStartPar
Compute the unitary, ordinary\sphinxhyphen{}frequency inverse Fourier transform of \sphinxtitleref{F}, defined as
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{inverse\_hankel\_transform}}(F, k, r, nu, **hints)
&
\sphinxAtStartPar
Compute the inverse Hankel transform of \sphinxtitleref{F} defined as
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{inverse\_laplace\_transform}}(F, s, t{[}, plane{]})
&
\sphinxAtStartPar
Compute the inverse Laplace transform of \sphinxtitleref{F(s)}, defined as
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{inverse\_mellin\_transform}}(F, s, x, strip, **hints)
&
\sphinxAtStartPar
Compute the inverse Mellin transform of \sphinxtitleref{F(s)} over the fundamental strip given by \sphinxcode{\sphinxupquote{strip=(a, b)}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{inverse\_mobius\_transform}}(seq{[}, subset{]})
&
\sphinxAtStartPar
Performs the Mobius Transform for subset lattice with indices of sequence as bitmasks.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{inverse\_sine\_transform}}(F, k, x, **hints)
&
\sphinxAtStartPar
Compute the unitary, ordinary\sphinxhyphen{}frequency inverse sine transform of \sphinxtitleref{F}, defined as
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{invert}}(f, g, *gens, **args)
&
\sphinxAtStartPar
Invert \sphinxcode{\sphinxupquote{f}} modulo \sphinxcode{\sphinxupquote{g}} when possible.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{is\_abundant}}(n)
&
\sphinxAtStartPar
Returns True if \sphinxcode{\sphinxupquote{n}} is an abundant number, else False.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{is\_amicable}}(m, n)
&
\sphinxAtStartPar
Returns True if the numbers \sphinxtitleref{m} and \sphinxtitleref{n} are "amicable", else False.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{is\_convex}}(f, *syms{[}, domain{]})
&
\sphinxAtStartPar
Determines the  convexity of the function passed in the argument.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{is\_decreasing}}(expression{[}, interval, symbol{]})
&
\sphinxAtStartPar
Return whether the function is decreasing in the given interval.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{is\_deficient}}(n)
&
\sphinxAtStartPar
Returns True if \sphinxcode{\sphinxupquote{n}} is a deficient number, else False.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{is\_increasing}}(expression{[}, interval, symbol{]})
&
\sphinxAtStartPar
Return whether the function is increasing in the given interval.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{is\_mersenne\_prime}}(n)
&
\sphinxAtStartPar
Returns True if  \sphinxcode{\sphinxupquote{n}} is a Mersenne prime, else False.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{is\_monotonic}}(expression{[}, interval, symbol{]})
&
\sphinxAtStartPar
Return whether the function is monotonic in the given interval.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{is\_nthpow\_residue}}(a, n, m)
&
\sphinxAtStartPar
Returns True if \sphinxcode{\sphinxupquote{x**n == a (mod m)}} has solutions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{is\_perfect}}(n)
&
\sphinxAtStartPar
Returns True if \sphinxcode{\sphinxupquote{n}} is a perfect number, else False.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{is\_primitive\_root}}(a, p)
&
\sphinxAtStartPar
Returns True if \sphinxcode{\sphinxupquote{a}} is a primitive root of \sphinxcode{\sphinxupquote{p}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{is\_quad\_residue}}(a, p)
&
\sphinxAtStartPar
Returns True if \sphinxcode{\sphinxupquote{a}} (mod \sphinxcode{\sphinxupquote{p}}) is in the set of squares mod \sphinxcode{\sphinxupquote{p}}, i.e a \% p in set({[}i**2 \% p for i in range(p){]}).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{is\_strictly\_decreasing}}(expression{[}, ...{]})
&
\sphinxAtStartPar
Return whether the function is strictly decreasing in the given interval.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{is\_strictly\_increasing}}(expression{[}, ...{]})
&
\sphinxAtStartPar
Return whether the function is strictly increasing in the given interval.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{is\_zero\_dimensional}}(F, *gens, **args)
&
\sphinxAtStartPar
Checks if the ideal generated by a Groebner basis is zero\sphinxhyphen{}dimensional.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{isolate}}(alg{[}, eps, fast{]})
&
\sphinxAtStartPar
Find a rational isolating interval for a real algebraic number.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{isprime}}(n)
&
\sphinxAtStartPar
Test if n is a prime number (True) or not (False).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{itermonomials}}(variables, max\_degrees{[}, ...{]})
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{max\_degrees}} and \sphinxcode{\sphinxupquote{min\_degrees}} are either both integers or both lists.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{jacobi\_normalized}}(n, a, b, x)
&
\sphinxAtStartPar
Jacobi polynomial \$P\_n\textasciicircum{}\{left(alpha, betaright)\}(x)\$.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{jacobi\_poly}}(n, a, b{[}, x, polys{]})
&
\sphinxAtStartPar
Generates the Jacobi polynomial \sphinxtitleref{P\_n\textasciicircum{}\{(a,b)\}(x)}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{jacobi\_symbol}}(m, n)
&
\sphinxAtStartPar
Returns the Jacobi symbol \sphinxtitleref{(m / n)}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{jn\_zeros}}(n, k{[}, method, dps{]})
&
\sphinxAtStartPar
Zeros of the spherical Bessel function of the first kind.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{jordan\_cell}}(eigenval, n)
&
\sphinxAtStartPar
Create a Jordan block:
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{jscode}}(expr{[}, assign\_to{]})
&
\sphinxAtStartPar
Converts an expr to a string of javascript code
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{julia\_code}}(expr{[}, assign\_to{]})
&
\sphinxAtStartPar
Converts \sphinxtitleref{expr} to a string of Julia code.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{kronecker\_product}}(*matrices)
&
\sphinxAtStartPar
The Kronecker product of two or more arguments.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{kroneckersimp}}(expr)
&
\sphinxAtStartPar
Simplify expressions with KroneckerDelta.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{laguerre\_poly}}(n{[}, x, alpha, polys{]})
&
\sphinxAtStartPar
Generates the Laguerre polynomial \sphinxtitleref{L\_n\textasciicircum{}\{(alpha)\}(x)}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{lambdify}}(args, expr{[}, modules, printer, ...{]})
&
\sphinxAtStartPar
Convert a SymPy expression into a function that allows for fast numeric evaluation.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{laplace\_transform}}(f, t, s{[}, legacy\_matrix{]})
&
\sphinxAtStartPar
Compute the Laplace Transform \sphinxtitleref{F(s)} of \sphinxtitleref{f(t)},
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{lcm}}(f{[}, g{]})
&
\sphinxAtStartPar
Compute LCM of \sphinxcode{\sphinxupquote{f}} and \sphinxcode{\sphinxupquote{g}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{lcm\_list}}(seq, *gens, **args)
&
\sphinxAtStartPar
Compute LCM of a list of polynomials.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{legendre\_poly}}(n{[}, x, polys{]})
&
\sphinxAtStartPar
Generates the Legendre polynomial \sphinxtitleref{P\_n(x)}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{legendre\_symbol}}(a, p)
&
\sphinxAtStartPar
Returns the Legendre symbol \sphinxtitleref{(a / p)}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{limit}}(e, z, z0{[}, dir{]})
&
\sphinxAtStartPar
Computes the limit of \sphinxcode{\sphinxupquote{e(z)}} at the point \sphinxcode{\sphinxupquote{z0}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{limit\_seq}}(expr{[}, n, trials{]})
&
\sphinxAtStartPar
Finds the limit of a sequence as index \sphinxcode{\sphinxupquote{n}} tends to infinity.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{line\_integrate}}(field, Curve, variables)
&
\sphinxAtStartPar
Compute the line integral.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{linear\_eq\_to\_matrix}}(equations, *symbols)
&
\sphinxAtStartPar
Converts a given System of Equations into Matrix form.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{linsolve}}(system, *symbols)
&
\sphinxAtStartPar
Solve system of \$N\$ linear equations with \$M\$ variables; both underdetermined and overdetermined systems are supported.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{list2numpy}}(l{[}, dtype{]})
&
\sphinxAtStartPar
Converts Python list of SymPy expressions to a NumPy array.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{logcombine}}(expr{[}, force{]})
&
\sphinxAtStartPar
Takes logarithms and combines them using the following rules:
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{maple\_code}}(expr{[}, assign\_to{]})
&
\sphinxAtStartPar
Converts \sphinxcode{\sphinxupquote{expr}} to a string of Maple code.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mathematica\_code}}(expr, **settings)
&
\sphinxAtStartPar
Converts an expr to a string of the Wolfram Mathematica code
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{matrix2numpy}}(m{[}, dtype{]})
&
\sphinxAtStartPar
Converts SymPy\textquotesingle{}s matrix to a NumPy array.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{matrix\_multiply\_elementwise}}(A, B)
&
\sphinxAtStartPar
Return the Hadamard product (elementwise product) of A and B
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{matrix\_symbols}}(expr)
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{maximum}}(f, symbol{[}, domain{]})
&
\sphinxAtStartPar
Returns the maximum value of a function in the given domain.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mellin\_transform}}(f, x, s, **hints)
&
\sphinxAtStartPar
Compute the Mellin transform \sphinxtitleref{F(s)} of \sphinxtitleref{f(x)},
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{memoize\_property}}(propfunc)
&
\sphinxAtStartPar
Property decorator that caches the value of potentially expensive \sphinxtitleref{propfunc} after the first evaluation.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mersenne\_prime\_exponent}}(nth)
&
\sphinxAtStartPar
Returns the exponent \sphinxcode{\sphinxupquote{i}} for the nth Mersenne prime (which has the form \sphinxtitleref{2\textasciicircum{}i \sphinxhyphen{} 1}).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{minimal\_polynomial}}(ex{[}, x, compose, polys, ...{]})
&
\sphinxAtStartPar
Computes the minimal polynomial of an algebraic element.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{minimum}}(f, symbol{[}, domain{]})
&
\sphinxAtStartPar
Returns the minimum value of a function in the given domain.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{minpoly}}(ex{[}, x, compose, polys, domain{]})
&
\sphinxAtStartPar
This is a synonym for \sphinxcode{\sphinxupquote{minimal\_polynomial()}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mobius\_transform}}(seq{[}, subset{]})
&
\sphinxAtStartPar
Performs the Mobius Transform for subset lattice with indices of sequence as bitmasks.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mod\_inverse}}(a, m)
&
\sphinxAtStartPar
Return the number \$c\$ such that, \$a times c = 1 pmod\{m\}\$ where \$c\$ has the same sign as \$m\$.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{monic}}(f, *gens, **args)
&
\sphinxAtStartPar
Divide all coefficients of \sphinxcode{\sphinxupquote{f}} by \sphinxcode{\sphinxupquote{LC(f)}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{multiline\_latex}}(lhs, rhs{[}, terms\_per\_line, ...{]})
&
\sphinxAtStartPar
This function generates a LaTeX equation with a multiline right\sphinxhyphen{}hand side in an \sphinxcode{\sphinxupquote{align*}}, \sphinxcode{\sphinxupquote{eqnarray}} or \sphinxcode{\sphinxupquote{IEEEeqnarray}} environment.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{multinomial\_coefficients}}(m, n)
&
\sphinxAtStartPar
Return a dictionary containing pairs \sphinxcode{\sphinxupquote{\{(k1,k2,..,km) : C\_kn\}}} where \sphinxcode{\sphinxupquote{C\_kn}} are multinomial coefficients such that \sphinxcode{\sphinxupquote{n=k1+k2+..+km}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{multiplicity}}(p, n)
&
\sphinxAtStartPar
Find the greatest integer m such that p**m divides n.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{n\_order}}(a, n)
&
\sphinxAtStartPar
Returns the order of \sphinxcode{\sphinxupquote{a}} modulo \sphinxcode{\sphinxupquote{n}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nextprime}}(n{[}, ith{]})
&
\sphinxAtStartPar
Return the ith prime greater than n.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nfloat}}(expr{[}, n, exponent, dkeys{]})
&
\sphinxAtStartPar
Make all Rationals in expr Floats except those in exponents (unless the exponents flag is set to True) and those in undefined functions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nonlinsolve}}(system, *symbols)
&
\sphinxAtStartPar
Solve system of \$N\$ nonlinear equations with \$M\$ variables, which means both under and overdetermined systems are supported.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{not\_empty\_in}}(finset\_intersection, *syms)
&
\sphinxAtStartPar
Finds the domain of the functions in \sphinxcode{\sphinxupquote{finset\_intersection}} in which the \sphinxcode{\sphinxupquote{finite\_set}} is not\sphinxhyphen{}empty.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{npartitions}}(n{[}, verbose{]})
&
\sphinxAtStartPar
Calculate the partition function P(n), i.e. the number of ways that n can be written as a sum of positive integers.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nroots}}(f{[}, n, maxsteps, cleanup{]})
&
\sphinxAtStartPar
Compute numerical approximations of roots of \sphinxcode{\sphinxupquote{f}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nsimplify}}(expr{[}, constants, tolerance, ...{]})
&
\sphinxAtStartPar
Find a simple representation for a number or, if there are free symbols or if \sphinxcode{\sphinxupquote{rational=True}}, then replace Floats with their Rational equivalents.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nsolve}}(*args{[}, dict{]})
&
\sphinxAtStartPar
Solve a nonlinear equation system numerically: \sphinxcode{\sphinxupquote{nsolve(f, {[}args,{]} x0, modules={[}\textquotesingle{}mpmath\textquotesingle{}{]}, **kwargs)}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nth\_power\_roots\_poly}}(f, n, *gens, **args)
&
\sphinxAtStartPar
Construct a polynomial with n\sphinxhyphen{}th powers of roots of \sphinxcode{\sphinxupquote{f}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nthroot\_mod}}(a, n, p{[}, all\_roots{]})
&
\sphinxAtStartPar
Find the solutions to \sphinxcode{\sphinxupquote{x**n = a mod p}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ntt}}(seq, prime)
&
\sphinxAtStartPar
Performs the Number Theoretic Transform (\sphinxstylestrong{NTT}), which specializes the Discrete Fourier Transform (\sphinxstylestrong{DFT}) over quotient ring \sphinxtitleref{Z/pZ} for prime \sphinxtitleref{p} instead of complex numbers \sphinxtitleref{C}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{numbered\_symbols}}({[}prefix, cls, start, exclude{]})
&
\sphinxAtStartPar
Generate an infinite stream of Symbols consisting of a prefix and increasing subscripts provided that they do not occur in \sphinxcode{\sphinxupquote{exclude}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{numer}}(expr)
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{octave\_code}}(expr{[}, assign\_to{]})
&
\sphinxAtStartPar
Converts \sphinxtitleref{expr} to a string of Octave (or Matlab) code.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ode\_order}}(expr, func)
&
\sphinxAtStartPar
Returns the order of a given differential equation with respect to func.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ones}}(*args, **kwargs)
&
\sphinxAtStartPar
Returns a matrix of ones with \sphinxcode{\sphinxupquote{rows}} rows and \sphinxcode{\sphinxupquote{cols}} columns; if \sphinxcode{\sphinxupquote{cols}} is omitted a square matrix will be returned.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ordered}}(seq{[}, keys, default, warn{]})
&
\sphinxAtStartPar
Return an iterator of the seq where keys are used to break ties in a conservative fashion: if, after applying a key, there are no ties then no other keys will be computed.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pager\_print}}(expr, **settings)
&
\sphinxAtStartPar
Prints expr using the pager, in pretty form.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{parallel\_poly\_from\_expr}}(exprs, *gens, **args)
&
\sphinxAtStartPar
Construct polynomials from expressions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{parse\_expr}}(s{[}, local\_dict, transformations, ...{]})
&
\sphinxAtStartPar
Converts the string \sphinxcode{\sphinxupquote{s}} to a SymPy expression, in \sphinxcode{\sphinxupquote{local\_dict}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pde\_separate}}(eq, fun, sep{[}, strategy{]})
&
\sphinxAtStartPar
Separate variables in partial differential equation either by additive or multiplicative separation approach.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pde\_separate\_add}}(eq, fun, sep)
&
\sphinxAtStartPar
Helper function for searching additive separable solutions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pde\_separate\_mul}}(eq, fun, sep)
&
\sphinxAtStartPar
Helper function for searching multiplicative separable solutions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pdiv}}(f, g, *gens, **args)
&
\sphinxAtStartPar
Compute polynomial pseudo\sphinxhyphen{}division of \sphinxcode{\sphinxupquote{f}} and \sphinxcode{\sphinxupquote{g}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pdsolve}}(eq{[}, func, hint, dict, solvefun{]})
&
\sphinxAtStartPar
Solves any (supported) kind of partial differential equation.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{per}}(matexpr)
&
\sphinxAtStartPar
Matrix Permanent
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{perfect\_power}}(n{[}, candidates, big, factor{]})
&
\sphinxAtStartPar
Return \sphinxcode{\sphinxupquote{(b, e)}} such that \sphinxcode{\sphinxupquote{n}} == \sphinxcode{\sphinxupquote{b**e}} if \sphinxcode{\sphinxupquote{n}} is a unique perfect power with \sphinxcode{\sphinxupquote{e \textgreater{} 1}}, else \sphinxcode{\sphinxupquote{False}} (e.g. 1 is not a perfect power).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{periodicity}}(f, symbol{[}, check{]})
&
\sphinxAtStartPar
Tests the given function for periodicity in the given symbol.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{permutedims}}(expr{[}, perm, index\_order\_old, ...{]})
&
\sphinxAtStartPar
Permutes the indices of an array.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pexquo}}(f, g, *gens, **args)
&
\sphinxAtStartPar
Compute polynomial exact pseudo\sphinxhyphen{}quotient of \sphinxcode{\sphinxupquote{f}} and \sphinxcode{\sphinxupquote{g}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{piecewise\_exclusive}}(expr, *{[}, skip\_nan, deep{]})
&
\sphinxAtStartPar
Rewrite \sphinxcode{\sphinxupquote{Piecewise}} with mutually exclusive conditions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{piecewise\_fold}}(expr{[}, evaluate{]})
&
\sphinxAtStartPar
Takes an expression containing a piecewise function and returns the expression in piecewise form.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{plot}}(*args{[}, show{]})
&
\sphinxAtStartPar
Plots a function of a single variable as a curve.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{plot\_implicit}}(expr{[}, x\_var, y\_var, ...{]})
&
\sphinxAtStartPar
A plot function to plot implicit equations / inequalities.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{plot\_parametric}}(*args{[}, show{]})
&
\sphinxAtStartPar
Plots a 2D parametric curve.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{polarify}}(eq{[}, subs, lift{]})
&
\sphinxAtStartPar
Turn all numbers in eq into their polar equivalents (under the standard choice of argument).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pollard\_pm1}}(n{[}, B, a, retries, seed{]})
&
\sphinxAtStartPar
Use Pollard\textquotesingle{}s p\sphinxhyphen{}1 method to try to extract a nontrivial factor of \sphinxcode{\sphinxupquote{n}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pollard\_rho}}(n{[}, s, a, retries, seed, ...{]})
&
\sphinxAtStartPar
Use Pollard\textquotesingle{}s rho method to try to extract a nontrivial factor of \sphinxcode{\sphinxupquote{n}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{poly}}(expr, *gens, **args)
&
\sphinxAtStartPar
Efficiently transform an expression into a polynomial.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{poly\_from\_expr}}(expr, *gens, **args)
&
\sphinxAtStartPar
Construct a polynomial from an expression.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{posify}}(eq)
&
\sphinxAtStartPar
Return \sphinxcode{\sphinxupquote{eq}} (with generic symbols made positive) and a dictionary containing the mapping between the old and new symbols.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{postfixes}}(seq)
&
\sphinxAtStartPar
Generate all postfixes of a sequence.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{postorder\_traversal}}(node{[}, keys{]})
&
\sphinxAtStartPar
Do a postorder traversal of a tree.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{powdenest}}(eq{[}, force, polar{]})
&
\sphinxAtStartPar
Collect exponents on powers as assumptions allow.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{powsimp}}(expr{[}, deep, combine, force, measure{]})
&
\sphinxAtStartPar
Reduce expression by combining powers with similar bases and exponents.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pprint}}(expr, **kwargs)
&
\sphinxAtStartPar
Prints expr in pretty form.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pprint\_try\_use\_unicode}}()
&
\sphinxAtStartPar
See if unicode output is available and leverage it if possible
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pprint\_use\_unicode}}({[}flag{]})
&
\sphinxAtStartPar
Set whether pretty\sphinxhyphen{}printer should use unicode by default
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pquo}}(f, g, *gens, **args)
&
\sphinxAtStartPar
Compute polynomial pseudo\sphinxhyphen{}quotient of \sphinxcode{\sphinxupquote{f}} and \sphinxcode{\sphinxupquote{g}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{prefixes}}(seq)
&
\sphinxAtStartPar
Generate all prefixes of a sequence.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{prem}}(f, g, *gens, **args)
&
\sphinxAtStartPar
Compute polynomial pseudo\sphinxhyphen{}remainder of \sphinxcode{\sphinxupquote{f}} and \sphinxcode{\sphinxupquote{g}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pretty\_print}}(expr, **kwargs)
&
\sphinxAtStartPar
Prints expr in pretty form.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{preview}}(expr{[}, output, viewer, euler, ...{]})
&
\sphinxAtStartPar
View expression or LaTeX markup in PNG, DVI, PostScript or PDF form.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{prevprime}}(n)
&
\sphinxAtStartPar
Return the largest prime smaller than n.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{prime}}(nth)
&
\sphinxAtStartPar
Return the nth prime, with the primes indexed as prime(1) = 2, prime(2) = 3, etc.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{prime\_decomp}}(p{[}, T, ZK, dK, radical{]})
&
\sphinxAtStartPar
Compute the decomposition of rational prime \sphinxstyleemphasis{p} in a number field.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{prime\_valuation}}(I, P)
&
\sphinxAtStartPar
Compute the \sphinxstyleemphasis{P}\sphinxhyphen{}adic valuation for an integral ideal \sphinxstyleemphasis{I}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{primefactors}}(n{[}, limit, verbose{]})
&
\sphinxAtStartPar
Return a sorted list of n\textquotesingle{}s prime factors, ignoring multiplicity and any composite factor that remains if the limit was set too low for complete factorization.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{primerange}}(a{[}, b{]})
&
\sphinxAtStartPar
Generate a list of all prime numbers in the range {[}2, a), or {[}a, b).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{primitive}}(f, *gens, **args)
&
\sphinxAtStartPar
Compute content and the primitive form of \sphinxcode{\sphinxupquote{f}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{primitive\_element}}(extension{[}, x, ex, polys{]})
&
\sphinxAtStartPar
Find a single generator for a number field given by several generators.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{primitive\_root}}(p)
&
\sphinxAtStartPar
Returns the smallest primitive root or None.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{primorial}}(n{[}, nth{]})
&
\sphinxAtStartPar
Returns the product of the first n primes (default) or the primes less than or equal to n (when \sphinxcode{\sphinxupquote{nth=False}}).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{print\_ccode}}(expr, **settings)
&
\sphinxAtStartPar
Prints C representation of the given expression.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{print\_fcode}}(expr, **settings)
&
\sphinxAtStartPar
Prints the Fortran representation of the given expression.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{print\_glsl}}(expr, **settings)
&
\sphinxAtStartPar
Prints the GLSL representation of the given expression.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{print\_gtk}}(x{[}, start\_viewer{]})
&
\sphinxAtStartPar
Print to Gtkmathview, a gtk widget capable of rendering MathML.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{print\_jscode}}(expr, **settings)
&
\sphinxAtStartPar
Prints the Javascript representation of the given expression.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{print\_latex}}(expr, **settings)
&
\sphinxAtStartPar
Prints LaTeX representation of the given expression.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{print\_maple\_code}}(expr, **settings)
&
\sphinxAtStartPar
Prints the Maple representation of the given expression.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{print\_mathml}}(expr{[}, printer{]})
&
\sphinxAtStartPar
Prints a pretty representation of the MathML code for expr.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{print\_python}}(expr, **settings)
&
\sphinxAtStartPar
Print output of python() function
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{print\_rcode}}(expr, **settings)
&
\sphinxAtStartPar
Prints R representation of the given expression.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{print\_tree}}(node{[}, assumptions{]})
&
\sphinxAtStartPar
Prints a tree representation of "node".
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{prod}}(a{[}, start{]})
&
\sphinxAtStartPar
Return product of elements of a. Start with int 1 so if only
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{product}}(*args, **kwargs)
&
\sphinxAtStartPar
Compute the product.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{proper\_divisor\_count}}(n{[}, modulus{]})
&
\sphinxAtStartPar
Return the number of proper divisors of \sphinxcode{\sphinxupquote{n}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{proper\_divisors}}(n{[}, generator{]})
&
\sphinxAtStartPar
Return all divisors of n except n, sorted by default.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{public}}(obj)
&
\sphinxAtStartPar
Append \sphinxcode{\sphinxupquote{obj}}\textquotesingle{}s name to global \sphinxcode{\sphinxupquote{\_\_all\_\_}} variable (call site).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pycode}}(expr, **settings)
&
\sphinxAtStartPar
Converts an expr to a string of Python code
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{python}}(expr, **settings)
&
\sphinxAtStartPar
Return Python interpretation of passed expression (can be passed to the exec() function without any modifications)
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{quadratic\_congruence}}(a, b, c, p)
&
\sphinxAtStartPar
Find the solutions to {\color{red}\bfseries{}\textasciigrave{}\textasciigrave{}}a x**2 + b x + c = 0 mod p.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{quadratic\_residues}}(p)
&
\sphinxAtStartPar
Returns the list of quadratic residues.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{quo}}(f, g, *gens, **args)
&
\sphinxAtStartPar
Compute polynomial quotient of \sphinxcode{\sphinxupquote{f}} and \sphinxcode{\sphinxupquote{g}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{rad}}(d)
&
\sphinxAtStartPar
Return the radian value for the given degrees (pi = 180 degrees).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{radsimp}}(expr{[}, symbolic, max\_terms{]})
&
\sphinxAtStartPar
Rationalize the denominator by removing square roots.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{randMatrix}}(r{[}, c, min, max, seed, ...{]})
&
\sphinxAtStartPar
Create random matrix with dimensions \sphinxcode{\sphinxupquote{r}} x \sphinxcode{\sphinxupquote{c}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{random\_poly}}(x, n, inf, sup{[}, domain, polys{]})
&
\sphinxAtStartPar
Generates a polynomial of degree \sphinxcode{\sphinxupquote{n}} with coefficients in \sphinxcode{\sphinxupquote{{[}inf, sup{]}}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{randprime}}(a, b)
&
\sphinxAtStartPar
Return a random prime number in the range {[}a, b).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{rational\_interpolate}}(data, degnum{[}, X{]})
&
\sphinxAtStartPar
Returns a rational interpolation, where the data points are element of any integral domain.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ratsimp}}(expr)
&
\sphinxAtStartPar
Put an expression over a common denominator, cancel and reduce.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ratsimpmodprime}}(expr, G, *gens{[}, quick, ...{]})
&
\sphinxAtStartPar
Simplifies a rational expression \sphinxcode{\sphinxupquote{expr}} modulo the prime ideal generated by \sphinxcode{\sphinxupquote{G}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{rcode}}(expr{[}, assign\_to{]})
&
\sphinxAtStartPar
Converts an expr to a string of r code
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{rcollect}}(expr, *vars)
&
\sphinxAtStartPar
Recursively collect sums in an expression.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{real\_root}}(arg{[}, n, evaluate{]})
&
\sphinxAtStartPar
Return the real \sphinxstyleemphasis{n}\textquotesingle{}th\sphinxhyphen{}root of \sphinxstyleemphasis{arg} if possible.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{real\_roots}}(f{[}, multiple{]})
&
\sphinxAtStartPar
Return a list of real roots with multiplicities of \sphinxcode{\sphinxupquote{f}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{reduce\_abs\_inequalities}}(exprs, gen)
&
\sphinxAtStartPar
Reduce a system of inequalities with nested absolute values.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{reduce\_abs\_inequality}}(expr, rel, gen)
&
\sphinxAtStartPar
Reduce an inequality with nested absolute values.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{reduce\_inequalities}}(inequalities{[}, symbols{]})
&
\sphinxAtStartPar
Reduce a system of inequalities with rational coefficients.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{reduced}}(f, G, *gens, **args)
&
\sphinxAtStartPar
Reduces a polynomial \sphinxcode{\sphinxupquote{f}} modulo a set of polynomials \sphinxcode{\sphinxupquote{G}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{refine}}(expr{[}, assumptions{]})
&
\sphinxAtStartPar
Simplify an expression using assumptions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{refine\_root}}(f, s, t{[}, eps, steps, fast, ...{]})
&
\sphinxAtStartPar
Refine an isolating interval of a root to the given precision.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{register\_handler}}(key, handler)
&
\sphinxAtStartPar
Register a handler in the ask system.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{rem}}(f, g, *gens, **args)
&
\sphinxAtStartPar
Compute polynomial remainder of \sphinxcode{\sphinxupquote{f}} and \sphinxcode{\sphinxupquote{g}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{remove\_handler}}(key, handler)
&
\sphinxAtStartPar
Removes a handler from the ask system.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{reshape}}(seq, how)
&
\sphinxAtStartPar
Reshape the sequence according to the template in \sphinxcode{\sphinxupquote{how}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{residue}}(expr, x, x0)
&
\sphinxAtStartPar
Finds the residue of \sphinxcode{\sphinxupquote{expr}} at the point x=x0.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{resultant}}(f, g, *gens{[}, includePRS{]})
&
\sphinxAtStartPar
Compute resultant of \sphinxcode{\sphinxupquote{f}} and \sphinxcode{\sphinxupquote{g}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ring}}(symbols, domain{[}, order{]})
&
\sphinxAtStartPar
Construct a polynomial ring returning \sphinxcode{\sphinxupquote{(ring, x\_1, ..., x\_n)}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{root}}(arg, n{[}, k, evaluate{]})
&
\sphinxAtStartPar
Returns the \sphinxstyleemphasis{k}\sphinxhyphen{}th \sphinxstyleemphasis{n}\sphinxhyphen{}th root of \sphinxcode{\sphinxupquote{arg}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{rootof}}(f, x{[}, index, radicals, expand{]})
&
\sphinxAtStartPar
An indexed root of a univariate polynomial.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{roots}}(f, *gens{[}, auto, cubics, trig, ...{]})
&
\sphinxAtStartPar
Computes symbolic roots of a univariate polynomial.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{rot\_axis1}}(theta)
&
\sphinxAtStartPar
Returns a rotation matrix for a rotation of theta (in radians) about the 1\sphinxhyphen{}axis.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{rot\_axis2}}(theta)
&
\sphinxAtStartPar
Returns a rotation matrix for a rotation of theta (in radians) about the 2\sphinxhyphen{}axis.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{rot\_axis3}}(theta)
&
\sphinxAtStartPar
Returns a rotation matrix for a rotation of theta (in radians) about the 3\sphinxhyphen{}axis.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{rot\_ccw\_axis1}}(theta)
&
\sphinxAtStartPar
Returns a rotation matrix for a rotation of theta (in radians) about the 1\sphinxhyphen{}axis.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{rot\_ccw\_axis2}}(theta)
&
\sphinxAtStartPar
Returns a rotation matrix for a rotation of theta (in radians) about the 2\sphinxhyphen{}axis.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{rot\_ccw\_axis3}}(theta)
&
\sphinxAtStartPar
Returns a rotation matrix for a rotation of theta (in radians) about the 3\sphinxhyphen{}axis.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{rot\_givens}}(i, j, theta{[}, dim{]})
&
\sphinxAtStartPar
Returns a a Givens rotation matrix, a a rotation in the plane spanned by two coordinates axes.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{rotations}}(s{[}, dir{]})
&
\sphinxAtStartPar
Return a generator giving the items in s as list where each subsequent list has the items rotated to the left (default) or right (\sphinxcode{\sphinxupquote{dir=\sphinxhyphen{}1}}) relative to the previous list.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{round\_two}}(T{[}, radicals{]})
&
\sphinxAtStartPar
Zassenhaus\textquotesingle{}s "Round 2" algorithm.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{rsolve}}(f, y{[}, init{]})
&
\sphinxAtStartPar
Solve univariate recurrence with rational coefficients.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{rsolve\_hyper}}(coeffs, f, n, **hints)
&
\sphinxAtStartPar
Given linear recurrence operator \sphinxtitleref{operatorname\{L\}} of order \sphinxtitleref{k} with polynomial coefficients and inhomogeneous equation \sphinxtitleref{operatorname\{L\} y = f} we seek for all hypergeometric solutions over field \sphinxtitleref{K} of characteristic zero.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{rsolve\_poly}}(coeffs, f, n{[}, shift{]})
&
\sphinxAtStartPar
Given linear recurrence operator \sphinxtitleref{operatorname\{L\}} of order \sphinxtitleref{k} with polynomial coefficients and inhomogeneous equation \sphinxtitleref{operatorname\{L\} y = f}, where \sphinxtitleref{f} is a polynomial, we seek for all polynomial solutions over field \sphinxtitleref{K} of characteristic zero.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{rsolve\_ratio}}(coeffs, f, n, **hints)
&
\sphinxAtStartPar
Given linear recurrence operator \sphinxtitleref{operatorname\{L\}} of order \sphinxtitleref{k} with polynomial coefficients and inhomogeneous equation \sphinxtitleref{operatorname\{L\} y = f}, where \sphinxtitleref{f} is a polynomial, we seek for all rational solutions over field \sphinxtitleref{K} of characteristic zero.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{rust\_code}}(expr{[}, assign\_to{]})
&
\sphinxAtStartPar
Converts an expr to a string of Rust code
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{satisfiable}}(expr{[}, algorithm, all\_models, ...{]})
&
\sphinxAtStartPar
Check satisfiability of a propositional sentence.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{separatevars}}(expr{[}, symbols, dict, force{]})
&
\sphinxAtStartPar
Separates variables in an expression, if possible.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sequence}}(seq{[}, limits{]})
&
\sphinxAtStartPar
Returns appropriate sequence object.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{series}}(expr{[}, x, x0, n, dir{]})
&
\sphinxAtStartPar
Series expansion of expr around point \sphinxtitleref{x = x0}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{seterr}}({[}divide{]})
&
\sphinxAtStartPar
Should SymPy raise an exception on 0/0 or return a nan?
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sfield}}(exprs, *symbols, **options)
&
\sphinxAtStartPar
Construct a field deriving generators and domain from options and input expressions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{shape}}()
&
\sphinxAtStartPar
Return the shape of the \sphinxstyleemphasis{expr} as a tuple.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sift}}(seq, keyfunc{[}, binary{]})
&
\sphinxAtStartPar
Sift the sequence, \sphinxcode{\sphinxupquote{seq}} according to \sphinxcode{\sphinxupquote{keyfunc}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{signsimp}}(expr{[}, evaluate{]})
&
\sphinxAtStartPar
Make all Add sub\sphinxhyphen{}expressions canonical wrt sign.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{simplify}}(expr{[}, ratio, measure, rational, ...{]})
&
\sphinxAtStartPar
Simplifies the given expression.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{simplify\_logic}}(expr{[}, form, deep, force, ...{]})
&
\sphinxAtStartPar
This function simplifies a boolean function to its simplified version in SOP or POS form.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sine\_transform}}(f, x, k, **hints)
&
\sphinxAtStartPar
Compute the unitary, ordinary\sphinxhyphen{}frequency sine transform of \sphinxtitleref{f}, defined as
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{singularities}}(expression, symbol{[}, domain{]})
&
\sphinxAtStartPar
Find singularities of a given function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{singularityintegrate}}(f, x)
&
\sphinxAtStartPar
This function handles the indefinite integrations of Singularity functions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{smtlib\_code}}(expr{[}, auto\_assert, ...{]})
&
\sphinxAtStartPar
Converts \sphinxcode{\sphinxupquote{expr}} to a string of smtlib code.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{solve}}(f, *symbols, **flags)
&
\sphinxAtStartPar
Algebraically solves equations and systems of equations.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{solve\_linear}}(lhs{[}, rhs, symbols, exclude{]})
&
\sphinxAtStartPar
Return a tuple derived from \sphinxcode{\sphinxupquote{f = lhs \sphinxhyphen{} rhs}} that is one of the following: \sphinxcode{\sphinxupquote{(0, 1)}}, \sphinxcode{\sphinxupquote{(0, 0)}}, \sphinxcode{\sphinxupquote{(symbol, solution)}}, \sphinxcode{\sphinxupquote{(n, d)}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{solve\_linear\_system}}(system, *symbols, **flags)
&
\sphinxAtStartPar
Solve system of \$N\$ linear equations with \$M\$ variables, which means both under\sphinxhyphen{} and overdetermined systems are supported.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{solve\_linear\_system\_LU}}(matrix, syms)
&
\sphinxAtStartPar
Solves the augmented matrix system using \sphinxcode{\sphinxupquote{LUsolve}} and returns a dictionary in which solutions are keyed to the symbols of \sphinxstyleemphasis{syms} as ordered.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{solve\_poly\_inequality}}(poly, rel)
&
\sphinxAtStartPar
Solve a polynomial inequality with rational coefficients.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{solve\_poly\_system}}(seq, *gens{[}, strict{]})
&
\sphinxAtStartPar
Return a list of solutions for the system of polynomial equations or else None.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{solve\_rational\_inequalities}}(eqs)
&
\sphinxAtStartPar
Solve a system of rational inequalities with rational coefficients.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{solve\_triangulated}}(polys, *gens, **args)
&
\sphinxAtStartPar
Solve a polynomial system using Gianni\sphinxhyphen{}Kalkbrenner algorithm.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{solve\_undetermined\_coeffs}}(equ, coeffs, ...)
&
\sphinxAtStartPar
Solve a system of equations in \$k\$ parameters that is formed by matching coefficients in variables \sphinxcode{\sphinxupquote{coeffs}} that are on factors dependent on the remaining variables (or those given explicitly by \sphinxcode{\sphinxupquote{syms}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{solve\_univariate\_inequality}}(expr, gen{[}, ...{]})
&
\sphinxAtStartPar
Solves a real univariate inequality.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{solveset}}(f{[}, symbol, domain{]})
&
\sphinxAtStartPar
Solves a given inequality or equation with set as output
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sqf}}(f, *gens, **args)
&
\sphinxAtStartPar
Compute square\sphinxhyphen{}free factorization of \sphinxcode{\sphinxupquote{f}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sqf\_list}}(f, *gens, **args)
&
\sphinxAtStartPar
Compute a list of square\sphinxhyphen{}free factors of \sphinxcode{\sphinxupquote{f}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sqf\_norm}}(f, *gens, **args)
&
\sphinxAtStartPar
Compute square\sphinxhyphen{}free norm of \sphinxcode{\sphinxupquote{f}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sqf\_part}}(f, *gens, **args)
&
\sphinxAtStartPar
Compute square\sphinxhyphen{}free part of \sphinxcode{\sphinxupquote{f}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sqrt}}(arg{[}, evaluate{]})
&
\sphinxAtStartPar
Returns the principal square root.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sqrt\_mod}}(a, p{[}, all\_roots{]})
&
\sphinxAtStartPar
Find a root of \sphinxcode{\sphinxupquote{x**2 = a mod p}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sqrt\_mod\_iter}}(a, p{[}, domain{]})
&
\sphinxAtStartPar
Iterate over solutions to \sphinxcode{\sphinxupquote{x**2 = a mod p}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sqrtdenest}}(expr{[}, max\_iter{]})
&
\sphinxAtStartPar
Denests sqrts in an expression that contain other square roots if possible, otherwise returns the expr unchanged.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sring}}(exprs, *symbols, **options)
&
\sphinxAtStartPar
Construct a ring deriving generators and domain from options and input expressions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{stationary\_points}}(f, symbol{[}, domain{]})
&
\sphinxAtStartPar
Returns the stationary points of a function (where derivative of the function is 0) in the given domain.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sturm}}(f, *gens, **args)
&
\sphinxAtStartPar
Compute Sturm sequence of \sphinxcode{\sphinxupquote{f}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{subresultants}}(f, g, *gens, **args)
&
\sphinxAtStartPar
Compute subresultant PRS of \sphinxcode{\sphinxupquote{f}} and \sphinxcode{\sphinxupquote{g}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{subsets}}(seq{[}, k, repetition{]})
&
\sphinxAtStartPar
Generates all \sphinxtitleref{k}\sphinxhyphen{}subsets (combinations) from an \sphinxtitleref{n}\sphinxhyphen{}element set, \sphinxcode{\sphinxupquote{seq}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{substitution}}(system, symbols{[}, result, ...{]})
&
\sphinxAtStartPar
Solves the \sphinxtitleref{system} using substitution method.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{summation}}(f, *symbols, **kwargs)
&
\sphinxAtStartPar
Compute the summation of f with respect to symbols.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{swinnerton\_dyer\_poly}}(n{[}, x, polys{]})
&
\sphinxAtStartPar
Generates n\sphinxhyphen{}th Swinnerton\sphinxhyphen{}Dyer polynomial in \sphinxtitleref{x}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{symarray}}(prefix, shape, **kwargs)
&
\sphinxAtStartPar
Create a numpy ndarray of symbols (as an object array).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{symbols}}(names, *{[}, cls{]})
&
\sphinxAtStartPar
Transform strings into instances of \sphinxcode{\sphinxupquote{Symbol}} class.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{symmetric\_poly}}(n, *gens{[}, polys{]})
&
\sphinxAtStartPar
Generates symmetric polynomial of order \sphinxtitleref{n}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{symmetrize}}(F, *gens, **args)
&
\sphinxAtStartPar
Rewrite a polynomial in terms of elementary symmetric polynomials.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sympify}}(a{[}, locals, convert\_xor, strict, ...{]})
&
\sphinxAtStartPar
Converts an arbitrary expression to a type that can be used inside SymPy.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{take}}(iter, n)
&
\sphinxAtStartPar
Return \sphinxcode{\sphinxupquote{n}} items from \sphinxcode{\sphinxupquote{iter}} iterator.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{tensorcontraction}}(array, *contraction\_axes)
&
\sphinxAtStartPar
Contraction of an array\sphinxhyphen{}like object on the specified axes.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{tensordiagonal}}(array, *diagonal\_axes)
&
\sphinxAtStartPar
Diagonalization of an array\sphinxhyphen{}like object on the specified axes.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{tensorproduct}}(*args)
&
\sphinxAtStartPar
Tensor product among scalars or array\sphinxhyphen{}like objects.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{terms\_gcd}}(f, *gens, **args)
&
\sphinxAtStartPar
Remove GCD of terms from \sphinxcode{\sphinxupquote{f}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{textplot}}(expr, a, b{[}, W, H{]})
&
\sphinxAtStartPar
Print a crude ASCII art plot of the SymPy expression \textquotesingle{}expr\textquotesingle{} (which should contain a single symbol, e.g. x or something else) over the interval {[}a, b{]}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{threaded}}(func)
&
\sphinxAtStartPar
Apply \sphinxcode{\sphinxupquote{func}} to sub\sphinxhyphen{}\sphinxhyphen{}elements of an object, including \sphinxcode{\sphinxupquote{Add}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{timed}}(func{[}, setup, limit{]})
&
\sphinxAtStartPar
Adaptively measure execution time of a function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{to\_cnf}}(expr{[}, simplify, force{]})
&
\sphinxAtStartPar
Convert a propositional logical sentence \sphinxcode{\sphinxupquote{expr}} to conjunctive normal form: \sphinxcode{\sphinxupquote{((A | \textasciitilde{}B | ...) \& (B | C | ...) \& ...)}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{to\_dnf}}(expr{[}, simplify, force{]})
&
\sphinxAtStartPar
Convert a propositional logical sentence \sphinxcode{\sphinxupquote{expr}} to disjunctive normal form: \sphinxcode{\sphinxupquote{((A \& \textasciitilde{}B \& ...) | (B \& C \& ...) | ...)}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{to\_nnf}}(expr{[}, simplify{]})
&
\sphinxAtStartPar
Converts \sphinxcode{\sphinxupquote{expr}} to Negation Normal Form (NNF).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{to\_number\_field}}(extension{[}, theta, gen, alias{]})
&
\sphinxAtStartPar
Express one algebraic number in the field generated by another.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{together}}(expr{[}, deep, fraction{]})
&
\sphinxAtStartPar
Denest and combine rational expressions using symbolic methods.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{topological\_sort}}(graph{[}, key{]})
&
\sphinxAtStartPar
Topological sort of graph\textquotesingle{}s vertices.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{total\_degree}}(f, *gens)
&
\sphinxAtStartPar
Return the total\_degree of \sphinxcode{\sphinxupquote{f}} in the given variables.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{trace}}(expr)
&
\sphinxAtStartPar
Trace of a Matrix.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{trailing}}(n)
&
\sphinxAtStartPar
Count the number of trailing zero digits in the binary representation of n, i.e. determine the largest power of 2 that divides n.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{trigsimp}}(expr{[}, inverse{]})
&
\sphinxAtStartPar
Returns a reduced expression by using known trig identities.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{trunc}}(f, p, *gens, **args)
&
\sphinxAtStartPar
Reduce \sphinxcode{\sphinxupquote{f}} modulo a constant \sphinxcode{\sphinxupquote{p}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{unbranched\_argument}}(arg)
&
\sphinxAtStartPar
Returns periodic argument of arg with period as infinity.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{unflatten}}(iter{[}, n{]})
&
\sphinxAtStartPar
Group \sphinxcode{\sphinxupquote{iter}} into tuples of length \sphinxcode{\sphinxupquote{n}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{unpolarify}}(eq{[}, subs, exponents\_only{]})
&
\sphinxAtStartPar
If \sphinxtitleref{p} denotes the projection from the Riemann surface of the logarithm to the complex line, return a simplified version \sphinxtitleref{eq\textquotesingle{}} of \sphinxtitleref{eq} such that \sphinxtitleref{p(eq\textquotesingle{}) = p(eq)}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{use}}(expr, func{[}, level, args, kwargs{]})
&
\sphinxAtStartPar
Use \sphinxcode{\sphinxupquote{func}} to transform \sphinxcode{\sphinxupquote{expr}} at the given level.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{var}}(names, **args)
&
\sphinxAtStartPar
Create symbols and inject them into the global namespace.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{variations}}(seq, n{[}, repetition{]})
&
\sphinxAtStartPar
Returns an iterator over the n\sphinxhyphen{}sized variations of \sphinxcode{\sphinxupquote{seq}} (size N).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{vfield}}(symbols, domain{[}, order{]})
&
\sphinxAtStartPar
Construct new rational function field and inject generators into global namespace.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{viete}}(f{[}, roots{]})
&
\sphinxAtStartPar
Generate Viete\textquotesingle{}s formulas for \sphinxcode{\sphinxupquote{f}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{vring}}(symbols, domain{[}, order{]})
&
\sphinxAtStartPar
Construct a polynomial ring and inject \sphinxcode{\sphinxupquote{x\_1, ..., x\_n}} into the global namespace.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{wronskian}}(functions, var{[}, method{]})
&
\sphinxAtStartPar
Compute Wronskian for {[}{]} of functions
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{xfield}}(symbols, domain{[}, order{]})
&
\sphinxAtStartPar
Construct new rational function field returning (field, (x1, ..., xn)).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{xring}}(symbols, domain{[}, order{]})
&
\sphinxAtStartPar
Construct a polynomial ring returning \sphinxcode{\sphinxupquote{(ring, (x\_1, ..., x\_n))}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{xthreaded}}(func)
&
\sphinxAtStartPar
Apply \sphinxcode{\sphinxupquote{func}} to sub\sphinxhyphen{}\sphinxhyphen{}elements of an object, excluding \sphinxcode{\sphinxupquote{Add}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{zeros}}(*args, **kwargs)
&
\sphinxAtStartPar
Returns a matrix of zeros with \sphinxcode{\sphinxupquote{rows}} rows and \sphinxcode{\sphinxupquote{cols}} columns; if \sphinxcode{\sphinxupquote{cols}} is omitted a square matrix will be returned.
\\
\sphinxbottomrule
\end{longtable}
\sphinxtableafterendhook
\sphinxatlongtableend
\end{savenotes}
\subsubsection*{Classes}


\begin{savenotes}
\sphinxatlongtablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\makeatletter
  \LTleft \@totalleftmargin plus1fill
  \LTright\dimexpr\columnwidth-\@totalleftmargin-\linewidth\relax plus1fill
\makeatother
\begin{longtable}{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\endfirsthead

\multicolumn{2}{c}{\sphinxnorowcolor
    \makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}%
}\\
\sphinxtoprule
\endhead

\sphinxbottomrule
\multicolumn{2}{r}{\sphinxnorowcolor
    \makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}%
}\\
\endfoot

\endlastfoot
\sphinxtableatstartofbodyhook

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Abs}}(arg)
&
\sphinxAtStartPar
Return the absolute value of the argument.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{AccumBounds}}
&
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{AccumulationBounds}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Add}}(*args{[}, evaluate, \_sympify{]})
&
\sphinxAtStartPar
Expression representing addition operation for algebraic group.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Adjoint}}(*args, **kwargs)
&
\sphinxAtStartPar
The Hermitian adjoint of a matrix expression.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{AlgebraicField}}(dom, *ext{[}, alias{]})
&
\sphinxAtStartPar
Algebraic number field \DUrole{xref}{\DUrole{std}{\DUrole{std-ref}{QQ(a)}}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{AlgebraicNumber}}(expr{[}, coeffs, alias{]})
&
\sphinxAtStartPar
Class for representing algebraic numbers in SymPy.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{And}}(*args)
&
\sphinxAtStartPar
Logical AND function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{AppliedPredicate}}(predicate, *args)
&
\sphinxAtStartPar
The class of expressions resulting from applying \sphinxcode{\sphinxupquote{Predicate}} to the arguments.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Array}}
&
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{ImmutableDenseNDimArray}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{AssumptionsContext}}
&
\sphinxAtStartPar
Set containing default assumptions which are applied to the \sphinxcode{\sphinxupquote{ask()}} function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Atom}}(*args)
&
\sphinxAtStartPar
A parent class for atomic things.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{AtomicExpr}}(*args)
&
\sphinxAtStartPar
A parent class for object which are both atoms and Exprs.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{AutoSympy}}(model)
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Basic}}(*args)
&
\sphinxAtStartPar
Base class for all SymPy objects.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{BlockDiagMatrix}}(*mats)
&
\sphinxAtStartPar
A sparse matrix with block matrices along its diagonals
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{BlockMatrix}}(*args, **kwargs)
&
\sphinxAtStartPar
A BlockMatrix is a Matrix comprised of other matrices.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{CRootOf}}
&
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{ComplexRootOf}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Chi}}(z)
&
\sphinxAtStartPar
Cosh integral.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Ci}}(z)
&
\sphinxAtStartPar
Cosine integral.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Circle}}(*args, **kwargs)
&
\sphinxAtStartPar
A circle in space.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Complement}}(a, b{[}, evaluate{]})
&
\sphinxAtStartPar
Represents the set difference or relative complement of a set with another set.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ComplexField}}({[}prec, dps, tol{]})
&
\sphinxAtStartPar
Complex numbers up to the given precision.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ComplexRegion}}(sets{[}, polar{]})
&
\sphinxAtStartPar
Represents the Set of all Complex Numbers.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ComplexRootOf}}(f, x{[}, index, radicals, expand{]})
&
\sphinxAtStartPar
Represents an indexed complex root of a polynomial.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ConditionSet}}(sym, condition{[}, base\_set{]})
&
\sphinxAtStartPar
Set of elements which satisfies a given condition.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Contains}}(x, s)
&
\sphinxAtStartPar
Asserts that x is an element of the set S.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{CoordMap}}(var\_vector, eq\_duals, ineq\_duals, ...)
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{CosineTransform}}(*args)
&
\sphinxAtStartPar
Class representing unevaluated cosine transforms.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Curve}}(function, limits)
&
\sphinxAtStartPar
A curve in space.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{DeferredVector}}(name, **assumptions)
&
\sphinxAtStartPar
A vector whose components are deferred (e.g. for use with lambdify).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{DenseNDimArray}}(*args, **kwargs)
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Derivative}}(expr, *variables, **kwargs)
&
\sphinxAtStartPar
Carries out differentiation of the given expression with respect to symbols.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Determinant}}(mat)
&
\sphinxAtStartPar
Matrix Determinant
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{DiagMatrix}}(vector)
&
\sphinxAtStartPar
Turn a vector into a diagonal matrix.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{DiagonalMatrix}}(*args, **kwargs)
&
\sphinxAtStartPar
DiagonalMatrix(M) will create a matrix expression that behaves as though all off\sphinxhyphen{}diagonal elements, \sphinxtitleref{M{[}i, j{]}} where \sphinxtitleref{i != j}, are zero.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{DiagonalOf}}(*args, **kwargs)
&
\sphinxAtStartPar
DiagonalOf(M) will create a matrix expression that is equivalent to the diagonal of \sphinxtitleref{M}, represented as a single column matrix.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Dict}}(*args)
&
\sphinxAtStartPar
Wrapper around the builtin dict object.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{DifferentialMapping}}(US, coord2item, ...)
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{DiracDelta}}(arg{[}, k{]})
&
\sphinxAtStartPar
The DiracDelta function and its derivatives.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{DisjointUnion}}(*sets)
&
\sphinxAtStartPar
Represents the disjoint union (also known as the external disjoint union) of a finite number of sets.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Domain}}()
&
\sphinxAtStartPar
Superclass for all domains in the polys domains system.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{DotProduct}}(arg1, arg2)
&
\sphinxAtStartPar
Dot product of vector matrices
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Dummy}}({[}name, dummy\_index{]})
&
\sphinxAtStartPar
Dummy symbols are each unique, even if they have the same name:
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{EPath}}(path)
&
\sphinxAtStartPar
Manipulate expressions using paths.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Ei}}(z)
&
\sphinxAtStartPar
The classical exponential integral.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Ellipse}}({[}center, hradius, vradius, eccentricity{]})
&
\sphinxAtStartPar
An elliptical GeometryEntity.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Eq}}
&
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{Equality}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Equality}}(lhs, rhs, **options)
&
\sphinxAtStartPar
An equal relation between two objects.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Equivalent}}(*args)
&
\sphinxAtStartPar
Equivalence relation.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Expr}}(*args)
&
\sphinxAtStartPar
Base class for algebraic expressions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ExpressionDomain}}()
&
\sphinxAtStartPar
A class for arbitrary expressions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{FF}}
&
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{FiniteField}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{FF\_gmpy}}
&
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{GMPYFiniteField}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{FF\_python}}
&
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{PythonFiniteField}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{FallingFactorial}}(x, k)
&
\sphinxAtStartPar
Falling factorial (related to rising factorial) is a double valued function arising in concrete mathematics, hypergeometric functions and series expansions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{FiniteField}}(mod{[}, symmetric{]})
&
\sphinxAtStartPar
Finite field of prime order \DUrole{xref}{\DUrole{std}{\DUrole{std-ref}{GF(p)}}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{FiniteSet}}(*args, **kwargs)
&
\sphinxAtStartPar
Represents a finite set of Sympy expressions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Float}}(num{[}, dps, precision{]})
&
\sphinxAtStartPar
Represent a floating\sphinxhyphen{}point number of arbitrary precision.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{FourierTransform}}(*args)
&
\sphinxAtStartPar
Class representing unevaluated Fourier transforms.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{FractionField}}(domain\_or\_field{[}, symbols, order{]})
&
\sphinxAtStartPar
A class for representing multivariate rational function fields.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Function}}(*args)
&
\sphinxAtStartPar
Base class for applied mathematical functions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{FunctionClass}}(*args, **kwargs)
&
\sphinxAtStartPar
Base class for function classes.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{FunctionMatrix}}(rows, cols, lamda)
&
\sphinxAtStartPar
Represents a matrix using a function (\sphinxcode{\sphinxupquote{Lambda}}) which gives outputs according to the coordinates of each matrix entries.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{GF}}
&
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{FiniteField}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{GMPYFiniteField}}(mod{[}, symmetric{]})
&
\sphinxAtStartPar
Finite field based on GMPY integers.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{GMPYIntegerRing}}()
&
\sphinxAtStartPar
Integer ring based on GMPY\textquotesingle{}s \sphinxcode{\sphinxupquote{mpz}} type.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{GMPYRationalField}}()
&
\sphinxAtStartPar
Rational field based on GMPY\textquotesingle{}s \sphinxcode{\sphinxupquote{mpq}} type.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Ge}}
&
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{GreaterThan}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{GreaterThan}}(lhs, rhs, **options)
&
\sphinxAtStartPar
Class representations of inequalities.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{GroebnerBasis}}(F, *gens, **args)
&
\sphinxAtStartPar
Represents a reduced Groebner basis.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Gt}}
&
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{StrictGreaterThan}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{HadamardPower}}(base, exp)
&
\sphinxAtStartPar
Elementwise power of matrix expressions
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{HadamardProduct}}(*args{[}, evaluate, check{]})
&
\sphinxAtStartPar
Elementwise product of matrix expressions
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{HankelTransform}}(*args)
&
\sphinxAtStartPar
Class representing unevaluated Hankel transforms.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Heaviside}}(arg{[}, H0{]})
&
\sphinxAtStartPar
Heaviside step function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ITE}}(*args)
&
\sphinxAtStartPar
If\sphinxhyphen{}then\sphinxhyphen{}else clause.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Identity}}(n)
&
\sphinxAtStartPar
The Matrix Identity I \sphinxhyphen{} multiplicative identity
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Idx}}(label{[}, range{]})
&
\sphinxAtStartPar
Represents an integer index as an \sphinxcode{\sphinxupquote{Integer}} or integer expression.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ImageSet}}(flambda, *sets)
&
\sphinxAtStartPar
Image of a set under a mathematical function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ImmutableDenseMatrix}}(*args, **kwargs)
&
\sphinxAtStartPar
Create an immutable version of a matrix.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ImmutableDenseNDimArray}}(iterable{[}, shape{]})
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ImmutableMatrix}}
&
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{ImmutableDenseMatrix}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ImmutableSparseMatrix}}(*args, **kwargs)
&
\sphinxAtStartPar
Create an immutable version of a sparse matrix.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ImmutableSparseNDimArray}}({[}iterable, shape{]})
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Implies}}(*args)
&
\sphinxAtStartPar
Logical implication.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Indexed}}(base, *args, **kw\_args)
&
\sphinxAtStartPar
Represents a mathematical object with indices.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{IndexedBase}}(label{[}, shape, offset, strides{]})
&
\sphinxAtStartPar
Represent the base or stem of an indexed object
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Integer}}(i)
&
\sphinxAtStartPar
Represents integer numbers of any size.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{IntegerRing}}()
&
\sphinxAtStartPar
The domain \sphinxcode{\sphinxupquote{ZZ}} representing the integers \sphinxtitleref{mathbb\{Z\}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Integral}}(function, *symbols, **assumptions)
&
\sphinxAtStartPar
Represents unevaluated integral.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Intersection}}(*args, **kwargs)
&
\sphinxAtStartPar
Represents an intersection of sets as a \sphinxcode{\sphinxupquote{Set}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Interval}}(start, end{[}, left\_open, right\_open{]})
&
\sphinxAtStartPar
Represents a real interval as a Set.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Inverse}}(mat{[}, exp{]})
&
\sphinxAtStartPar
The multiplicative inverse of a matrix expression
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{InverseCosineTransform}}(*args)
&
\sphinxAtStartPar
Class representing unevaluated inverse cosine transforms.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{InverseFourierTransform}}(*args)
&
\sphinxAtStartPar
Class representing unevaluated inverse Fourier transforms.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{InverseHankelTransform}}(*args)
&
\sphinxAtStartPar
Class representing unevaluated inverse Hankel transforms.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{InverseLaplaceTransform}}(*args)
&
\sphinxAtStartPar
Class representing unevaluated inverse Laplace transforms.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{InverseMellinTransform}}(*args)
&
\sphinxAtStartPar
Class representing unevaluated inverse Mellin transforms.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{InverseSineTransform}}(*args)
&
\sphinxAtStartPar
Class representing unevaluated inverse sine transforms.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{KroneckerDelta}}(i, j{[}, delta\_range{]})
&
\sphinxAtStartPar
The discrete, or Kronecker, delta function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{KroneckerProduct}}(*args{[}, check{]})
&
\sphinxAtStartPar
The Kronecker product of two or more arguments.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Lambda}}(signature, expr)
&
\sphinxAtStartPar
Lambda(x, expr) represents a lambda function similar to Python\textquotesingle{}s \textquotesingle{}lambda x: expr\textquotesingle{}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{LambertW}}(x{[}, k{]})
&
\sphinxAtStartPar
The Lambert W function \$W(z)\$ is defined as the inverse function of \$w exp(w)\$ {\color{red}\bfseries{}{[}1{]}\_}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{LaplaceTransform}}(*args)
&
\sphinxAtStartPar
Class representing unevaluated Laplace transforms.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Le}}
&
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{LessThan}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{LessThan}}(lhs, rhs, **options)
&
\sphinxAtStartPar
Class representations of inequalities.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{LeviCivita}}(*args)
&
\sphinxAtStartPar
Represent the Levi\sphinxhyphen{}Civita symbol.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Li}}(z)
&
\sphinxAtStartPar
The offset logarithmic integral.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Limit}}(e, z, z0{[}, dir{]})
&
\sphinxAtStartPar
Represents an unevaluated limit.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Line}}(*args, **kwargs)
&
\sphinxAtStartPar
An infinite line in space.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Line2D}}(p1{[}, pt, slope{]})
&
\sphinxAtStartPar
An infinite line in space 2D.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Line3D}}(p1{[}, pt, direction\_ratio{]})
&
\sphinxAtStartPar
An infinite 3D line in space.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Lt}}
&
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{StrictLessThan}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{MatAdd}}(*args{[}, evaluate, check, \_sympify{]})
&
\sphinxAtStartPar
A Sum of Matrix Expressions
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{MatMul}}(*args{[}, evaluate, check, \_sympify{]})
&
\sphinxAtStartPar
A product of matrix expressions
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{MatPow}}(base, exp{[}, evaluate{]})
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Matrix}}
&
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{MutableDenseMatrix}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{MatrixBase}}()
&
\sphinxAtStartPar
Base class for matrix objects.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{MatrixExpr}}(*args, **kwargs)
&
\sphinxAtStartPar
Superclass for Matrix Expressions
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{MatrixPermute}}(mat, perm{[}, axis{]})
&
\sphinxAtStartPar
Symbolic representation for permuting matrix rows or columns.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{MatrixSlice}}(parent, rowslice, colslice)
&
\sphinxAtStartPar
A MatrixSlice of a Matrix Expression
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{MatrixSymbol}}(name, n, m)
&
\sphinxAtStartPar
Symbolic representation of a Matrix object
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Max}}(*args)
&
\sphinxAtStartPar
Return, if possible, the maximum value of the list.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{MellinTransform}}(*args)
&
\sphinxAtStartPar
Class representing unevaluated Mellin transforms.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Min}}(*args)
&
\sphinxAtStartPar
Return, if possible, the minimum value of the list.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Mod}}(p, q)
&
\sphinxAtStartPar
Represents a modulo operation on symbolic expressions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Monomial}}(monom{[}, gens{]})
&
\sphinxAtStartPar
Class representing a monomial, i.e. a product of powers.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Mul}}(*args{[}, evaluate, \_sympify{]})
&
\sphinxAtStartPar
Expression representing multiplication operation for algebraic field.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{MutableDenseMatrix}}(*args, **kwargs)
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{MutableDenseNDimArray}}({[}iterable, shape{]})
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{MutableMatrix}}
&
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{MutableDenseMatrix}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{MutableSparseMatrix}}(*args, **kwargs)
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{MutableSparseNDimArray}}({[}iterable, shape{]})
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{NDimArray}}(iterable{[}, shape{]})
&
\sphinxAtStartPar
N\sphinxhyphen{}dimensional array.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Nand}}(*args)
&
\sphinxAtStartPar
Logical NAND function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Ne}}
&
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{Unequality}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Nor}}(*args)
&
\sphinxAtStartPar
Logical NOR function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Not}}(arg)
&
\sphinxAtStartPar
Logical Not function (negation)
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Number}}(*obj)
&
\sphinxAtStartPar
Represents atomic numbers in SymPy.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{NumberSymbol}}()
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{O}}
&
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{Order}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{OmegaPower}}(a, b)
&
\sphinxAtStartPar
Represents ordinal exponential and multiplication terms one of the building blocks of the \sphinxcode{\sphinxupquote{Ordinal}} class.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{OneMatrix}}(m, n{[}, evaluate{]})
&
\sphinxAtStartPar
Matrix whose all entries are ones.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Options}}(gens, args{[}, flags, strict{]})
&
\sphinxAtStartPar
Options manager for polynomial manipulation module.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Or}}(*args)
&
\sphinxAtStartPar
Logical OR function
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Order}}(expr, *args, **kwargs)
&
\sphinxAtStartPar
Represents the limiting behavior of some function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Ordinal}}(*terms)
&
\sphinxAtStartPar
Represents ordinals in Cantor normal form.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Parabola}}({[}focus, directrix{]})
&
\sphinxAtStartPar
A parabolic GeometryEntity.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Permanent}}(mat)
&
\sphinxAtStartPar
Matrix Permanent
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{PermutationMatrix}}(perm)
&
\sphinxAtStartPar
A Permutation Matrix
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Piecewise}}(*\_args)
&
\sphinxAtStartPar
Represents a piecewise function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Plane}}(p1{[}, a, b{]})
&
\sphinxAtStartPar
A plane is a flat, two\sphinxhyphen{}dimensional surface.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Point}}(*args, **kwargs)
&
\sphinxAtStartPar
A point in a n\sphinxhyphen{}dimensional Euclidean space.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Point2D}}(*args{[}, \_nocheck{]})
&
\sphinxAtStartPar
A point in a 2\sphinxhyphen{}dimensional Euclidean space.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Point3D}}(*args{[}, \_nocheck{]})
&
\sphinxAtStartPar
A point in a 3\sphinxhyphen{}dimensional Euclidean space.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Poly}}(rep, *gens, **args)
&
\sphinxAtStartPar
Generic class for representing and operating on polynomial expressions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Polygon}}(*args{[}, n{]})
&
\sphinxAtStartPar
A two\sphinxhyphen{}dimensional polygon.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{PolynomialRing}}(domain\_or\_ring{[}, symbols, order{]})
&
\sphinxAtStartPar
A class for representing multivariate polynomial rings.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Pow}}(b, e{[}, evaluate{]})
&
\sphinxAtStartPar
Defines the expression x**y as "x raised to a power y"
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{PowerSet}}(arg{[}, evaluate{]})
&
\sphinxAtStartPar
A symbolic object representing a power set.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Predicate}}(*args, **kwargs)
&
\sphinxAtStartPar
Base class for mathematical predicates.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Product}}(function, *symbols, **assumptions)
&
\sphinxAtStartPar
Represents unevaluated products.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ProductSet}}(*sets, **assumptions)
&
\sphinxAtStartPar
Represents a Cartesian Product of Sets.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{PurePoly}}(rep, *gens, **args)
&
\sphinxAtStartPar
Class for representing pure polynomials.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{PythonFiniteField}}(mod{[}, symmetric{]})
&
\sphinxAtStartPar
Finite field based on Python\textquotesingle{}s integers.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{PythonIntegerRing}}()
&
\sphinxAtStartPar
Integer ring based on Python\textquotesingle{}s \sphinxcode{\sphinxupquote{int}} type.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{PythonRational}}
&
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{PythonMPQ}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{QQ\_gmpy}}
&
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{GMPYRationalField}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{QQ\_python}}
&
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{PythonRationalField}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Quaternion}}({[}a, b, c, d, real\_field, norm{]})
&
\sphinxAtStartPar
Provides basic quaternion operations.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Range}}(*args)
&
\sphinxAtStartPar
Represents a range of integers.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Rational}}(p{[}, q, gcd{]})
&
\sphinxAtStartPar
Represents rational numbers (p/q) of any size.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{RationalField}}()
&
\sphinxAtStartPar
Abstract base class for the domain \DUrole{xref}{\DUrole{std}{\DUrole{std-ref}{QQ}}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Ray}}(p1{[}, p2{]})
&
\sphinxAtStartPar
A Ray is a semi\sphinxhyphen{}line in the space with a source point and a direction.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Ray2D}}(p1{[}, pt, angle{]})
&
\sphinxAtStartPar
A Ray is a semi\sphinxhyphen{}line in the space with a source point and a direction.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Ray3D}}(p1{[}, pt, direction\_ratio{]})
&
\sphinxAtStartPar
A Ray is a semi\sphinxhyphen{}line in the space with a source point and a direction.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{RealField}}({[}prec, dps, tol{]})
&
\sphinxAtStartPar
Real numbers up to the given precision.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{RealNumber}}
&
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{Float}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{RegularPolygon}}(c, r, n{[}, rot{]})
&
\sphinxAtStartPar
A regular polygon.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Rel}}
&
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{Relational}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Rem}}(p, q)
&
\sphinxAtStartPar
Returns the remainder when \sphinxcode{\sphinxupquote{p}} is divided by \sphinxcode{\sphinxupquote{q}} where \sphinxcode{\sphinxupquote{p}} is finite and \sphinxcode{\sphinxupquote{q}} is not equal to zero.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{RisingFactorial}}(x, k)
&
\sphinxAtStartPar
Rising factorial (also called Pochhammer symbol {\color{red}\bfseries{}{[}1{]}\_}) is a double valued function arising in concrete mathematics, hypergeometric functions and series expansions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{RootOf}}(f, x{[}, index, radicals, expand{]})
&
\sphinxAtStartPar
Represents a root of a univariate polynomial.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{RootSum}}(expr{[}, func, x, auto, quadratic{]})
&
\sphinxAtStartPar
Represents a sum of all roots of a univariate polynomial.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Segment}}(p1, p2, **kwargs)
&
\sphinxAtStartPar
A line segment in space.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Segment2D}}(p1, p2, **kwargs)
&
\sphinxAtStartPar
A line segment in 2D space.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Segment3D}}(p1, p2, **kwargs)
&
\sphinxAtStartPar
A line segment in a 3D space.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SensitivityMatrix}}(sympification, duals, ...)
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SeqAdd}}(*args, **kwargs)
&
\sphinxAtStartPar
Represents term\sphinxhyphen{}wise addition of sequences.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SeqFormula}}(formula{[}, limits{]})
&
\sphinxAtStartPar
Represents sequence based on a formula.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SeqMul}}(*args, **kwargs)
&
\sphinxAtStartPar
Represents term\sphinxhyphen{}wise multiplication of sequences.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SeqPer}}(periodical{[}, limits{]})
&
\sphinxAtStartPar
Represents a periodic sequence.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Set}}(*args)
&
\sphinxAtStartPar
The base class for any kind of set.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Shi}}(z)
&
\sphinxAtStartPar
Sinh integral.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Si}}(z)
&
\sphinxAtStartPar
Sine integral.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Sieve}}()
&
\sphinxAtStartPar
An infinite list of prime numbers, implemented as a dynamically growing sieve of Eratosthenes.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SineTransform}}(*args)
&
\sphinxAtStartPar
Class representing unevaluated sine transforms.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SingularityFunction}}(variable, offset, exponent)
&
\sphinxAtStartPar
Singularity functions are a class of discontinuous functions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SparseMatrix}}
&
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{MutableSparseMatrix}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SparseNDimArray}}(*args, **kwargs)
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{StrPrinter}}({[}settings{]})
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{StrictGreaterThan}}(lhs, rhs, **options)
&
\sphinxAtStartPar
Class representations of inequalities.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{StrictLessThan}}(lhs, rhs, **options)
&
\sphinxAtStartPar
Class representations of inequalities.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Subs}}(expr, variables, point, **assumptions)
&
\sphinxAtStartPar
Represents unevaluated substitutions of an expression.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Sum}}(function, *symbols, **assumptions)
&
\sphinxAtStartPar
Represents unevaluated summation.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Symbol}}(name, **assumptions)
&
\sphinxAtStartPar
Assumptions:
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SymmetricDifference}}(a, b{[}, evaluate{]})
&
\sphinxAtStartPar
Represents the set of elements which are in either of the sets and not in their intersection.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{TableForm}}(data, **kwarg)
&
\sphinxAtStartPar
Create a nice table representation of data.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.sensitivity.babymodel:src.sensitivity.babymodel.TestBabyModel}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{TestBabyModel}}}}}(*args, **kwds)
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Trace}}(mat)
&
\sphinxAtStartPar
Matrix Trace
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Transpose}}(*args, **kwargs)
&
\sphinxAtStartPar
The transpose of a matrix expression.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Triangle}}(*args, **kwargs)
&
\sphinxAtStartPar
A polygon with three vertices and three sides.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Tuple}}(*args, **kwargs)
&
\sphinxAtStartPar
Wrapper around the builtin tuple object.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Unequality}}(lhs, rhs, **options)
&
\sphinxAtStartPar
An unequal relation between two objects.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{UnevaluatedExpr}}(arg, **kwargs)
&
\sphinxAtStartPar
Expression that is not evaluated unless released.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Union}}(*args, **kwargs)
&
\sphinxAtStartPar
Represents a union of sets as a \sphinxcode{\sphinxupquote{Set}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Wild}}(name{[}, exclude, properties{]})
&
\sphinxAtStartPar
A Wild symbol matches anything, or anything without whatever is explicitly excluded.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{WildFunction}}(*args)
&
\sphinxAtStartPar
A WildFunction function matches any function (with its arguments).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Xor}}(*args)
&
\sphinxAtStartPar
Logical XOR (exclusive OR) function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Ynm}}(n, m, theta, phi)
&
\sphinxAtStartPar
Spherical harmonics defined as
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ZZ\_gmpy}}
&
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{GMPYIntegerRing}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ZZ\_python}}
&
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{PythonIntegerRing}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ZeroMatrix}}(m, n)
&
\sphinxAtStartPar
The Matrix Zero 0 \sphinxhyphen{} additive identity
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Znm}}(n, m, theta, phi)
&
\sphinxAtStartPar
Real spherical harmonics defined as
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{acos}}(arg)
&
\sphinxAtStartPar
The inverse cosine function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{acosh}}(arg)
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{acosh(x)}} is the inverse hyperbolic cosine of \sphinxcode{\sphinxupquote{x}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{acot}}(arg)
&
\sphinxAtStartPar
The inverse cotangent function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{acoth}}(arg)
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{acoth(x)}} is the inverse hyperbolic cotangent of \sphinxcode{\sphinxupquote{x}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{acsc}}(arg)
&
\sphinxAtStartPar
The inverse cosecant function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{acsch}}(arg)
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{acsch(x)}} is the inverse hyperbolic cosecant of \sphinxcode{\sphinxupquote{x}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{adjoint}}(arg)
&
\sphinxAtStartPar
Conjugate transpose or Hermite conjugation.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{airyai}}(arg)
&
\sphinxAtStartPar
The Airy function \$operatorname\{Ai\}\$ of the first kind.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{airyaiprime}}(arg)
&
\sphinxAtStartPar
The derivative \$operatorname\{Ai\}\textasciicircum{}prime\$ of the Airy function of the first kind.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{airybi}}(arg)
&
\sphinxAtStartPar
The Airy function \$operatorname\{Bi\}\$ of the second kind.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{airybiprime}}(arg)
&
\sphinxAtStartPar
The derivative \$operatorname\{Bi\}\textasciicircum{}prime\$ of the Airy function of the first kind.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{andre}}(n)
&
\sphinxAtStartPar
Andre numbers / Andre function
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{appellf1}}(a, b1, b2, c, x, y)
&
\sphinxAtStartPar
This is the Appell hypergeometric function of two variables as:
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{arg}}(arg)
&
\sphinxAtStartPar
Returns the argument (in radians) of a complex number.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{asec}}(arg)
&
\sphinxAtStartPar
The inverse secant function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{asech}}(arg)
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{asech(x)}} is the inverse hyperbolic secant of \sphinxcode{\sphinxupquote{x}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{asin}}(arg)
&
\sphinxAtStartPar
The inverse sine function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{asinh}}(arg)
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{asinh(x)}} is the inverse hyperbolic sine of \sphinxcode{\sphinxupquote{x}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{assoc\_laguerre}}(n, alpha, x)
&
\sphinxAtStartPar
Returns the \$n\$th generalized Laguerre polynomial in \$x\$, \$L\_n(x)\$.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{assoc\_legendre}}(n, m, x)
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{assoc\_legendre(n, m, x)}} gives \$P\_n\textasciicircum{}m(x)\$, where \$n\$ and \$m\$ are the degree and order or an expression which is related to the nth order Legendre polynomial, \$P\_n(x)\$ in the following manner:
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{atan}}(arg)
&
\sphinxAtStartPar
The inverse tangent function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{atan2}}(y, x)
&
\sphinxAtStartPar
The function \sphinxcode{\sphinxupquote{atan2(y, x)}} computes \sphinxtitleref{operatorname\{atan\}(y/x)} taking two arguments \sphinxtitleref{y} and \sphinxtitleref{x}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{atanh}}(arg)
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{atanh(x)}} is the inverse hyperbolic tangent of \sphinxcode{\sphinxupquote{x}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{bell}}(n{[}, k\_sym, symbols{]})
&
\sphinxAtStartPar
Bell numbers / Bell polynomials
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{bernoulli}}(n{[}, x{]})
&
\sphinxAtStartPar
Bernoulli numbers / Bernoulli polynomials / Bernoulli function
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{besseli}}(nu, z)
&
\sphinxAtStartPar
Modified Bessel function of the first kind.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{besselj}}(nu, z)
&
\sphinxAtStartPar
Bessel function of the first kind.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{besselk}}(nu, z)
&
\sphinxAtStartPar
Modified Bessel function of the second kind.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{bessely}}(nu, z)
&
\sphinxAtStartPar
Bessel function of the second kind.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{beta}}(x{[}, y{]})
&
\sphinxAtStartPar
The beta integral is called the Eulerian integral of the first kind by Legendre:
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{betainc}}(*args)
&
\sphinxAtStartPar
The Generalized Incomplete Beta function is defined as
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{betainc\_regularized}}(*args)
&
\sphinxAtStartPar
The Generalized Regularized Incomplete Beta function is given by
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{binomial}}(n, k)
&
\sphinxAtStartPar
Implementation of the binomial coefficient.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{carmichael}}(*args)
&
\sphinxAtStartPar
Carmichael Numbers:
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{cartes}}
&
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{product}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{catalan}}(n)
&
\sphinxAtStartPar
Catalan numbers
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ceiling}}(arg)
&
\sphinxAtStartPar
Ceiling is a univariate function which returns the smallest integer value not less than its argument.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{chebyshevt}}(n, x)
&
\sphinxAtStartPar
Chebyshev polynomial of the first kind, \$T\_n(x)\$.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{chebyshevt\_root}}(n, k)
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{chebyshev\_root(n, k)}} returns the \$k\$th root (indexed from zero) of the \$n\$th Chebyshev polynomial of the first kind; that is, if \$0 le k \textless{} n\$, \sphinxcode{\sphinxupquote{chebyshevt(n, chebyshevt\_root(n, k)) == 0}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{chebyshevu}}(n, x)
&
\sphinxAtStartPar
Chebyshev polynomial of the second kind, \$U\_n(x)\$.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{chebyshevu\_root}}(n, k)
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{chebyshevu\_root(n, k)}} returns the \$k\$th root (indexed from zero) of the \$n\$th Chebyshev polynomial of the second kind; that is, if \$0 le k \textless{} n\$, \sphinxcode{\sphinxupquote{chebyshevu(n, chebyshevu\_root(n, k)) == 0}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{conjugate}}(arg)
&
\sphinxAtStartPar
Returns the \sphinxstyleemphasis{complex conjugate} {\color{red}\bfseries{}{[}1{]}\_} of an argument.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{cos}}(arg)
&
\sphinxAtStartPar
The cosine function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{cosh}}(arg)
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{cosh(x)}} is the hyperbolic cosine of \sphinxcode{\sphinxupquote{x}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{cot}}(arg)
&
\sphinxAtStartPar
The cotangent function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{coth}}(arg)
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{coth(x)}} is the hyperbolic cotangent of \sphinxcode{\sphinxupquote{x}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{csc}}(arg)
&
\sphinxAtStartPar
The cosecant function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{csch}}(arg)
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{csch(x)}} is the hyperbolic cosecant of \sphinxcode{\sphinxupquote{x}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{defaultdict}}
&
\sphinxAtStartPar
defaultdict(default\_factory=None, /, {[}...{]}) \sphinxhyphen{}\sphinxhyphen{}\textgreater{} dict with default factory
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{digamma}}(z)
&
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{digamma}} function is the first derivative of the \sphinxcode{\sphinxupquote{loggamma}} function
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{dirichlet\_eta}}(s{[}, a{]})
&
\sphinxAtStartPar
Dirichlet eta function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{divisor\_sigma}}(n{[}, k{]})
&
\sphinxAtStartPar
Calculate the divisor function \sphinxtitleref{sigma\_k(n)} for positive integer n
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{elliptic\_e}}(m{[}, z{]})
&
\sphinxAtStartPar
Called with two arguments \$z\$ and \$m\$, evaluates the incomplete elliptic integral of the second kind, defined by
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{elliptic\_f}}(z, m)
&
\sphinxAtStartPar
The Legendre incomplete elliptic integral of the first kind, defined by
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{elliptic\_k}}(m)
&
\sphinxAtStartPar
The complete elliptic integral of the first kind, defined by
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{elliptic\_pi}}(n, m{[}, z{]})
&
\sphinxAtStartPar
Called with three arguments \$n\$, \$z\$ and \$m\$, evaluates the Legendre incomplete elliptic integral of the third kind, defined by
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{erf}}(arg)
&
\sphinxAtStartPar
The Gauss error function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{erf2}}(x, y)
&
\sphinxAtStartPar
Two\sphinxhyphen{}argument error function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{erf2inv}}(x, y)
&
\sphinxAtStartPar
Two\sphinxhyphen{}argument Inverse error function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{erfc}}(arg)
&
\sphinxAtStartPar
Complementary Error Function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{erfcinv}}(z)
&
\sphinxAtStartPar
Inverse Complementary Error Function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{erfi}}(z)
&
\sphinxAtStartPar
Imaginary error function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{erfinv}}(z)
&
\sphinxAtStartPar
Inverse Error Function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{euler}}(n{[}, x{]})
&
\sphinxAtStartPar
Euler numbers / Euler polynomials / Euler function
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{exp}}(arg)
&
\sphinxAtStartPar
The exponential function, \(e^x\).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{exp\_polar}}(*args)
&
\sphinxAtStartPar
Represent a \sphinxstyleemphasis{polar number} (see g\sphinxhyphen{}function Sphinx documentation).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{expint}}(nu, z)
&
\sphinxAtStartPar
Generalized exponential integral.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{factorial}}(n)
&
\sphinxAtStartPar
Implementation of factorial function over nonnegative integers.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{factorial2}}(arg)
&
\sphinxAtStartPar
The double factorial \sphinxtitleref{n!!}, not to be confused with \sphinxtitleref{(n!)!}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ff}}
&
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{FallingFactorial}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{fibonacci}}(n{[}, sym{]})
&
\sphinxAtStartPar
Fibonacci numbers / Fibonacci polynomials
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{floor}}(arg)
&
\sphinxAtStartPar
Floor is a univariate function which returns the largest integer value not greater than its argument.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{frac}}(arg)
&
\sphinxAtStartPar
Represents the fractional part of x
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{fresnelc}}(z)
&
\sphinxAtStartPar
Fresnel integral C.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{fresnels}}(z)
&
\sphinxAtStartPar
Fresnel integral S.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{gamma}}(arg)
&
\sphinxAtStartPar
The gamma function
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{gegenbauer}}(n, a, x)
&
\sphinxAtStartPar
Gegenbauer polynomial \$C\_n\textasciicircum{}\{left(alpharight)\}(x)\$.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{genocchi}}(n{[}, x{]})
&
\sphinxAtStartPar
Genocchi numbers / Genocchi polynomials / Genocchi function
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hankel1}}(nu, z)
&
\sphinxAtStartPar
Hankel function of the first kind.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hankel2}}(nu, z)
&
\sphinxAtStartPar
Hankel function of the second kind.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{harmonic}}(n{[}, m{]})
&
\sphinxAtStartPar
Harmonic numbers
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hermite}}(n, x)
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hermite(n, x)}} gives the \$n\$th Hermite polynomial in \$x\$, \$H\_n(x)\$.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hermite\_prob}}(n, x)
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hermite\_prob(n, x)}} gives the \$n\$th probabilist\textquotesingle{}s Hermite polynomial in \$x\$, \$He\_n(x)\$.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hn1}}(nu, z)
&
\sphinxAtStartPar
Spherical Hankel function of the first kind.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hn2}}(nu, z)
&
\sphinxAtStartPar
Spherical Hankel function of the second kind.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hyper}}(ap, bq, z)
&
\sphinxAtStartPar
The generalized hypergeometric function is defined by a series where the ratios of successive terms are a rational function of the summation index.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{im}}(arg)
&
\sphinxAtStartPar
Returns imaginary part of expression.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{jacobi}}(n, a, b, x)
&
\sphinxAtStartPar
Jacobi polynomial \$P\_n\textasciicircum{}\{left(alpha, betaright)\}(x)\$.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{jn}}(nu, z)
&
\sphinxAtStartPar
Spherical Bessel function of the first kind.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{laguerre}}(n, x)
&
\sphinxAtStartPar
Returns the \$n\$th Laguerre polynomial in \$x\$, \$L\_n(x)\$.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{legendre}}(n, x)
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{legendre(n, x)}} gives the \$n\$th Legendre polynomial of \$x\$, \$P\_n(x)\$
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{lerchphi}}(*args)
&
\sphinxAtStartPar
Lerch transcendent (Lerch phi function).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{li}}(z)
&
\sphinxAtStartPar
The classical logarithmic integral.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ln}}
&
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{log}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{log}}(arg{[}, base{]})
&
\sphinxAtStartPar
The natural logarithm function \sphinxtitleref{ln(x)} or \sphinxtitleref{log(x)}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{loggamma}}(z)
&
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{loggamma}} function implements the logarithm of the gamma function (i.e., \$logGamma(x)\$).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{lowergamma}}(a, x)
&
\sphinxAtStartPar
The lower incomplete gamma function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{lucas}}(n)
&
\sphinxAtStartPar
Lucas numbers
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{marcumq}}(m, a, b)
&
\sphinxAtStartPar
The Marcum Q\sphinxhyphen{}function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mathieuc}}(a, q, z)
&
\sphinxAtStartPar
The Mathieu Cosine function \$C(a,q,z)\$.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mathieucprime}}(a, q, z)
&
\sphinxAtStartPar
The derivative \$C\textasciicircum{}\{prime\}(a,q,z)\$ of the Mathieu Cosine function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mathieus}}(a, q, z)
&
\sphinxAtStartPar
The Mathieu Sine function \$S(a,q,z)\$.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mathieusprime}}(a, q, z)
&
\sphinxAtStartPar
The derivative \$S\textasciicircum{}\{prime\}(a,q,z)\$ of the Mathieu Sine function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{meijerg}}(*args)
&
\sphinxAtStartPar
The Meijer G\sphinxhyphen{}function is defined by a Mellin\sphinxhyphen{}Barnes type integral that resembles an inverse Mellin transform.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mobius}}(n)
&
\sphinxAtStartPar
Mobius function maps natural number to \{\sphinxhyphen{}1, 0, 1\}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{motzkin}}(n)
&
\sphinxAtStartPar
The nth Motzkin number is the number
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{multigamma}}(x, p)
&
\sphinxAtStartPar
The multivariate gamma function is a generalization of the gamma function
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{partition}}(n)
&
\sphinxAtStartPar
Partition numbers
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{periodic\_argument}}(ar, period)
&
\sphinxAtStartPar
Represent the argument on a quotient of the Riemann surface of the logarithm.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{polar\_lift}}(arg)
&
\sphinxAtStartPar
Lift argument to the Riemann surface of the logarithm, using the standard branch.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{polygamma}}(n, z)
&
\sphinxAtStartPar
The function \sphinxcode{\sphinxupquote{polygamma(n, z)}} returns \sphinxcode{\sphinxupquote{log(gamma(z)).diff(n + 1)}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{polylog}}(s, z)
&
\sphinxAtStartPar
Polylogarithm function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{preorder\_traversal}}(node{[}, keys{]})
&
\sphinxAtStartPar
Do a pre\sphinxhyphen{}order traversal of a tree.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{primenu}}(n)
&
\sphinxAtStartPar
Calculate the number of distinct prime factors for a positive integer n.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{primeomega}}(n)
&
\sphinxAtStartPar
Calculate the number of prime factors counting multiplicities for a positive integer n.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{primepi}}(n)
&
\sphinxAtStartPar
Represents the prime counting function pi(n) = the number of prime numbers less than or equal to n.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{principal\_branch}}(x, period)
&
\sphinxAtStartPar
Represent a polar number reduced to its principal branch on a quotient of the Riemann surface of the logarithm.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{re}}(arg)
&
\sphinxAtStartPar
Returns real part of expression.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{reduced\_totient}}(n)
&
\sphinxAtStartPar
Calculate the Carmichael reduced totient function lambda(n)
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{rf}}
&
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{RisingFactorial}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{riemann\_xi}}(s)
&
\sphinxAtStartPar
Riemann Xi function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sec}}(arg)
&
\sphinxAtStartPar
The secant function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sech}}(arg)
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sech(x)}} is the hyperbolic secant of \sphinxcode{\sphinxupquote{x}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sign}}(arg)
&
\sphinxAtStartPar
Returns the complex sign of an expression:
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sin}}(arg)
&
\sphinxAtStartPar
The sine function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sinc}}(arg)
&
\sphinxAtStartPar
Represents an unnormalized sinc function:
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sinh}}(arg)
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sinh(x)}} is the hyperbolic sine of \sphinxcode{\sphinxupquote{x}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{stieltjes}}(n{[}, a{]})
&
\sphinxAtStartPar
Represents Stieltjes constants, \$gamma\_\{k\}\$ that occur in Laurent Series expansion of the Riemann zeta function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{subfactorial}}(arg)
&
\sphinxAtStartPar
The subfactorial counts the derangements of \$n\$ items and is defined for non\sphinxhyphen{}negative integers as:
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{tan}}(arg)
&
\sphinxAtStartPar
The tangent function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{tanh}}(arg)
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{tanh(x)}} is the hyperbolic tangent of \sphinxcode{\sphinxupquote{x}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{totient}}(n)
&
\sphinxAtStartPar
Calculate the Euler totient function phi(n)
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{transpose}}(arg)
&
\sphinxAtStartPar
Linear map transposition.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{tribonacci}}(n{[}, sym{]})
&
\sphinxAtStartPar
Tribonacci numbers / Tribonacci polynomials
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{trigamma}}(z)
&
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{trigamma}} function is the second derivative of the \sphinxcode{\sphinxupquote{loggamma}} function
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{uppergamma}}(a, z)
&
\sphinxAtStartPar
The upper incomplete gamma function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{vectorize}}(*mdargs)
&
\sphinxAtStartPar
Generalizes a function taking scalars to accept multidimensional arguments.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{yn}}(nu, z)
&
\sphinxAtStartPar
Spherical Bessel function of the second kind.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{zeta}}(s{[}, a{]})
&
\sphinxAtStartPar
Hurwitz zeta function (or Riemann zeta function).
\\
\sphinxbottomrule
\end{longtable}
\sphinxtableafterendhook
\sphinxatlongtableend
\end{savenotes}
\subsubsection*{Exceptions}


\begin{savenotes}
\sphinxatlongtablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\makeatletter
  \LTleft \@totalleftmargin plus1fill
  \LTright\dimexpr\columnwidth-\@totalleftmargin-\linewidth\relax plus1fill
\makeatother
\begin{longtable}{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\endfirsthead

\multicolumn{2}{c}{\sphinxnorowcolor
    \makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}%
}\\
\sphinxtoprule
\endhead

\sphinxbottomrule
\multicolumn{2}{r}{\sphinxnorowcolor
    \makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}%
}\\
\endfoot

\endlastfoot
\sphinxtableatstartofbodyhook

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{BasePolynomialError}}
&
\sphinxAtStartPar
Base class for polynomial related exceptions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{CoercionFailed}}
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ComputationFailed}}(func, nargs, exc)
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{DomainError}}
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{EvaluationFailed}}
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ExactQuotientFailed}}(f, g{[}, dom{]})
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ExtraneousFactors}}
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{FlagError}}
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{GeneratorsError}}
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{GeneratorsNeeded}}
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{GeometryError}}
&
\sphinxAtStartPar
An exception raised by classes in the geometry module.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{HeuristicGCDFailed}}
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{HomomorphismFailed}}
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{IsomorphismFailed}}
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{MultivariatePolynomialError}}
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{NonSquareMatrixError}}
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{NotAlgebraic}}
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{NotInvertible}}
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{NotReversible}}
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{OperationNotSupported}}(poly, func)
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{OptionError}}
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{PoleError}}
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{PolificationFailed}}(opt, origs, exprs{[}, seq{]})
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{PolynomialDivisionFailed}}(f, g, domain)
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{PolynomialError}}
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{PrecisionExhausted}}
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{RefinementFailed}}
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ShapeError}}
&
\sphinxAtStartPar
Wrong matrix shape
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SympifyError}}(expr{[}, base\_exc{]})
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{UnificationFailed}}
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{UnivariatePolynomialError}}
&
\sphinxAtStartPar

\\
\sphinxbottomrule
\end{longtable}
\sphinxtableafterendhook
\sphinxatlongtableend
\end{savenotes}
\index{TestBabyModel (class in src.sensitivity.babymodel)@\spxentry{TestBabyModel}\spxextra{class in src.sensitivity.babymodel}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.sensitivity.babymodel:src.sensitivity.babymodel.TestBabyModel}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{\DUrole{k}{class}\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{src.sensitivity.babymodel.}}\sphinxbfcode{\sphinxupquote{TestBabyModel}}}
{\sphinxparam{\DUrole{o}{*}\DUrole{n}{args}}\sphinxparamcomma \sphinxparam{\DUrole{o}{**}\DUrole{n}{kwds}}}
{}
\pysigstopsignatures\index{\_active (src.sensitivity.babymodel.TestBabyModel attribute)@\spxentry{\_active}\spxextra{src.sensitivity.babymodel.TestBabyModel attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.sensitivity.babymodel:src.sensitivity.babymodel.TestBabyModel._active}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{\_active}}}
\pysigstopsignatures
\end{fulllineitems}

\index{solve() (src.sensitivity.babymodel.TestBabyModel method)@\spxentry{solve()}\spxextra{src.sensitivity.babymodel.TestBabyModel method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.sensitivity.babymodel:src.sensitivity.babymodel.TestBabyModel.solve}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{solve}}}
{}
{}
\pysigstopsignatures
\end{fulllineitems}


\end{fulllineitems}

\index{connect\_regions() (in module src.sensitivity.babymodel)@\spxentry{connect\_regions()}\spxextra{in module src.sensitivity.babymodel}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.sensitivity.babymodel:src.sensitivity.babymodel.connect_regions}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{src.sensitivity.babymodel.}}\sphinxbfcode{\sphinxupquote{connect\_regions}}}
{\sphinxparam{\DUrole{n}{region\_map}}\sphinxparamcomma \sphinxparam{\DUrole{n}{hubmap}}\sphinxparamcomma \sphinxparam{\DUrole{n}{base\_trans\_cap}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
given a mapping of regions to lists of hubs, and hubs to regions, creates
a set of arcs between hubs such that:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
the grid is connected

\item {} 
\sphinxAtStartPar
each region has a main hub that all other hubs in the region are connected to

\end{enumerate}
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{region\_map}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} dictionary of region names to lists of hubs

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{hubmap}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} dictionary of hub names to their parent region

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{base\_trans\_cap}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} base transportation capacity for arcs

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{arcs} (\sphinxstyleemphasis{list}) \textendash{} list of tuples of hubs, representing start and endpoints

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{outbound} (\sphinxstyleemphasis{dict}) \textendash{} dictionary of hub:list of arcs originating from hub

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{inbound} (\sphinxstyleemphasis{dict}) \textendash{} dictionary of hub:list of arcs terminating at hub

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{trans\_capacity} (\sphinxstyleemphasis{dict}) \textendash{} dictionary of arcs:transportation capacity of arc

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{generate() (in module src.sensitivity.babymodel)@\spxentry{generate()}\spxextra{in module src.sensitivity.babymodel}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.sensitivity.babymodel:src.sensitivity.babymodel.generate}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{src.sensitivity.babymodel.}}\sphinxbfcode{\sphinxupquote{generate}}}
{\sphinxparam{\DUrole{n}{num\_regions}\DUrole{o}{=}\DUrole{default_value}{3}}\sphinxparamcomma \sphinxparam{\DUrole{n}{hubs\_per\_region}\DUrole{o}{=}\DUrole{default_value}{2}}\sphinxparamcomma \sphinxparam{\DUrole{n}{base\_elec\_price}\DUrole{o}{=}\DUrole{default_value}{5.0}}\sphinxparamcomma \sphinxparam{\DUrole{n}{base\_prod\_capacity}\DUrole{o}{=}\DUrole{default_value}{5000}}\sphinxparamcomma \sphinxparam{\DUrole{n}{demand\_fraction}\DUrole{o}{=}\DUrole{default_value}{0.7}}\sphinxparamcomma \sphinxparam{\DUrole{n}{base\_transport\_cost}\DUrole{o}{=}\DUrole{default_value}{22.3}}\sphinxparamcomma \sphinxparam{\DUrole{n}{base\_elec\_consumption}\DUrole{o}{=}\DUrole{default_value}{9.8}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
generates a random network with all parameters required to initialize a ToyBabyModel
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{num\_regions}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} number of regions. Defaults to 3.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{hubs\_per\_region}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} number of hubs per region. Defaults to 2.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{base\_elec\_price}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} the average electricity price in all regions. Defaults to 5.0.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{base\_prod\_capacity}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} the average production capacity for all hubs. Defaults to 5000.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{demand\_fraction}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} the average fraction of capacity initial demand is set to. Defaults to 0.7.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{base\_transport\_cost}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} the base transportation cost for all arcs. Defaults to 22.3.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{base\_elec\_consumption}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} the electricity consumption rate for production. Defaults to 9.8.

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{hublist} (\sphinxstyleemphasis{list})

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{region\_list} (\sphinxstyleemphasis{list})

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{hub\_map} (\sphinxstyleemphasis{dict})

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{region\_map} (\sphinxstyleemphasis{dict})

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{elec\_price} (\sphinxstyleemphasis{dict})

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{prod\_capacity} (\sphinxstyleemphasis{dict})

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{demand} (\sphinxstyleemphasis{dict})

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{base\_elec\_consumption} (\sphinxstyleemphasis{float})

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{base\_transport\_cost} (\sphinxstyleemphasis{float})

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}


\sphinxstepscope


\paragraph{src.sensitivity.faster\_sensitivity}
\label{\detokenize{src.sensitivity.faster_sensitivity:module-src.sensitivity.faster_sensitivity}}\label{\detokenize{src.sensitivity.faster_sensitivity:src-sensitivity-faster-sensitivity}}\label{\detokenize{src.sensitivity.faster_sensitivity::doc}}\index{module@\spxentry{module}!src.sensitivity.faster\_sensitivity@\spxentry{src.sensitivity.faster\_sensitivity}}\index{src.sensitivity.faster\_sensitivity@\spxentry{src.sensitivity.faster\_sensitivity}!module@\spxentry{module}}
\sphinxAtStartPar
faster\_sensitivity

\sphinxAtStartPar
This file contains the class SensitivityMatrix which  takes in sympy objects that have been converted from pyomo. It builds the matrix of partials to be used in sensitivity analysis.

\sphinxAtStartPar
It also contains class AutoSympy which takes in pyomo models and converts the objects into sympy.

\sphinxAtStartPar
Finally, it contains class toy\_model, the sensitivity method in action and then runs toy\_model with input n=5.
\begin{description}
\sphinxlineitem{The file babymodel.py can be also use this method by importing this file instead of sensitivity\_tools.py by:}
\sphinxAtStartPar
from faster\_sensitivity import *

\end{description}
\subsubsection*{Classes}


\begin{savenotes}
\sphinxatlongtablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\makeatletter
  \LTleft \@totalleftmargin plus1fill
  \LTright\dimexpr\columnwidth-\@totalleftmargin-\linewidth\relax plus1fill
\makeatother
\begin{longtable}{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\endfirsthead

\multicolumn{2}{c}{\sphinxnorowcolor
    \makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}%
}\\
\sphinxtoprule
\endhead

\sphinxbottomrule
\multicolumn{2}{r}{\sphinxnorowcolor
    \makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}%
}\\
\endfoot

\endlastfoot
\sphinxtableatstartofbodyhook

\sphinxAtStartPar
{\hyperref[\detokenize{src.sensitivity.faster_sensitivity:src.sensitivity.faster_sensitivity.AutoSympy}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{AutoSympy}}}}}(model)
&
\sphinxAtStartPar
This class take in pyomo models and converts the objects into sympy.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.sensitivity.faster_sensitivity:src.sensitivity.faster_sensitivity.SensitivityMatrix}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{SensitivityMatrix}}}}}(sympification, duals, ...)
&
\sphinxAtStartPar
This class takes in sympy objects that have been converted from pyomo.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{date}}
&
\sphinxAtStartPar
date(year, month, day) \sphinxhyphen{}\sphinxhyphen{}\textgreater{} date object
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{datetime}}(year, month, day{[}, hour{[}, minute{[}, ...)
&
\sphinxAtStartPar
The year, month and day arguments are required.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{time}}
&
\sphinxAtStartPar
time({[}hour{[}, minute{[}, second{[}, microsecond{[}, tzinfo{]}{]}{]}{]}{]}) \sphinxhyphen{}\sphinxhyphen{}\textgreater{} a time object
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{timedelta}}
&
\sphinxAtStartPar
Difference between two datetime values.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{timezone}}
&
\sphinxAtStartPar
Fixed offset from UTC implementation of tzinfo.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.sensitivity.faster_sensitivity:src.sensitivity.faster_sensitivity.toy_model}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{toy\_model}}}}}(n)
&
\sphinxAtStartPar
An example of the method in action that scales by the given \textquotesingle{}n\textquotesingle{} value
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{tzinfo}}
&
\sphinxAtStartPar
Abstract base class for time zone info objects.
\\
\sphinxbottomrule
\end{longtable}
\sphinxtableafterendhook
\sphinxatlongtableend
\end{savenotes}
\index{AutoSympy (class in src.sensitivity.faster\_sensitivity)@\spxentry{AutoSympy}\spxextra{class in src.sensitivity.faster\_sensitivity}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.sensitivity.faster_sensitivity:src.sensitivity.faster_sensitivity.AutoSympy}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{\DUrole{k}{class}\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{src.sensitivity.faster\_sensitivity.}}\sphinxbfcode{\sphinxupquote{AutoSympy}}}
{\sphinxparam{\DUrole{n}{model}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
This class take in pyomo models and converts the objects into sympy.
This is useful for problems that needs methods such as derivatives to be calculated on the equations.
We use these derivatives to calculate a sensitivity matrix that estimates the changes in variables due to changes in parameters
\index{check\_complimentarity\_all() (src.sensitivity.faster\_sensitivity.AutoSympy method)@\spxentry{check\_complimentarity\_all()}\spxextra{src.sensitivity.faster\_sensitivity.AutoSympy method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.sensitivity.faster_sensitivity:src.sensitivity.faster_sensitivity.AutoSympy.check_complimentarity_all}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{check\_complimentarity\_all}}}
{}
{}
\pysigstopsignatures
\end{fulllineitems}

\index{generate\_duals() (src.sensitivity.faster\_sensitivity.AutoSympy method)@\spxentry{generate\_duals()}\spxextra{src.sensitivity.faster\_sensitivity.AutoSympy method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.sensitivity.faster_sensitivity:src.sensitivity.faster_sensitivity.AutoSympy.generate_duals}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{generate\_duals}}}
{\sphinxparam{\DUrole{n}{constraints}}\sphinxparamcomma \sphinxparam{\DUrole{n}{duals}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Uses dual values and slack values to classify each constraint. It also stores the dual values for substitution later.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{constraints}} (\sphinxstyleliteralemphasis{\sphinxupquote{model.component\_objects}}\sphinxstyleliteralemphasis{\sphinxupquote{(}}\sphinxstyleliteralemphasis{\sphinxupquote{pyo.Constraint}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} All of the constraint objects from the pyomo model

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{duals}} (\sphinxstyleliteralemphasis{\sphinxupquote{model.dual}}) \textendash{} All of the dual (or Suffix) objects from the pyomo model

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\_description\_

\sphinxlineitem{Return type}
\sphinxAtStartPar
dict of lists and dicts

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_constraints() (src.sensitivity.faster\_sensitivity.AutoSympy method)@\spxentry{get\_constraints()}\spxextra{src.sensitivity.faster\_sensitivity.AutoSympy method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.sensitivity.faster_sensitivity:src.sensitivity.faster_sensitivity.AutoSympy.get_constraints}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{get\_constraints}}}
{}
{}
\pysigstopsignatures
\sphinxAtStartPar
This function converts all of the constraints in the pyomo object and converts the pyomo expressions into sympy expressions.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
Returns 2 dictionaries:
equality\_constraints: keys are tuples (constraint\_name, index) and values are sympy expressions
inequality\_constraints: keys are tuples (constraint\_name, index) and values are sympy expressions

\sphinxlineitem{Return type}
\sphinxAtStartPar
dict, dict

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_objective() (src.sensitivity.faster\_sensitivity.AutoSympy method)@\spxentry{get\_objective()}\spxextra{src.sensitivity.faster\_sensitivity.AutoSympy method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.sensitivity.faster_sensitivity:src.sensitivity.faster_sensitivity.AutoSympy.get_objective}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{get\_objective}}}
{}
{}
\pysigstopsignatures
\sphinxAtStartPar
This converts the pyomo objective function into a sympy function.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
The pyomo objective function converted into sympy

\sphinxlineitem{Return type}
\sphinxAtStartPar
sympy equation

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_parameters() (src.sensitivity.faster\_sensitivity.AutoSympy method)@\spxentry{get\_parameters()}\spxextra{src.sensitivity.faster\_sensitivity.AutoSympy method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.sensitivity.faster_sensitivity:src.sensitivity.faster_sensitivity.AutoSympy.get_parameters}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{get\_parameters}}}
{}
{}
\pysigstopsignatures
\sphinxAtStartPar
Convert pyomo parameters into sympy objects.
This procedure creates sympy IndexedBase objects and sympy Symbol objects of similar names.
The IndexedBase datatype is necessary to parse the equations, but it does not work well with derivatives.
We will substitute in Symbols when the equations are all created, so they need to map to each other.
To keep the columns in order through all procedures, all parameters are given a unique column number by the variable “position”
This position is stored in the class dict param\_position\_map
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
Returns 4 dictionaries:
parameters: keys are pyomo parameter names and values are sympy IndexedBase objects with the same name
parameter\_values: keys are sympy symbols and values are the numerical values of the pyomo objects
parameter\_index\_sets: keys are pyomo parameter names and values are lists of that parameters indices
symbol\_map: keys are pyomo parameters with an index and values are sympy symbols with a similarly styled name and index

\sphinxlineitem{Return type}
\sphinxAtStartPar
dict, dict, dict, dict

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_sensitivity\_matrix() (src.sensitivity.faster\_sensitivity.AutoSympy method)@\spxentry{get\_sensitivity\_matrix()}\spxextra{src.sensitivity.faster\_sensitivity.AutoSympy method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.sensitivity.faster_sensitivity:src.sensitivity.faster_sensitivity.AutoSympy.get_sensitivity_matrix}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{get\_sensitivity\_matrix}}}
{\sphinxparam{\DUrole{n}{parameters\_of\_interest}\DUrole{o}{=}\DUrole{default_value}{None}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
This function gathers all of the new sympy objects and creates a SensitivityMatrix object.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{parameters\_of\_interest}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Specified subset of the parameters if more information is known about needless parameters, by default None

\sphinxlineitem{Returns}
\sphinxAtStartPar
a SensitivityMatrix object that contains the sensitivity matrix and commands to use it.

\sphinxlineitem{Return type}
\sphinxAtStartPar
{\hyperref[\detokenize{src.sensitivity.faster_sensitivity:src.sensitivity.faster_sensitivity.SensitivityMatrix}]{\sphinxcrossref{SensitivityMatrix}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_sets() (src.sensitivity.faster\_sensitivity.AutoSympy method)@\spxentry{get\_sets()}\spxextra{src.sensitivity.faster\_sensitivity.AutoSympy method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.sensitivity.faster_sensitivity:src.sensitivity.faster_sensitivity.AutoSympy.get_sets}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{get\_sets}}}
{}
{}
\pysigstopsignatures
\sphinxAtStartPar
Convert pyomo sets into sympy indexes
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
The first dictionary has the pyomo objects’ names as keys and newly created sympy indexes as values.
The second dictionary has the new sympy indexes as keys and the pyomo sets’ values as the dict values.

\sphinxlineitem{Return type}
\sphinxAtStartPar
dict, dict

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_variables() (src.sensitivity.faster\_sensitivity.AutoSympy method)@\spxentry{get\_variables()}\spxextra{src.sensitivity.faster\_sensitivity.AutoSympy method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.sensitivity.faster_sensitivity:src.sensitivity.faster_sensitivity.AutoSympy.get_variables}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{get\_variables}}}
{}
{}
\pysigstopsignatures
\sphinxAtStartPar
Convert pyomo variables into sympy objects.
This procedure creates sympy IndexedBase objects and sympy Symbol objects of similar names.
The IndexedBase datatype is necessary to parse the equations, but it does not work well with derivatives.
We will substitute in Symbols when the equations are all created, so they need to map to each other.
To keep the columns in order through all procedures, all parameters are given a unique column number by the variable “position”
This position is stored in the class dict param\_position\_map
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
Returns 2 dictionaries:
variables: keys are pyomo variable names and values are sympy IndexedBase objects with the same name
variable values: keys are sympy symbols and values are the numerical values of the pyomo objects
It is also worth mentioning that this adds entries to the self.symbol\_map in the same way parameters do.
Symbol map entries have keys of IndexedBase objects and the values are their associated sympy Symbol

\sphinxlineitem{Return type}
\sphinxAtStartPar
dict, dict

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{SensitivityMatrix (class in src.sensitivity.faster\_sensitivity)@\spxentry{SensitivityMatrix}\spxextra{class in src.sensitivity.faster\_sensitivity}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.sensitivity.faster_sensitivity:src.sensitivity.faster_sensitivity.SensitivityMatrix}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{\DUrole{k}{class}\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{src.sensitivity.faster\_sensitivity.}}\sphinxbfcode{\sphinxupquote{SensitivityMatrix}}}
{\sphinxparam{\DUrole{n}{sympification}}\sphinxparamcomma \sphinxparam{\DUrole{n}{duals}}\sphinxparamcomma \sphinxparam{\DUrole{n}{parameters\_of\_interest}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
This class takes in sympy objects that have been converted from pyomo.
It builds the matrix of partials to be used in sensitivity analysis.
\index{generate\_matrix() (src.sensitivity.faster\_sensitivity.SensitivityMatrix method)@\spxentry{generate\_matrix()}\spxextra{src.sensitivity.faster\_sensitivity.SensitivityMatrix method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.sensitivity.faster_sensitivity:src.sensitivity.faster_sensitivity.SensitivityMatrix.generate_matrix}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{generate\_matrix}}}
{}
{}
\pysigstopsignatures
\sphinxAtStartPar
This creates all of the matrices that will be combined into the U and S matrices.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
Returns 2 dictionaries. The first is the dictionary of matrix components with their names as keys.
The second dictionary is a map from the symbols to their values.

\sphinxlineitem{Return type}
\sphinxAtStartPar
dict, dict

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_partial() (src.sensitivity.faster\_sensitivity.SensitivityMatrix method)@\spxentry{get\_partial()}\spxextra{src.sensitivity.faster\_sensitivity.SensitivityMatrix method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.sensitivity.faster_sensitivity:src.sensitivity.faster_sensitivity.SensitivityMatrix.get_partial}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{get\_partial}}}
{\sphinxparam{\DUrole{n}{x}}\sphinxparamcomma \sphinxparam{\DUrole{n}{a}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Retrieve the value of a particular partial derivative.
The value retrieved will be dx/da.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{x}} (\sphinxstyleliteralemphasis{\sphinxupquote{sp.Symbol}}) \textendash{} The symbol for the variable that you wish to know the change effect

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{a}} (\sphinxstyleliteralemphasis{\sphinxupquote{sp.Symbol}}) \textendash{} The symbol for the parameter that you wish to change to cause an effect on a variable

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
The value of the partial derivative dx/da

\sphinxlineitem{Return type}
\sphinxAtStartPar
float

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_partials\_matrix() (src.sensitivity.faster\_sensitivity.SensitivityMatrix method)@\spxentry{get\_partials\_matrix()}\spxextra{src.sensitivity.faster\_sensitivity.SensitivityMatrix method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.sensitivity.faster_sensitivity:src.sensitivity.faster_sensitivity.SensitivityMatrix.get_partials_matrix}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{get\_partials\_matrix}}}
{}
{}
\pysigstopsignatures
\sphinxAtStartPar
Calculate the matrix of all partials as U\textasciicircum{}(\sphinxhyphen{}1) * S
Thus far, this is found to run the fastest when U\textasciicircum{}(\sphinxhyphen{}1) and S are numpy arrays
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
Full partials matrix

\sphinxlineitem{Return type}
\sphinxAtStartPar
np.ndarray

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_sensitivity\_range() (src.sensitivity.faster\_sensitivity.SensitivityMatrix method)@\spxentry{get\_sensitivity\_range()}\spxextra{src.sensitivity.faster\_sensitivity.SensitivityMatrix method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.sensitivity.faster_sensitivity:src.sensitivity.faster_sensitivity.SensitivityMatrix.get_sensitivity_range}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{get\_sensitivity\_range}}}
{\sphinxparam{\DUrole{n}{x}}\sphinxparamcomma \sphinxparam{\DUrole{n}{a}}\sphinxparamcomma \sphinxparam{\DUrole{n}{percent}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
The estimated values for “x” if the parameter “a” changes by percent\% (as number 0\% to 100\%).
It will return values for an increase and decrease of the percent given.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{x}} (\sphinxstyleliteralemphasis{\sphinxupquote{sp.Symbol}}) \textendash{} The symbol for the variable that you wish to know the change effect

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{a}} (\sphinxstyleliteralemphasis{\sphinxupquote{sp.Symbol}}) \textendash{} The symbol for the parameter that you wish to change to cause an effect on a variable

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{percent}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} A number 0\sphinxhyphen{}100 for the percent change in “a”

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
Returns the estimated value for “x” if “a” is increased by percent\% and decreased by percent\%

\sphinxlineitem{Return type}
\sphinxAtStartPar
float, float

\end{description}\end{quote}

\end{fulllineitems}

\index{invert\_U() (src.sensitivity.faster\_sensitivity.SensitivityMatrix method)@\spxentry{invert\_U()}\spxextra{src.sensitivity.faster\_sensitivity.SensitivityMatrix method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.sensitivity.faster_sensitivity:src.sensitivity.faster_sensitivity.SensitivityMatrix.invert_U}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{invert\_U}}}
{}
{}
\pysigstopsignatures
\sphinxAtStartPar
Calculates the inverse of the U matrix.
The fastest method found for this so far has been to convert to numpy and use its inverse function
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
Calculated matrix for the inverse of U

\sphinxlineitem{Return type}
\sphinxAtStartPar
np.ndarray

\end{description}\end{quote}

\end{fulllineitems}

\index{matrix\_assembly() (src.sensitivity.faster\_sensitivity.SensitivityMatrix method)@\spxentry{matrix\_assembly()}\spxextra{src.sensitivity.faster\_sensitivity.SensitivityMatrix method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.sensitivity.faster_sensitivity:src.sensitivity.faster_sensitivity.SensitivityMatrix.matrix_assembly}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{matrix\_assembly}}}
{\sphinxparam{\DUrole{n}{components}}\sphinxparamcomma \sphinxparam{\DUrole{n}{subs\_dict}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Combines matrix components to create U and S matrices from the literature.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{components}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} Dictionary of all precalculated matrix components

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{subs\_dict}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} Dictionary that maps symbols to their values

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
Returns the U and S matrices respectively with all symbols replaced by corresponding values

\sphinxlineitem{Return type}
\sphinxAtStartPar
sp.Matrix, sp.Matrix

\end{description}\end{quote}

\end{fulllineitems}

\index{matrix\_sub() (src.sensitivity.faster\_sensitivity.SensitivityMatrix method)@\spxentry{matrix\_sub()}\spxextra{src.sensitivity.faster\_sensitivity.SensitivityMatrix method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.sensitivity.faster_sensitivity:src.sensitivity.faster_sensitivity.SensitivityMatrix.matrix_sub}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{matrix\_sub}}}
{\sphinxparam{\DUrole{n}{M}}\sphinxparamcomma \sphinxparam{\DUrole{n}{subs}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
A function that substitutes values into a matrix.
This is the same result as sp.Matrix().subs(subs).
This speeds up runtime by only attempting to substitute values into symbols that actually exist in each cell.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{M}} (\sphinxstyleliteralemphasis{\sphinxupquote{sp.Matrix}}) \textendash{} The matrix to have symbols substituted for values

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{subs}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} Dictionary of values for sympy symbols

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
The original matrix with all given values substituted into their symbols

\sphinxlineitem{Return type}
\sphinxAtStartPar
sp.Matrix

\end{description}\end{quote}

\end{fulllineitems}

\index{new\_jacobian() (src.sensitivity.faster\_sensitivity.SensitivityMatrix method)@\spxentry{new\_jacobian()}\spxextra{src.sensitivity.faster\_sensitivity.SensitivityMatrix method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.sensitivity.faster_sensitivity:src.sensitivity.faster_sensitivity.SensitivityMatrix.new_jacobian}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{new\_jacobian}}}
{\sphinxparam{\DUrole{n}{f}}\sphinxparamcomma \sphinxparam{\DUrole{n}{values}}\sphinxparamcomma \sphinxparam{\DUrole{n}{map}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
A function that returns the same result as Matrix.jacobian(values).
This speeds up runtime by only taking derivatives of symbols that exist.
The original function takes the derivative wrt everything in values.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{f}} (\sphinxstyleliteralemphasis{\sphinxupquote{sp.Matrix}}) \textendash{} Matrix of equations

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{values}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}) \textendash{} List of symbols that the function will take derivatives with respect to

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{map}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} Dictionary of column locations for each symbol

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
Returns jacobian of given f matrix

\sphinxlineitem{Return type}
\sphinxAtStartPar
sp.Matrix

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{toy\_model (class in src.sensitivity.faster\_sensitivity)@\spxentry{toy\_model}\spxextra{class in src.sensitivity.faster\_sensitivity}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.sensitivity.faster_sensitivity:src.sensitivity.faster_sensitivity.toy_model}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{\DUrole{k}{class}\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{src.sensitivity.faster\_sensitivity.}}\sphinxbfcode{\sphinxupquote{toy\_model}}}
{\sphinxparam{\DUrole{n}{n}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
An example of the method in action that scales by the given ‘n’ value
\index{create\_model() (src.sensitivity.faster\_sensitivity.toy\_model method)@\spxentry{create\_model()}\spxextra{src.sensitivity.faster\_sensitivity.toy\_model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.sensitivity.faster_sensitivity:src.sensitivity.faster_sensitivity.toy_model.create_model}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{create\_model}}}
{}
{}
\pysigstopsignatures
\end{fulllineitems}


\end{fulllineitems}


\sphinxstepscope


\paragraph{src.sensitivity.sensitivity\_tools}
\label{\detokenize{src.sensitivity.sensitivity_tools:module-src.sensitivity.sensitivity_tools}}\label{\detokenize{src.sensitivity.sensitivity_tools:src-sensitivity-sensitivity-tools}}\label{\detokenize{src.sensitivity.sensitivity_tools::doc}}\index{module@\spxentry{module}!src.sensitivity.sensitivity\_tools@\spxentry{src.sensitivity.sensitivity\_tools}}\index{src.sensitivity.sensitivity\_tools@\spxentry{src.sensitivity.sensitivity\_tools}!module@\spxentry{module}}
\sphinxAtStartPar
Sensitivity Tools
This file contains the AutoSympy, SensitivityMatrix, CoordMap, and DifferentialMapping classes. These
classes serve as the data structures and containers of methods to get from a Pyomo ConcreteModel to easily
accessible sensitivities.

\sphinxAtStartPar
The flow goes:

\sphinxAtStartPar
Pyomo model \sphinxhyphen{}\textgreater{} AutoSympy \sphinxhyphen{}\textgreater{} SensitivityMatrix \sphinxhyphen{}\textgreater{} DifferentialMapping

\sphinxAtStartPar
sensitivities and sensitivity\sphinxhyphen{}based calculations can be done through the DifferentialMapping object.
\subsubsection*{Functions}


\begin{savenotes}
\sphinxatlongtablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\makeatletter
  \LTleft \@totalleftmargin plus1fill
  \LTright\dimexpr\columnwidth-\@totalleftmargin-\linewidth\relax plus1fill
\makeatother
\begin{longtable}{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\endfirsthead

\multicolumn{2}{c}{\sphinxnorowcolor
    \makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}%
}\\
\sphinxtoprule
\endhead

\sphinxbottomrule
\multicolumn{2}{r}{\sphinxnorowcolor
    \makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}%
}\\
\endfoot

\endlastfoot
\sphinxtableatstartofbodyhook

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{E1}}(z)
&
\sphinxAtStartPar
Classical case of the generalized exponential integral.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Eijk}}(*args, **kwargs)
&
\sphinxAtStartPar
Represent the Levi\sphinxhyphen{}Civita symbol.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{GramSchmidt}}(vlist{[}, orthonormal{]})
&
\sphinxAtStartPar
Apply the Gram\sphinxhyphen{}Schmidt process to a set of vectors.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{LC}}(f, *gens, **args)
&
\sphinxAtStartPar
Return the leading coefficient of \sphinxcode{\sphinxupquote{f}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{LM}}(f, *gens, **args)
&
\sphinxAtStartPar
Return the leading monomial of \sphinxcode{\sphinxupquote{f}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{LT}}(f, *gens, **args)
&
\sphinxAtStartPar
Return the leading term of \sphinxcode{\sphinxupquote{f}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{N}}(x{[}, n{]})
&
\sphinxAtStartPar
Calls x.evalf(n, **options).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{POSform}}(variables, minterms{[}, dontcares{]})
&
\sphinxAtStartPar
The POSform function uses simplified\_pairs and a redundant\sphinxhyphen{}group eliminating algorithm to convert the list of all input combinations that generate \textquotesingle{}1\textquotesingle{} (the minterms) into the smallest product\sphinxhyphen{}of\sphinxhyphen{}sums form.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SOPform}}(variables, minterms{[}, dontcares{]})
&
\sphinxAtStartPar
The SOPform function uses simplified\_pairs and a redundant group\sphinxhyphen{} eliminating algorithm to convert the list of all input combos that generate \textquotesingle{}1\textquotesingle{} (the minterms) into the smallest sum\sphinxhyphen{}of\sphinxhyphen{}products form.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Ynm\_c}}(n, m, theta, phi)
&
\sphinxAtStartPar
Conjugate spherical harmonics defined as
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{abundance}}(n)
&
\sphinxAtStartPar
Returns the difference between the sum of the positive proper divisors of a number and the number.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{apart}}(f{[}, x, full{]})
&
\sphinxAtStartPar
Compute partial fraction decomposition of a rational function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{apart\_list}}(f{[}, x, dummies{]})
&
\sphinxAtStartPar
Compute partial fraction decomposition of a rational function and return the result in structured form.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{apply\_finite\_diff}}(order, x\_list, y\_list{[}, x0{]})
&
\sphinxAtStartPar
Calculates the finite difference approximation of the derivative of requested order at \sphinxcode{\sphinxupquote{x0}} from points provided in \sphinxcode{\sphinxupquote{x\_list}} and \sphinxcode{\sphinxupquote{y\_list}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{approximants}}(l{[}, X, simplify{]})
&
\sphinxAtStartPar
Return a generator for consecutive Pade approximants for a series.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{are\_similar}}(e1, e2)
&
\sphinxAtStartPar
Are two geometrical entities similar.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{arity}}(cls)
&
\sphinxAtStartPar
Return the arity of the function if it is known, else None.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ask}}(proposition{[}, assumptions, context{]})
&
\sphinxAtStartPar
Function to evaluate the proposition with assumptions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{assemble\_partfrac\_list}}(partial\_list)
&
\sphinxAtStartPar
Reassemble a full partial fraction decomposition from a structured result obtained by the function \sphinxcode{\sphinxupquote{apart\_list}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{assuming}}(*assumptions)
&
\sphinxAtStartPar
Context manager for assumptions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{banded}}(*args, **kwargs)
&
\sphinxAtStartPar
Returns a SparseMatrix from the given dictionary describing the diagonals of the matrix.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{besselsimp}}(expr)
&
\sphinxAtStartPar
Simplify bessel\sphinxhyphen{}type functions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{binomial\_coefficients}}(n)
&
\sphinxAtStartPar
Return a dictionary containing pairs \({(k1,k2) : C_kn}\) where \(C_kn\) are binomial coefficients and \(n=k1+k2\).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{binomial\_coefficients\_list}}(n)
&
\sphinxAtStartPar
Return a list of binomial coefficients as rows of the Pascal\textquotesingle{}s triangle.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{block\_collapse}}(expr)
&
\sphinxAtStartPar
Evaluates a block matrix expression
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{blockcut}}(expr, rowsizes, colsizes)
&
\sphinxAtStartPar
Cut a matrix expression into Blocks
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{bool\_map}}(bool1, bool2)
&
\sphinxAtStartPar
Return the simplified version of \sphinxstyleemphasis{bool1}, and the mapping of variables that makes the two expressions \sphinxstyleemphasis{bool1} and \sphinxstyleemphasis{bool2} represent the same logical behaviour for some correspondence between the variables of each.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{bottom\_up}}(rv, F{[}, atoms, nonbasic{]})
&
\sphinxAtStartPar
Apply \sphinxcode{\sphinxupquote{F}} to all expressions in an expression tree from the bottom up.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{bspline\_basis}}(d, knots, n, x)
&
\sphinxAtStartPar
The \$n\$\sphinxhyphen{}th B\sphinxhyphen{}spline at \$x\$ of degree \$d\$ with knots.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{bspline\_basis\_set}}(d, knots, x)
&
\sphinxAtStartPar
Return the \sphinxcode{\sphinxupquote{len(knots)\sphinxhyphen{}d\sphinxhyphen{}1}} B\sphinxhyphen{}splines at \sphinxstyleemphasis{x} of degree \sphinxstyleemphasis{d} with \sphinxstyleemphasis{knots}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{cacheit}}(func)
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{cancel}}(f, *gens{[}, \_signsimp{]})
&
\sphinxAtStartPar
Cancel common factors in a rational function \sphinxcode{\sphinxupquote{f}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{capture}}(func)
&
\sphinxAtStartPar
Return the printed output of func().
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{casoratian}}(seqs, n{[}, zero{]})
&
\sphinxAtStartPar
Given linear difference operator L of order \textquotesingle{}k\textquotesingle{} and homogeneous equation Ly = 0 we want to compute kernel of L, which is a set of \textquotesingle{}k\textquotesingle{} sequences: a(n), b(n), .
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{cbrt}}(arg{[}, evaluate{]})
&
\sphinxAtStartPar
Returns the principal cube root.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ccode}}(expr{[}, assign\_to, standard{]})
&
\sphinxAtStartPar
Converts an expr to a string of c code
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{centroid}}(*args)
&
\sphinxAtStartPar
Find the centroid (center of mass) of the collection containing only Points, Segments or Polygons.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{chebyshevt\_poly}}(n{[}, x, polys{]})
&
\sphinxAtStartPar
Generates the Chebyshev polynomial of the first kind \sphinxtitleref{T\_n(x)}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{chebyshevu\_poly}}(n{[}, x, polys{]})
&
\sphinxAtStartPar
Generates the Chebyshev polynomial of the second kind \sphinxtitleref{U\_n(x)}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{check\_assumptions}}(expr{[}, against{]})
&
\sphinxAtStartPar
Checks whether assumptions of \sphinxcode{\sphinxupquote{expr}} match the T/F assumptions given (or possessed by \sphinxcode{\sphinxupquote{against}}).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{checkodesol}}(ode, sol{[}, func, order, ...{]})
&
\sphinxAtStartPar
Substitutes \sphinxcode{\sphinxupquote{sol}} into \sphinxcode{\sphinxupquote{ode}} and checks that the result is \sphinxcode{\sphinxupquote{0}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{checkpdesol}}(pde, sol{[}, func, solve\_for\_func{]})
&
\sphinxAtStartPar
Checks if the given solution satisfies the partial differential equation.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{checksol}}(f, symbol{[}, sol{]})
&
\sphinxAtStartPar
Checks whether sol is a solution of equation f == 0.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{classify\_ode}}(eq{[}, func, dict, ics, prep, ...{]})
&
\sphinxAtStartPar
Returns a tuple of possible \sphinxcode{\sphinxupquote{dsolve()}} classifications for an ODE.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{classify\_pde}}(eq{[}, func, dict, prep{]})
&
\sphinxAtStartPar
Returns a tuple of possible pdsolve() classifications for a PDE.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{closest\_points}}(*args)
&
\sphinxAtStartPar
Return the subset of points from a set of points that were the closest to each other in the 2D plane.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{cofactors}}(f, g, *gens, **args)
&
\sphinxAtStartPar
Compute GCD and cofactors of \sphinxcode{\sphinxupquote{f}} and \sphinxcode{\sphinxupquote{g}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{collect}}(expr, syms{[}, func, evaluate, exact, ...{]})
&
\sphinxAtStartPar
Collect additive terms of an expression.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{collect\_const}}(expr, *vars{[}, Numbers{]})
&
\sphinxAtStartPar
A non\sphinxhyphen{}greedy collection of terms with similar number coefficients in an Add expr.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{combsimp}}(expr)
&
\sphinxAtStartPar
Simplify combinatorial expressions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{comp}}(z1, z2{[}, tol{]})
&
\sphinxAtStartPar
Return a bool indicating whether the error between z1 and z2 is \$le\$ \sphinxcode{\sphinxupquote{tol}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{compose}}(f, g, *gens, **args)
&
\sphinxAtStartPar
Compute functional composition \sphinxcode{\sphinxupquote{f(g)}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{composite}}(nth)
&
\sphinxAtStartPar
Return the nth composite number, with the composite numbers indexed as composite(1) = 4, composite(2) = 6, etc....
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{compositepi}}(n)
&
\sphinxAtStartPar
Return the number of positive composite numbers less than or equal to n.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{construct\_domain}}(obj, **args)
&
\sphinxAtStartPar
Construct a minimal domain for a list of expressions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{content}}(f, *gens, **args)
&
\sphinxAtStartPar
Compute GCD of coefficients of \sphinxcode{\sphinxupquote{f}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{continued\_fraction}}(a)
&
\sphinxAtStartPar
Return the continued fraction representation of a Rational or quadratic irrational.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{continued\_fraction\_convergents}}(cf)
&
\sphinxAtStartPar
Return an iterator over the convergents of a continued fraction (cf).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{continued\_fraction\_iterator}}(x)
&
\sphinxAtStartPar
Return continued fraction expansion of x as iterator.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{continued\_fraction\_periodic}}(p, q{[}, d, s{]})
&
\sphinxAtStartPar
Find the periodic continued fraction expansion of a quadratic irrational.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{continued\_fraction\_reduce}}(cf)
&
\sphinxAtStartPar
Reduce a continued fraction to a rational or quadratic irrational.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{convex\_hull}}(*args{[}, polygon{]})
&
\sphinxAtStartPar
The convex hull surrounding the Points contained in the list of entities.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{convolution}}(a, b{[}, cycle, dps, prime, ...{]})
&
\sphinxAtStartPar
Performs convolution by determining the type of desired convolution using hints.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{cosine\_transform}}(f, x, k, **hints)
&
\sphinxAtStartPar
Compute the unitary, ordinary\sphinxhyphen{}frequency cosine transform of \sphinxtitleref{f}, defined as
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{count\_ops}}(expr{[}, visual{]})
&
\sphinxAtStartPar
Return a representation (integer or expression) of the operations in expr.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{count\_roots}}(f{[}, inf, sup{]})
&
\sphinxAtStartPar
Return the number of roots of \sphinxcode{\sphinxupquote{f}} in \sphinxcode{\sphinxupquote{{[}inf, sup{]}}} interval.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{covering\_product}}(a, b)
&
\sphinxAtStartPar
Returns the covering product of given sequences.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{cse}}(exprs{[}, symbols, optimizations, ...{]})
&
\sphinxAtStartPar
Perform common subexpression elimination on an expression.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{cxxcode}}(expr{[}, assign\_to, standard{]})
&
\sphinxAtStartPar
C++ equivalent of \sphinxcode{\sphinxupquote{ccode()}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{cycle\_length}}(f, x0{[}, nmax, values{]})
&
\sphinxAtStartPar
For a given iterated sequence, return a generator that gives the length of the iterated cycle (lambda) and the length of terms before the cycle begins (mu); if \sphinxcode{\sphinxupquote{values}} is True then the terms of the sequence will be returned instead.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{cyclotomic\_poly}}(n{[}, x, polys{]})
&
\sphinxAtStartPar
Generates cyclotomic polynomial of order \sphinxtitleref{n} in \sphinxtitleref{x}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{decompogen}}(f, symbol)
&
\sphinxAtStartPar
Computes General functional decomposition of \sphinxcode{\sphinxupquote{f}}. Given an expression \sphinxcode{\sphinxupquote{f}}, returns a list \sphinxcode{\sphinxupquote{{[}f\_1, f\_2, ..., f\_n{]}}}, where::           f = f\_1 o f\_2 o ... f\_n = f\_1(f\_2(... f\_n)).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{decompose}}(f, *gens, **args)
&
\sphinxAtStartPar
Compute functional decomposition of \sphinxcode{\sphinxupquote{f}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{default\_sort\_key}}(item{[}, order{]})
&
\sphinxAtStartPar
Return a key that can be used for sorting.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{deg}}(r)
&
\sphinxAtStartPar
Return the degree value for the given radians (pi = 180 degrees).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{degree}}(f{[}, gen{]})
&
\sphinxAtStartPar
Return the degree of \sphinxcode{\sphinxupquote{f}} in the given variable.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{degree\_list}}(f, *gens, **args)
&
\sphinxAtStartPar
Return a list of degrees of \sphinxcode{\sphinxupquote{f}} in all variables.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{denom}}(expr)
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{derive\_by\_array}}(expr, dx)
&
\sphinxAtStartPar
Derivative by arrays.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{det}}(matexpr)
&
\sphinxAtStartPar
Matrix Determinant
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{det\_quick}}(M{[}, method{]})
&
\sphinxAtStartPar
Return \sphinxcode{\sphinxupquote{det(M)}} assuming that either there are lots of zeros or the size of the matrix is small.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{diag}}(*values{[}, strict, unpack{]})
&
\sphinxAtStartPar
Returns a matrix with the provided values placed on the diagonal.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{diagonalize\_vector}}(vector)
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{dict\_merge}}(*dicts)
&
\sphinxAtStartPar
Merge dictionaries into a single dictionary.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{diff}}(f, *symbols, **kwargs)
&
\sphinxAtStartPar
Differentiate f with respect to symbols.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{difference\_delta}}(expr{[}, n, step{]})
&
\sphinxAtStartPar
Difference Operator.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{differentiate\_finite}}(expr, *symbols{[}, ...{]})
&
\sphinxAtStartPar
Differentiate expr and replace Derivatives with finite differences.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{diophantine}}(eq{[}, param, syms, permute{]})
&
\sphinxAtStartPar
Simplify the solution procedure of diophantine equation \sphinxcode{\sphinxupquote{eq}} by converting it into a product of terms which should equal zero.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{discrete\_log}}(n, a, b{[}, order, prime\_order{]})
&
\sphinxAtStartPar
Compute the discrete logarithm of \sphinxcode{\sphinxupquote{a}} to the base \sphinxcode{\sphinxupquote{b}} modulo \sphinxcode{\sphinxupquote{n}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{discriminant}}(f, *gens, **args)
&
\sphinxAtStartPar
Compute discriminant of \sphinxcode{\sphinxupquote{f}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{div}}(f, g, *gens, **args)
&
\sphinxAtStartPar
Compute polynomial division of \sphinxcode{\sphinxupquote{f}} and \sphinxcode{\sphinxupquote{g}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{divisor\_count}}(n{[}, modulus, proper{]})
&
\sphinxAtStartPar
Return the number of divisors of \sphinxcode{\sphinxupquote{n}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{divisors}}(n{[}, generator, proper{]})
&
\sphinxAtStartPar
Return all divisors of n sorted from 1..n by default.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{dotprint}}(expr{[}, styles, atom, maxdepth, ...{]})
&
\sphinxAtStartPar
DOT description of a SymPy expression tree
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{dsolve}}(eq{[}, func, hint, simplify, ics, xi, ...{]})
&
\sphinxAtStartPar
Solves any (supported) kind of ordinary differential equation and system of ordinary differential equations.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{egyptian\_fraction}}(r{[}, algorithm{]})
&
\sphinxAtStartPar
Return the list of denominators of an Egyptian fraction expansion {\color{red}\bfseries{}{[}1{]}\_} of the said rational \sphinxtitleref{r}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{epath}}(path{[}, expr, func, args, kwargs{]})
&
\sphinxAtStartPar
Manipulate parts of an expression selected by a path.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{euler\_equations}}(L{[}, funcs, vars{]})
&
\sphinxAtStartPar
Find the Euler\sphinxhyphen{}Lagrange equations {\color{red}\bfseries{}{[}1{]}\_} for a given Lagrangian.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{evaluate}}(x)
&
\sphinxAtStartPar
Control automatic evaluation
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{expand}}(e{[}, deep, modulus, power\_base, ...{]})
&
\sphinxAtStartPar
Expand an expression using methods given as hints.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{expand\_complex}}(expr{[}, deep{]})
&
\sphinxAtStartPar
Wrapper around expand that only uses the complex hint.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{expand\_func}}(expr{[}, deep{]})
&
\sphinxAtStartPar
Wrapper around expand that only uses the func hint.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{expand\_log}}(expr{[}, deep, force, factor{]})
&
\sphinxAtStartPar
Wrapper around expand that only uses the log hint.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{expand\_mul}}(expr{[}, deep{]})
&
\sphinxAtStartPar
Wrapper around expand that only uses the mul hint.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{expand\_multinomial}}(expr{[}, deep{]})
&
\sphinxAtStartPar
Wrapper around expand that only uses the multinomial hint.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{expand\_power\_base}}(expr{[}, deep, force{]})
&
\sphinxAtStartPar
Wrapper around expand that only uses the power\_base hint.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{expand\_power\_exp}}(expr{[}, deep{]})
&
\sphinxAtStartPar
Wrapper around expand that only uses the power\_exp hint.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{expand\_trig}}(expr{[}, deep{]})
&
\sphinxAtStartPar
Wrapper around expand that only uses the trig hint.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{exptrigsimp}}(expr)
&
\sphinxAtStartPar
Simplifies exponential / trigonometric / hyperbolic functions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{exquo}}(f, g, *gens, **args)
&
\sphinxAtStartPar
Compute polynomial exact quotient of \sphinxcode{\sphinxupquote{f}} and \sphinxcode{\sphinxupquote{g}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{eye}}(*args, **kwargs)
&
\sphinxAtStartPar
Create square identity matrix n x n
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{factor}}(f, *gens{[}, deep{]})
&
\sphinxAtStartPar
Compute the factorization of expression, \sphinxcode{\sphinxupquote{f}}, into irreducibles.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{factor\_list}}(f, *gens, **args)
&
\sphinxAtStartPar
Compute a list of irreducible factors of \sphinxcode{\sphinxupquote{f}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{factor\_nc}}(expr)
&
\sphinxAtStartPar
Return the factored form of \sphinxcode{\sphinxupquote{expr}} while handling non\sphinxhyphen{}commutative expressions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{factor\_terms}}(expr{[}, radical, clear, ...{]})
&
\sphinxAtStartPar
Remove common factors from terms in all arguments without changing the underlying structure of the expr.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{factorint}}(n{[}, limit, use\_trial, use\_rho, ...{]})
&
\sphinxAtStartPar
Given a positive integer \sphinxcode{\sphinxupquote{n}}, \sphinxcode{\sphinxupquote{factorint(n)}} returns a dict containing the prime factors of \sphinxcode{\sphinxupquote{n}} as keys and their respective multiplicities as values.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{factorrat}}(rat{[}, limit, use\_trial, use\_rho, ...{]})
&
\sphinxAtStartPar
Given a Rational \sphinxcode{\sphinxupquote{r}}, \sphinxcode{\sphinxupquote{factorrat(r)}} returns a dict containing the prime factors of \sphinxcode{\sphinxupquote{r}} as keys and their respective multiplicities as values.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{failing\_assumptions}}(expr, **assumptions)
&
\sphinxAtStartPar
Return a dictionary containing assumptions with values not matching those of the passed assumptions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{farthest\_points}}(*args)
&
\sphinxAtStartPar
Return the subset of points from a set of points that were the furthest apart from each other in the 2D plane.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{fcode}}(expr{[}, assign\_to{]})
&
\sphinxAtStartPar
Converts an expr to a string of fortran code
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{fft}}(seq{[}, dps{]})
&
\sphinxAtStartPar
Performs the Discrete Fourier Transform (\sphinxstylestrong{DFT}) in the complex domain.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{field}}(symbols, domain{[}, order{]})
&
\sphinxAtStartPar
Construct new rational function field returning (field, x1, ..., xn).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{field\_isomorphism}}(a, b, *{[}, fast{]})
&
\sphinxAtStartPar
Find an embedding of one number field into another.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{filldedent}}(s{[}, w{]})
&
\sphinxAtStartPar
Strips leading and trailing empty lines from a copy of \sphinxcode{\sphinxupquote{s}}, then dedents, fills and returns it.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{finite\_diff\_weights}}(order, x\_list{[}, x0{]})
&
\sphinxAtStartPar
Calculates the finite difference weights for an arbitrarily spaced one\sphinxhyphen{}dimensional grid (\sphinxcode{\sphinxupquote{x\_list}}) for derivatives at \sphinxcode{\sphinxupquote{x0}} of order 0, 1, ..., up to \sphinxcode{\sphinxupquote{order}} using a recursive formula.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{flatten}}(iterable{[}, levels, cls{]})
&
\sphinxAtStartPar
Recursively denest iterable containers.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{fourier\_series}}(f{[}, limits, finite{]})
&
\sphinxAtStartPar
Computes the Fourier trigonometric series expansion.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{fourier\_transform}}(f, x, k, **hints)
&
\sphinxAtStartPar
Compute the unitary, ordinary\sphinxhyphen{}frequency Fourier transform of \sphinxcode{\sphinxupquote{f}}, defined as
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{fps}}(f{[}, x, x0, dir, hyper, order, rational, ...{]})
&
\sphinxAtStartPar
Generates Formal Power Series of \sphinxcode{\sphinxupquote{f}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{fraction}}(expr{[}, exact{]})
&
\sphinxAtStartPar
Returns a pair with expression\textquotesingle{}s numerator and denominator.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{fu}}(rv{[}, measure{]})
&
\sphinxAtStartPar
Attempt to simplify expression by using transformation rules given in the algorithm by Fu et al.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{fwht}}(seq)
&
\sphinxAtStartPar
Performs the Walsh Hadamard Transform (\sphinxstylestrong{WHT}), and uses Hadamard ordering for the sequence.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{galois\_group}}(f, *gens{[}, by\_name, max\_tries, ...{]})
&
\sphinxAtStartPar
Compute the Galois group for polynomials \sphinxstyleemphasis{f} up to degree 6.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{gammasimp}}(expr)
&
\sphinxAtStartPar
Simplify expressions with gamma functions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{gcd}}(f{[}, g{]})
&
\sphinxAtStartPar
Compute GCD of \sphinxcode{\sphinxupquote{f}} and \sphinxcode{\sphinxupquote{g}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{gcd\_list}}(seq, *gens, **args)
&
\sphinxAtStartPar
Compute GCD of a list of polynomials.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{gcd\_terms}}(terms{[}, isprimitive, clear, fraction{]})
&
\sphinxAtStartPar
Compute the GCD of \sphinxcode{\sphinxupquote{terms}} and put them together.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{gcdex}}(f, g, *gens, **args)
&
\sphinxAtStartPar
Extended Euclidean algorithm of \sphinxcode{\sphinxupquote{f}} and \sphinxcode{\sphinxupquote{g}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{getLogger}}({[}name{]})
&
\sphinxAtStartPar
Return a logger with the specified name, creating it if necessary.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{get\_contraction\_structure}}(expr)
&
\sphinxAtStartPar
Determine dummy indices of \sphinxcode{\sphinxupquote{expr}} and describe its structure
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{get\_indices}}(expr)
&
\sphinxAtStartPar
Determine the outer indices of expression \sphinxcode{\sphinxupquote{expr}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{gff}}(f, *gens, **args)
&
\sphinxAtStartPar
Compute greatest factorial factorization of \sphinxcode{\sphinxupquote{f}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{gff\_list}}(f, *gens, **args)
&
\sphinxAtStartPar
Compute a list of greatest factorial factors of \sphinxcode{\sphinxupquote{f}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{glsl\_code}}(expr{[}, assign\_to{]})
&
\sphinxAtStartPar
Converts an expr to a string of GLSL code
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{groebner}}(F, *gens, **args)
&
\sphinxAtStartPar
Computes the reduced Groebner basis for a set of polynomials.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ground\_roots}}(f, *gens, **args)
&
\sphinxAtStartPar
Compute roots of \sphinxcode{\sphinxupquote{f}} by factorization in the ground domain.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{group}}(seq{[}, multiple{]})
&
\sphinxAtStartPar
Splits a sequence into a list of lists of equal, adjacent elements.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{gruntz}}(e, z, z0{[}, dir{]})
&
\sphinxAtStartPar
Compute the limit of e(z) at the point z0 using the Gruntz algorithm.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hadamard\_product}}(*matrices)
&
\sphinxAtStartPar
Return the elementwise (aka Hadamard) product of matrices.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{half\_gcdex}}(f, g, *gens, **args)
&
\sphinxAtStartPar
Half extended Euclidean algorithm of \sphinxcode{\sphinxupquote{f}} and \sphinxcode{\sphinxupquote{g}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hankel\_transform}}(f, r, k, nu, **hints)
&
\sphinxAtStartPar
Compute the Hankel transform of \sphinxtitleref{f}, defined as
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{has\_dups}}(seq)
&
\sphinxAtStartPar
Return True if there are any duplicate elements in \sphinxcode{\sphinxupquote{seq}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{has\_variety}}(seq)
&
\sphinxAtStartPar
Return True if there are any different elements in \sphinxcode{\sphinxupquote{seq}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hermite\_poly}}(n{[}, x, polys{]})
&
\sphinxAtStartPar
Generates the Hermite polynomial \sphinxtitleref{H\_n(x)}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hermite\_prob\_poly}}(n{[}, x, polys{]})
&
\sphinxAtStartPar
Generates the probabilist\textquotesingle{}s Hermite polynomial \sphinxtitleref{He\_n(x)}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hessian}}(f, varlist{[}, constraints{]})
&
\sphinxAtStartPar
Compute Hessian matrix for a function f wrt parameters in varlist which may be given as a sequence or a row/column vector.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{homogeneous\_order}}(eq, *symbols)
&
\sphinxAtStartPar
Returns the order \sphinxtitleref{n} if \sphinxtitleref{g} is homogeneous and \sphinxcode{\sphinxupquote{None}} if it is not homogeneous.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{horner}}(f, *gens, **args)
&
\sphinxAtStartPar
Rewrite a polynomial in Horner form.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hyperexpand}}(f{[}, allow\_hyper, rewrite, place{]})
&
\sphinxAtStartPar
Expand hypergeometric functions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hypersimilar}}(f, g, k)
&
\sphinxAtStartPar
Returns True if \sphinxcode{\sphinxupquote{f}} and \sphinxcode{\sphinxupquote{g}} are hyper\sphinxhyphen{}similar.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hypersimp}}(f, k)
&
\sphinxAtStartPar
Given combinatorial term f(k) simplify its consecutive term ratio i.e. f(k+1)/f(k).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{idiff}}(eq, y, x{[}, n{]})
&
\sphinxAtStartPar
Return \sphinxcode{\sphinxupquote{dy/dx}} assuming that \sphinxcode{\sphinxupquote{eq == 0}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ifft}}(seq{[}, dps{]})
&
\sphinxAtStartPar
Performs the Discrete Fourier Transform (\sphinxstylestrong{DFT}) in the complex domain.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ifwht}}(seq)
&
\sphinxAtStartPar
Performs the Walsh Hadamard Transform (\sphinxstylestrong{WHT}), and uses Hadamard ordering for the sequence.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{igcd}}(*args)
&
\sphinxAtStartPar
Computes nonnegative integer greatest common divisor.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ilcm}}(*args)
&
\sphinxAtStartPar
Computes integer least common multiple.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{imageset}}(*args)
&
\sphinxAtStartPar
Return an image of the set under transformation \sphinxcode{\sphinxupquote{f}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{init\_printing}}({[}pretty\_print, order, ...{]})
&
\sphinxAtStartPar
Initializes pretty\sphinxhyphen{}printer depending on the environment.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{init\_session}}({[}ipython, pretty\_print, order, ...{]})
&
\sphinxAtStartPar
Initialize an embedded IPython or Python session.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{integer\_log}}(y, x)
&
\sphinxAtStartPar
Returns \sphinxcode{\sphinxupquote{(e, bool)}} where e is the largest nonnegative integer such that \(|y| \geq |x^e|\) and \sphinxcode{\sphinxupquote{bool}} is True if \$y = x\textasciicircum{}e\$.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{integer\_nthroot}}(y, n)
&
\sphinxAtStartPar
Return a tuple containing x = floor(y**(1/n)) and a boolean indicating whether the result is exact (that is, whether x**n == y).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{integrate}}(f, var, ...)
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{interactive\_traversal}}(expr)
&
\sphinxAtStartPar
Traverse a tree asking a user which branch to choose.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{interpolate}}(data, x)
&
\sphinxAtStartPar
Construct an interpolating polynomial for the data points evaluated at point x (which can be symbolic or numeric).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{interpolating\_poly}}(n, x{[}, X, Y{]})
&
\sphinxAtStartPar
Construct Lagrange interpolating polynomial for \sphinxcode{\sphinxupquote{n}} data points.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{interpolating\_spline}}(d, x, X, Y)
&
\sphinxAtStartPar
Return spline of degree \sphinxstyleemphasis{d}, passing through the given \sphinxstyleemphasis{X} and \sphinxstyleemphasis{Y} values.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{intersecting\_product}}(a, b)
&
\sphinxAtStartPar
Returns the intersecting product of given sequences.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{intersection}}(*entities{[}, pairwise{]})
&
\sphinxAtStartPar
The intersection of a collection of GeometryEntity instances.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{intervals}}(F{[}, all, eps, inf, sup, strict, ...{]})
&
\sphinxAtStartPar
Compute isolating intervals for roots of \sphinxcode{\sphinxupquote{f}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{intt}}(seq, prime)
&
\sphinxAtStartPar
Performs the Number Theoretic Transform (\sphinxstylestrong{NTT}), which specializes the Discrete Fourier Transform (\sphinxstylestrong{DFT}) over quotient ring \sphinxtitleref{Z/pZ} for prime \sphinxtitleref{p} instead of complex numbers \sphinxtitleref{C}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{inv\_quick}}(M)
&
\sphinxAtStartPar
Return the inverse of \sphinxcode{\sphinxupquote{M}}, assuming that either there are lots of zeros or the size of the matrix is small.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{inverse\_cosine\_transform}}(F, k, x, **hints)
&
\sphinxAtStartPar
Compute the unitary, ordinary\sphinxhyphen{}frequency inverse cosine transform of \sphinxtitleref{F}, defined as
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{inverse\_fourier\_transform}}(F, k, x, **hints)
&
\sphinxAtStartPar
Compute the unitary, ordinary\sphinxhyphen{}frequency inverse Fourier transform of \sphinxtitleref{F}, defined as
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{inverse\_hankel\_transform}}(F, k, r, nu, **hints)
&
\sphinxAtStartPar
Compute the inverse Hankel transform of \sphinxtitleref{F} defined as
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{inverse\_laplace\_transform}}(F, s, t{[}, plane{]})
&
\sphinxAtStartPar
Compute the inverse Laplace transform of \sphinxtitleref{F(s)}, defined as
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{inverse\_mellin\_transform}}(F, s, x, strip, **hints)
&
\sphinxAtStartPar
Compute the inverse Mellin transform of \sphinxtitleref{F(s)} over the fundamental strip given by \sphinxcode{\sphinxupquote{strip=(a, b)}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{inverse\_mobius\_transform}}(seq{[}, subset{]})
&
\sphinxAtStartPar
Performs the Mobius Transform for subset lattice with indices of sequence as bitmasks.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{inverse\_sine\_transform}}(F, k, x, **hints)
&
\sphinxAtStartPar
Compute the unitary, ordinary\sphinxhyphen{}frequency inverse sine transform of \sphinxtitleref{F}, defined as
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{invert}}(f, g, *gens, **args)
&
\sphinxAtStartPar
Invert \sphinxcode{\sphinxupquote{f}} modulo \sphinxcode{\sphinxupquote{g}} when possible.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{is\_abundant}}(n)
&
\sphinxAtStartPar
Returns True if \sphinxcode{\sphinxupquote{n}} is an abundant number, else False.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{is\_amicable}}(m, n)
&
\sphinxAtStartPar
Returns True if the numbers \sphinxtitleref{m} and \sphinxtitleref{n} are "amicable", else False.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{is\_convex}}(f, *syms{[}, domain{]})
&
\sphinxAtStartPar
Determines the  convexity of the function passed in the argument.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{is\_decreasing}}(expression{[}, interval, symbol{]})
&
\sphinxAtStartPar
Return whether the function is decreasing in the given interval.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{is\_deficient}}(n)
&
\sphinxAtStartPar
Returns True if \sphinxcode{\sphinxupquote{n}} is a deficient number, else False.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{is\_increasing}}(expression{[}, interval, symbol{]})
&
\sphinxAtStartPar
Return whether the function is increasing in the given interval.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{is\_mersenne\_prime}}(n)
&
\sphinxAtStartPar
Returns True if  \sphinxcode{\sphinxupquote{n}} is a Mersenne prime, else False.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{is\_monotonic}}(expression{[}, interval, symbol{]})
&
\sphinxAtStartPar
Return whether the function is monotonic in the given interval.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{is\_nthpow\_residue}}(a, n, m)
&
\sphinxAtStartPar
Returns True if \sphinxcode{\sphinxupquote{x**n == a (mod m)}} has solutions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{is\_perfect}}(n)
&
\sphinxAtStartPar
Returns True if \sphinxcode{\sphinxupquote{n}} is a perfect number, else False.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{is\_primitive\_root}}(a, p)
&
\sphinxAtStartPar
Returns True if \sphinxcode{\sphinxupquote{a}} is a primitive root of \sphinxcode{\sphinxupquote{p}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{is\_quad\_residue}}(a, p)
&
\sphinxAtStartPar
Returns True if \sphinxcode{\sphinxupquote{a}} (mod \sphinxcode{\sphinxupquote{p}}) is in the set of squares mod \sphinxcode{\sphinxupquote{p}}, i.e a \% p in set({[}i**2 \% p for i in range(p){]}).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{is\_strictly\_decreasing}}(expression{[}, ...{]})
&
\sphinxAtStartPar
Return whether the function is strictly decreasing in the given interval.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{is\_strictly\_increasing}}(expression{[}, ...{]})
&
\sphinxAtStartPar
Return whether the function is strictly increasing in the given interval.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{is\_zero\_dimensional}}(F, *gens, **args)
&
\sphinxAtStartPar
Checks if the ideal generated by a Groebner basis is zero\sphinxhyphen{}dimensional.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{isolate}}(alg{[}, eps, fast{]})
&
\sphinxAtStartPar
Find a rational isolating interval for a real algebraic number.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{isprime}}(n)
&
\sphinxAtStartPar
Test if n is a prime number (True) or not (False).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{itermonomials}}(variables, max\_degrees{[}, ...{]})
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{max\_degrees}} and \sphinxcode{\sphinxupquote{min\_degrees}} are either both integers or both lists.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{jacobi\_normalized}}(n, a, b, x)
&
\sphinxAtStartPar
Jacobi polynomial \$P\_n\textasciicircum{}\{left(alpha, betaright)\}(x)\$.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{jacobi\_poly}}(n, a, b{[}, x, polys{]})
&
\sphinxAtStartPar
Generates the Jacobi polynomial \sphinxtitleref{P\_n\textasciicircum{}\{(a,b)\}(x)}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{jacobi\_symbol}}(m, n)
&
\sphinxAtStartPar
Returns the Jacobi symbol \sphinxtitleref{(m / n)}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{jn\_zeros}}(n, k{[}, method, dps{]})
&
\sphinxAtStartPar
Zeros of the spherical Bessel function of the first kind.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{jordan\_cell}}(eigenval, n)
&
\sphinxAtStartPar
Create a Jordan block:
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{jscode}}(expr{[}, assign\_to{]})
&
\sphinxAtStartPar
Converts an expr to a string of javascript code
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{julia\_code}}(expr{[}, assign\_to{]})
&
\sphinxAtStartPar
Converts \sphinxtitleref{expr} to a string of Julia code.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{kronecker\_product}}(*matrices)
&
\sphinxAtStartPar
The Kronecker product of two or more arguments.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{kroneckersimp}}(expr)
&
\sphinxAtStartPar
Simplify expressions with KroneckerDelta.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{laguerre\_poly}}(n{[}, x, alpha, polys{]})
&
\sphinxAtStartPar
Generates the Laguerre polynomial \sphinxtitleref{L\_n\textasciicircum{}\{(alpha)\}(x)}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{lambdify}}(args, expr{[}, modules, printer, ...{]})
&
\sphinxAtStartPar
Convert a SymPy expression into a function that allows for fast numeric evaluation.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{laplace\_transform}}(f, t, s{[}, legacy\_matrix{]})
&
\sphinxAtStartPar
Compute the Laplace Transform \sphinxtitleref{F(s)} of \sphinxtitleref{f(t)},
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{lcm}}(f{[}, g{]})
&
\sphinxAtStartPar
Compute LCM of \sphinxcode{\sphinxupquote{f}} and \sphinxcode{\sphinxupquote{g}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{lcm\_list}}(seq, *gens, **args)
&
\sphinxAtStartPar
Compute LCM of a list of polynomials.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{legendre\_poly}}(n{[}, x, polys{]})
&
\sphinxAtStartPar
Generates the Legendre polynomial \sphinxtitleref{P\_n(x)}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{legendre\_symbol}}(a, p)
&
\sphinxAtStartPar
Returns the Legendre symbol \sphinxtitleref{(a / p)}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{limit}}(e, z, z0{[}, dir{]})
&
\sphinxAtStartPar
Computes the limit of \sphinxcode{\sphinxupquote{e(z)}} at the point \sphinxcode{\sphinxupquote{z0}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{limit\_seq}}(expr{[}, n, trials{]})
&
\sphinxAtStartPar
Finds the limit of a sequence as index \sphinxcode{\sphinxupquote{n}} tends to infinity.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{line\_integrate}}(field, Curve, variables)
&
\sphinxAtStartPar
Compute the line integral.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{linear\_eq\_to\_matrix}}(equations, *symbols)
&
\sphinxAtStartPar
Converts a given System of Equations into Matrix form.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{linsolve}}(system, *symbols)
&
\sphinxAtStartPar
Solve system of \$N\$ linear equations with \$M\$ variables; both underdetermined and overdetermined systems are supported.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{list2numpy}}(l{[}, dtype{]})
&
\sphinxAtStartPar
Converts Python list of SymPy expressions to a NumPy array.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{logcombine}}(expr{[}, force{]})
&
\sphinxAtStartPar
Takes logarithms and combines them using the following rules:
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{maple\_code}}(expr{[}, assign\_to{]})
&
\sphinxAtStartPar
Converts \sphinxcode{\sphinxupquote{expr}} to a string of Maple code.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mathematica\_code}}(expr, **settings)
&
\sphinxAtStartPar
Converts an expr to a string of the Wolfram Mathematica code
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{matrix2numpy}}(m{[}, dtype{]})
&
\sphinxAtStartPar
Converts SymPy\textquotesingle{}s matrix to a NumPy array.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{matrix\_multiply\_elementwise}}(A, B)
&
\sphinxAtStartPar
Return the Hadamard product (elementwise product) of A and B
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{matrix\_symbols}}(expr)
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{maximum}}(f, symbol{[}, domain{]})
&
\sphinxAtStartPar
Returns the maximum value of a function in the given domain.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mellin\_transform}}(f, x, s, **hints)
&
\sphinxAtStartPar
Compute the Mellin transform \sphinxtitleref{F(s)} of \sphinxtitleref{f(x)},
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{memoize\_property}}(propfunc)
&
\sphinxAtStartPar
Property decorator that caches the value of potentially expensive \sphinxtitleref{propfunc} after the first evaluation.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mersenne\_prime\_exponent}}(nth)
&
\sphinxAtStartPar
Returns the exponent \sphinxcode{\sphinxupquote{i}} for the nth Mersenne prime (which has the form \sphinxtitleref{2\textasciicircum{}i \sphinxhyphen{} 1}).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{minimal\_polynomial}}(ex{[}, x, compose, polys, ...{]})
&
\sphinxAtStartPar
Computes the minimal polynomial of an algebraic element.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{minimum}}(f, symbol{[}, domain{]})
&
\sphinxAtStartPar
Returns the minimum value of a function in the given domain.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{minpoly}}(ex{[}, x, compose, polys, domain{]})
&
\sphinxAtStartPar
This is a synonym for \sphinxcode{\sphinxupquote{minimal\_polynomial()}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mobius\_transform}}(seq{[}, subset{]})
&
\sphinxAtStartPar
Performs the Mobius Transform for subset lattice with indices of sequence as bitmasks.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mod\_inverse}}(a, m)
&
\sphinxAtStartPar
Return the number \$c\$ such that, \$a times c = 1 pmod\{m\}\$ where \$c\$ has the same sign as \$m\$.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{monic}}(f, *gens, **args)
&
\sphinxAtStartPar
Divide all coefficients of \sphinxcode{\sphinxupquote{f}} by \sphinxcode{\sphinxupquote{LC(f)}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{multiline\_latex}}(lhs, rhs{[}, terms\_per\_line, ...{]})
&
\sphinxAtStartPar
This function generates a LaTeX equation with a multiline right\sphinxhyphen{}hand side in an \sphinxcode{\sphinxupquote{align*}}, \sphinxcode{\sphinxupquote{eqnarray}} or \sphinxcode{\sphinxupquote{IEEEeqnarray}} environment.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{multinomial\_coefficients}}(m, n)
&
\sphinxAtStartPar
Return a dictionary containing pairs \sphinxcode{\sphinxupquote{\{(k1,k2,..,km) : C\_kn\}}} where \sphinxcode{\sphinxupquote{C\_kn}} are multinomial coefficients such that \sphinxcode{\sphinxupquote{n=k1+k2+..+km}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{multiplicity}}(p, n)
&
\sphinxAtStartPar
Find the greatest integer m such that p**m divides n.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{n\_order}}(a, n)
&
\sphinxAtStartPar
Returns the order of \sphinxcode{\sphinxupquote{a}} modulo \sphinxcode{\sphinxupquote{n}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nextprime}}(n{[}, ith{]})
&
\sphinxAtStartPar
Return the ith prime greater than n.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nfloat}}(expr{[}, n, exponent, dkeys{]})
&
\sphinxAtStartPar
Make all Rationals in expr Floats except those in exponents (unless the exponents flag is set to True) and those in undefined functions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nonlinsolve}}(system, *symbols)
&
\sphinxAtStartPar
Solve system of \$N\$ nonlinear equations with \$M\$ variables, which means both under and overdetermined systems are supported.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{not\_empty\_in}}(finset\_intersection, *syms)
&
\sphinxAtStartPar
Finds the domain of the functions in \sphinxcode{\sphinxupquote{finset\_intersection}} in which the \sphinxcode{\sphinxupquote{finite\_set}} is not\sphinxhyphen{}empty.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{npartitions}}(n{[}, verbose{]})
&
\sphinxAtStartPar
Calculate the partition function P(n), i.e. the number of ways that n can be written as a sum of positive integers.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nroots}}(f{[}, n, maxsteps, cleanup{]})
&
\sphinxAtStartPar
Compute numerical approximations of roots of \sphinxcode{\sphinxupquote{f}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nsimplify}}(expr{[}, constants, tolerance, ...{]})
&
\sphinxAtStartPar
Find a simple representation for a number or, if there are free symbols or if \sphinxcode{\sphinxupquote{rational=True}}, then replace Floats with their Rational equivalents.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nsolve}}(*args{[}, dict{]})
&
\sphinxAtStartPar
Solve a nonlinear equation system numerically: \sphinxcode{\sphinxupquote{nsolve(f, {[}args,{]} x0, modules={[}\textquotesingle{}mpmath\textquotesingle{}{]}, **kwargs)}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nth\_power\_roots\_poly}}(f, n, *gens, **args)
&
\sphinxAtStartPar
Construct a polynomial with n\sphinxhyphen{}th powers of roots of \sphinxcode{\sphinxupquote{f}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nthroot\_mod}}(a, n, p{[}, all\_roots{]})
&
\sphinxAtStartPar
Find the solutions to \sphinxcode{\sphinxupquote{x**n = a mod p}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ntt}}(seq, prime)
&
\sphinxAtStartPar
Performs the Number Theoretic Transform (\sphinxstylestrong{NTT}), which specializes the Discrete Fourier Transform (\sphinxstylestrong{DFT}) over quotient ring \sphinxtitleref{Z/pZ} for prime \sphinxtitleref{p} instead of complex numbers \sphinxtitleref{C}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{numbered\_symbols}}({[}prefix, cls, start, exclude{]})
&
\sphinxAtStartPar
Generate an infinite stream of Symbols consisting of a prefix and increasing subscripts provided that they do not occur in \sphinxcode{\sphinxupquote{exclude}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{numer}}(expr)
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{octave\_code}}(expr{[}, assign\_to{]})
&
\sphinxAtStartPar
Converts \sphinxtitleref{expr} to a string of Octave (or Matlab) code.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ode\_order}}(expr, func)
&
\sphinxAtStartPar
Returns the order of a given differential equation with respect to func.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ones}}(*args, **kwargs)
&
\sphinxAtStartPar
Returns a matrix of ones with \sphinxcode{\sphinxupquote{rows}} rows and \sphinxcode{\sphinxupquote{cols}} columns; if \sphinxcode{\sphinxupquote{cols}} is omitted a square matrix will be returned.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ordered}}(seq{[}, keys, default, warn{]})
&
\sphinxAtStartPar
Return an iterator of the seq where keys are used to break ties in a conservative fashion: if, after applying a key, there are no ties then no other keys will be computed.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pager\_print}}(expr, **settings)
&
\sphinxAtStartPar
Prints expr using the pager, in pretty form.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{parallel\_poly\_from\_expr}}(exprs, *gens, **args)
&
\sphinxAtStartPar
Construct polynomials from expressions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{parse\_expr}}(s{[}, local\_dict, transformations, ...{]})
&
\sphinxAtStartPar
Converts the string \sphinxcode{\sphinxupquote{s}} to a SymPy expression, in \sphinxcode{\sphinxupquote{local\_dict}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pde\_separate}}(eq, fun, sep{[}, strategy{]})
&
\sphinxAtStartPar
Separate variables in partial differential equation either by additive or multiplicative separation approach.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pde\_separate\_add}}(eq, fun, sep)
&
\sphinxAtStartPar
Helper function for searching additive separable solutions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pde\_separate\_mul}}(eq, fun, sep)
&
\sphinxAtStartPar
Helper function for searching multiplicative separable solutions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pdiv}}(f, g, *gens, **args)
&
\sphinxAtStartPar
Compute polynomial pseudo\sphinxhyphen{}division of \sphinxcode{\sphinxupquote{f}} and \sphinxcode{\sphinxupquote{g}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pdsolve}}(eq{[}, func, hint, dict, solvefun{]})
&
\sphinxAtStartPar
Solves any (supported) kind of partial differential equation.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{per}}(matexpr)
&
\sphinxAtStartPar
Matrix Permanent
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{perfect\_power}}(n{[}, candidates, big, factor{]})
&
\sphinxAtStartPar
Return \sphinxcode{\sphinxupquote{(b, e)}} such that \sphinxcode{\sphinxupquote{n}} == \sphinxcode{\sphinxupquote{b**e}} if \sphinxcode{\sphinxupquote{n}} is a unique perfect power with \sphinxcode{\sphinxupquote{e \textgreater{} 1}}, else \sphinxcode{\sphinxupquote{False}} (e.g. 1 is not a perfect power).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{periodicity}}(f, symbol{[}, check{]})
&
\sphinxAtStartPar
Tests the given function for periodicity in the given symbol.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{permutedims}}(expr{[}, perm, index\_order\_old, ...{]})
&
\sphinxAtStartPar
Permutes the indices of an array.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pexquo}}(f, g, *gens, **args)
&
\sphinxAtStartPar
Compute polynomial exact pseudo\sphinxhyphen{}quotient of \sphinxcode{\sphinxupquote{f}} and \sphinxcode{\sphinxupquote{g}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{piecewise\_exclusive}}(expr, *{[}, skip\_nan, deep{]})
&
\sphinxAtStartPar
Rewrite \sphinxcode{\sphinxupquote{Piecewise}} with mutually exclusive conditions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{piecewise\_fold}}(expr{[}, evaluate{]})
&
\sphinxAtStartPar
Takes an expression containing a piecewise function and returns the expression in piecewise form.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{plot}}(*args{[}, show{]})
&
\sphinxAtStartPar
Plots a function of a single variable as a curve.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{plot\_implicit}}(expr{[}, x\_var, y\_var, ...{]})
&
\sphinxAtStartPar
A plot function to plot implicit equations / inequalities.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{plot\_parametric}}(*args{[}, show{]})
&
\sphinxAtStartPar
Plots a 2D parametric curve.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{polarify}}(eq{[}, subs, lift{]})
&
\sphinxAtStartPar
Turn all numbers in eq into their polar equivalents (under the standard choice of argument).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pollard\_pm1}}(n{[}, B, a, retries, seed{]})
&
\sphinxAtStartPar
Use Pollard\textquotesingle{}s p\sphinxhyphen{}1 method to try to extract a nontrivial factor of \sphinxcode{\sphinxupquote{n}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pollard\_rho}}(n{[}, s, a, retries, seed, ...{]})
&
\sphinxAtStartPar
Use Pollard\textquotesingle{}s rho method to try to extract a nontrivial factor of \sphinxcode{\sphinxupquote{n}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{poly}}(expr, *gens, **args)
&
\sphinxAtStartPar
Efficiently transform an expression into a polynomial.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{poly\_from\_expr}}(expr, *gens, **args)
&
\sphinxAtStartPar
Construct a polynomial from an expression.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{posify}}(eq)
&
\sphinxAtStartPar
Return \sphinxcode{\sphinxupquote{eq}} (with generic symbols made positive) and a dictionary containing the mapping between the old and new symbols.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{postfixes}}(seq)
&
\sphinxAtStartPar
Generate all postfixes of a sequence.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{postorder\_traversal}}(node{[}, keys{]})
&
\sphinxAtStartPar
Do a postorder traversal of a tree.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{powdenest}}(eq{[}, force, polar{]})
&
\sphinxAtStartPar
Collect exponents on powers as assumptions allow.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{powsimp}}(expr{[}, deep, combine, force, measure{]})
&
\sphinxAtStartPar
Reduce expression by combining powers with similar bases and exponents.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pprint}}(expr, **kwargs)
&
\sphinxAtStartPar
Prints expr in pretty form.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pprint\_try\_use\_unicode}}()
&
\sphinxAtStartPar
See if unicode output is available and leverage it if possible
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pprint\_use\_unicode}}({[}flag{]})
&
\sphinxAtStartPar
Set whether pretty\sphinxhyphen{}printer should use unicode by default
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pquo}}(f, g, *gens, **args)
&
\sphinxAtStartPar
Compute polynomial pseudo\sphinxhyphen{}quotient of \sphinxcode{\sphinxupquote{f}} and \sphinxcode{\sphinxupquote{g}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{prefixes}}(seq)
&
\sphinxAtStartPar
Generate all prefixes of a sequence.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{prem}}(f, g, *gens, **args)
&
\sphinxAtStartPar
Compute polynomial pseudo\sphinxhyphen{}remainder of \sphinxcode{\sphinxupquote{f}} and \sphinxcode{\sphinxupquote{g}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pretty\_print}}(expr, **kwargs)
&
\sphinxAtStartPar
Prints expr in pretty form.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{preview}}(expr{[}, output, viewer, euler, ...{]})
&
\sphinxAtStartPar
View expression or LaTeX markup in PNG, DVI, PostScript or PDF form.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{prevprime}}(n)
&
\sphinxAtStartPar
Return the largest prime smaller than n.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{prime}}(nth)
&
\sphinxAtStartPar
Return the nth prime, with the primes indexed as prime(1) = 2, prime(2) = 3, etc.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{prime\_decomp}}(p{[}, T, ZK, dK, radical{]})
&
\sphinxAtStartPar
Compute the decomposition of rational prime \sphinxstyleemphasis{p} in a number field.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{prime\_valuation}}(I, P)
&
\sphinxAtStartPar
Compute the \sphinxstyleemphasis{P}\sphinxhyphen{}adic valuation for an integral ideal \sphinxstyleemphasis{I}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{primefactors}}(n{[}, limit, verbose{]})
&
\sphinxAtStartPar
Return a sorted list of n\textquotesingle{}s prime factors, ignoring multiplicity and any composite factor that remains if the limit was set too low for complete factorization.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{primerange}}(a{[}, b{]})
&
\sphinxAtStartPar
Generate a list of all prime numbers in the range {[}2, a), or {[}a, b).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{primitive}}(f, *gens, **args)
&
\sphinxAtStartPar
Compute content and the primitive form of \sphinxcode{\sphinxupquote{f}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{primitive\_element}}(extension{[}, x, ex, polys{]})
&
\sphinxAtStartPar
Find a single generator for a number field given by several generators.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{primitive\_root}}(p)
&
\sphinxAtStartPar
Returns the smallest primitive root or None.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{primorial}}(n{[}, nth{]})
&
\sphinxAtStartPar
Returns the product of the first n primes (default) or the primes less than or equal to n (when \sphinxcode{\sphinxupquote{nth=False}}).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{print\_ccode}}(expr, **settings)
&
\sphinxAtStartPar
Prints C representation of the given expression.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{print\_fcode}}(expr, **settings)
&
\sphinxAtStartPar
Prints the Fortran representation of the given expression.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{print\_glsl}}(expr, **settings)
&
\sphinxAtStartPar
Prints the GLSL representation of the given expression.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{print\_gtk}}(x{[}, start\_viewer{]})
&
\sphinxAtStartPar
Print to Gtkmathview, a gtk widget capable of rendering MathML.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{print\_jscode}}(expr, **settings)
&
\sphinxAtStartPar
Prints the Javascript representation of the given expression.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{print\_latex}}(expr, **settings)
&
\sphinxAtStartPar
Prints LaTeX representation of the given expression.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{print\_maple\_code}}(expr, **settings)
&
\sphinxAtStartPar
Prints the Maple representation of the given expression.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{print\_mathml}}(expr{[}, printer{]})
&
\sphinxAtStartPar
Prints a pretty representation of the MathML code for expr.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{print\_python}}(expr, **settings)
&
\sphinxAtStartPar
Print output of python() function
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{print\_rcode}}(expr, **settings)
&
\sphinxAtStartPar
Prints R representation of the given expression.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{print\_tree}}(node{[}, assumptions{]})
&
\sphinxAtStartPar
Prints a tree representation of "node".
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{prod}}(a{[}, start{]})
&
\sphinxAtStartPar
Return product of elements of a. Start with int 1 so if only
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{product}}(*args, **kwargs)
&
\sphinxAtStartPar
Compute the product.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{proper\_divisor\_count}}(n{[}, modulus{]})
&
\sphinxAtStartPar
Return the number of proper divisors of \sphinxcode{\sphinxupquote{n}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{proper\_divisors}}(n{[}, generator{]})
&
\sphinxAtStartPar
Return all divisors of n except n, sorted by default.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{public}}(obj)
&
\sphinxAtStartPar
Append \sphinxcode{\sphinxupquote{obj}}\textquotesingle{}s name to global \sphinxcode{\sphinxupquote{\_\_all\_\_}} variable (call site).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pycode}}(expr, **settings)
&
\sphinxAtStartPar
Converts an expr to a string of Python code
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{python}}(expr, **settings)
&
\sphinxAtStartPar
Return Python interpretation of passed expression (can be passed to the exec() function without any modifications)
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{quadratic\_congruence}}(a, b, c, p)
&
\sphinxAtStartPar
Find the solutions to {\color{red}\bfseries{}\textasciigrave{}\textasciigrave{}}a x**2 + b x + c = 0 mod p.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{quadratic\_residues}}(p)
&
\sphinxAtStartPar
Returns the list of quadratic residues.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{quo}}(f, g, *gens, **args)
&
\sphinxAtStartPar
Compute polynomial quotient of \sphinxcode{\sphinxupquote{f}} and \sphinxcode{\sphinxupquote{g}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{rad}}(d)
&
\sphinxAtStartPar
Return the radian value for the given degrees (pi = 180 degrees).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{radsimp}}(expr{[}, symbolic, max\_terms{]})
&
\sphinxAtStartPar
Rationalize the denominator by removing square roots.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{randMatrix}}(r{[}, c, min, max, seed, ...{]})
&
\sphinxAtStartPar
Create random matrix with dimensions \sphinxcode{\sphinxupquote{r}} x \sphinxcode{\sphinxupquote{c}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{random\_poly}}(x, n, inf, sup{[}, domain, polys{]})
&
\sphinxAtStartPar
Generates a polynomial of degree \sphinxcode{\sphinxupquote{n}} with coefficients in \sphinxcode{\sphinxupquote{{[}inf, sup{]}}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{randprime}}(a, b)
&
\sphinxAtStartPar
Return a random prime number in the range {[}a, b).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{rational\_interpolate}}(data, degnum{[}, X{]})
&
\sphinxAtStartPar
Returns a rational interpolation, where the data points are element of any integral domain.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ratsimp}}(expr)
&
\sphinxAtStartPar
Put an expression over a common denominator, cancel and reduce.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ratsimpmodprime}}(expr, G, *gens{[}, quick, ...{]})
&
\sphinxAtStartPar
Simplifies a rational expression \sphinxcode{\sphinxupquote{expr}} modulo the prime ideal generated by \sphinxcode{\sphinxupquote{G}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{rcode}}(expr{[}, assign\_to{]})
&
\sphinxAtStartPar
Converts an expr to a string of r code
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{rcollect}}(expr, *vars)
&
\sphinxAtStartPar
Recursively collect sums in an expression.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{real\_root}}(arg{[}, n, evaluate{]})
&
\sphinxAtStartPar
Return the real \sphinxstyleemphasis{n}\textquotesingle{}th\sphinxhyphen{}root of \sphinxstyleemphasis{arg} if possible.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{real\_roots}}(f{[}, multiple{]})
&
\sphinxAtStartPar
Return a list of real roots with multiplicities of \sphinxcode{\sphinxupquote{f}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{reduce\_abs\_inequalities}}(exprs, gen)
&
\sphinxAtStartPar
Reduce a system of inequalities with nested absolute values.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{reduce\_abs\_inequality}}(expr, rel, gen)
&
\sphinxAtStartPar
Reduce an inequality with nested absolute values.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{reduce\_inequalities}}(inequalities{[}, symbols{]})
&
\sphinxAtStartPar
Reduce a system of inequalities with rational coefficients.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{reduced}}(f, G, *gens, **args)
&
\sphinxAtStartPar
Reduces a polynomial \sphinxcode{\sphinxupquote{f}} modulo a set of polynomials \sphinxcode{\sphinxupquote{G}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{refine}}(expr{[}, assumptions{]})
&
\sphinxAtStartPar
Simplify an expression using assumptions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{refine\_root}}(f, s, t{[}, eps, steps, fast, ...{]})
&
\sphinxAtStartPar
Refine an isolating interval of a root to the given precision.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{register\_handler}}(key, handler)
&
\sphinxAtStartPar
Register a handler in the ask system.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{rem}}(f, g, *gens, **args)
&
\sphinxAtStartPar
Compute polynomial remainder of \sphinxcode{\sphinxupquote{f}} and \sphinxcode{\sphinxupquote{g}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{remove\_handler}}(key, handler)
&
\sphinxAtStartPar
Removes a handler from the ask system.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{reshape}}(seq, how)
&
\sphinxAtStartPar
Reshape the sequence according to the template in \sphinxcode{\sphinxupquote{how}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{residue}}(expr, x, x0)
&
\sphinxAtStartPar
Finds the residue of \sphinxcode{\sphinxupquote{expr}} at the point x=x0.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{resultant}}(f, g, *gens{[}, includePRS{]})
&
\sphinxAtStartPar
Compute resultant of \sphinxcode{\sphinxupquote{f}} and \sphinxcode{\sphinxupquote{g}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ring}}(symbols, domain{[}, order{]})
&
\sphinxAtStartPar
Construct a polynomial ring returning \sphinxcode{\sphinxupquote{(ring, x\_1, ..., x\_n)}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{root}}(arg, n{[}, k, evaluate{]})
&
\sphinxAtStartPar
Returns the \sphinxstyleemphasis{k}\sphinxhyphen{}th \sphinxstyleemphasis{n}\sphinxhyphen{}th root of \sphinxcode{\sphinxupquote{arg}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{rootof}}(f, x{[}, index, radicals, expand{]})
&
\sphinxAtStartPar
An indexed root of a univariate polynomial.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{roots}}(f, *gens{[}, auto, cubics, trig, ...{]})
&
\sphinxAtStartPar
Computes symbolic roots of a univariate polynomial.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{rot\_axis1}}(theta)
&
\sphinxAtStartPar
Returns a rotation matrix for a rotation of theta (in radians) about the 1\sphinxhyphen{}axis.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{rot\_axis2}}(theta)
&
\sphinxAtStartPar
Returns a rotation matrix for a rotation of theta (in radians) about the 2\sphinxhyphen{}axis.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{rot\_axis3}}(theta)
&
\sphinxAtStartPar
Returns a rotation matrix for a rotation of theta (in radians) about the 3\sphinxhyphen{}axis.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{rot\_ccw\_axis1}}(theta)
&
\sphinxAtStartPar
Returns a rotation matrix for a rotation of theta (in radians) about the 1\sphinxhyphen{}axis.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{rot\_ccw\_axis2}}(theta)
&
\sphinxAtStartPar
Returns a rotation matrix for a rotation of theta (in radians) about the 2\sphinxhyphen{}axis.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{rot\_ccw\_axis3}}(theta)
&
\sphinxAtStartPar
Returns a rotation matrix for a rotation of theta (in radians) about the 3\sphinxhyphen{}axis.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{rot\_givens}}(i, j, theta{[}, dim{]})
&
\sphinxAtStartPar
Returns a a Givens rotation matrix, a a rotation in the plane spanned by two coordinates axes.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{rotations}}(s{[}, dir{]})
&
\sphinxAtStartPar
Return a generator giving the items in s as list where each subsequent list has the items rotated to the left (default) or right (\sphinxcode{\sphinxupquote{dir=\sphinxhyphen{}1}}) relative to the previous list.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{round\_two}}(T{[}, radicals{]})
&
\sphinxAtStartPar
Zassenhaus\textquotesingle{}s "Round 2" algorithm.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{rsolve}}(f, y{[}, init{]})
&
\sphinxAtStartPar
Solve univariate recurrence with rational coefficients.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{rsolve\_hyper}}(coeffs, f, n, **hints)
&
\sphinxAtStartPar
Given linear recurrence operator \sphinxtitleref{operatorname\{L\}} of order \sphinxtitleref{k} with polynomial coefficients and inhomogeneous equation \sphinxtitleref{operatorname\{L\} y = f} we seek for all hypergeometric solutions over field \sphinxtitleref{K} of characteristic zero.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{rsolve\_poly}}(coeffs, f, n{[}, shift{]})
&
\sphinxAtStartPar
Given linear recurrence operator \sphinxtitleref{operatorname\{L\}} of order \sphinxtitleref{k} with polynomial coefficients and inhomogeneous equation \sphinxtitleref{operatorname\{L\} y = f}, where \sphinxtitleref{f} is a polynomial, we seek for all polynomial solutions over field \sphinxtitleref{K} of characteristic zero.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{rsolve\_ratio}}(coeffs, f, n, **hints)
&
\sphinxAtStartPar
Given linear recurrence operator \sphinxtitleref{operatorname\{L\}} of order \sphinxtitleref{k} with polynomial coefficients and inhomogeneous equation \sphinxtitleref{operatorname\{L\} y = f}, where \sphinxtitleref{f} is a polynomial, we seek for all rational solutions over field \sphinxtitleref{K} of characteristic zero.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{rust\_code}}(expr{[}, assign\_to{]})
&
\sphinxAtStartPar
Converts an expr to a string of Rust code
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{satisfiable}}(expr{[}, algorithm, all\_models, ...{]})
&
\sphinxAtStartPar
Check satisfiability of a propositional sentence.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{separatevars}}(expr{[}, symbols, dict, force{]})
&
\sphinxAtStartPar
Separates variables in an expression, if possible.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sequence}}(seq{[}, limits{]})
&
\sphinxAtStartPar
Returns appropriate sequence object.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{series}}(expr{[}, x, x0, n, dir{]})
&
\sphinxAtStartPar
Series expansion of expr around point \sphinxtitleref{x = x0}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{seterr}}({[}divide{]})
&
\sphinxAtStartPar
Should SymPy raise an exception on 0/0 or return a nan?
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sfield}}(exprs, *symbols, **options)
&
\sphinxAtStartPar
Construct a field deriving generators and domain from options and input expressions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{shape}}()
&
\sphinxAtStartPar
Return the shape of the \sphinxstyleemphasis{expr} as a tuple.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sift}}(seq, keyfunc{[}, binary{]})
&
\sphinxAtStartPar
Sift the sequence, \sphinxcode{\sphinxupquote{seq}} according to \sphinxcode{\sphinxupquote{keyfunc}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{signsimp}}(expr{[}, evaluate{]})
&
\sphinxAtStartPar
Make all Add sub\sphinxhyphen{}expressions canonical wrt sign.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{simplify}}(expr{[}, ratio, measure, rational, ...{]})
&
\sphinxAtStartPar
Simplifies the given expression.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{simplify\_logic}}(expr{[}, form, deep, force, ...{]})
&
\sphinxAtStartPar
This function simplifies a boolean function to its simplified version in SOP or POS form.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sine\_transform}}(f, x, k, **hints)
&
\sphinxAtStartPar
Compute the unitary, ordinary\sphinxhyphen{}frequency sine transform of \sphinxtitleref{f}, defined as
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{singularities}}(expression, symbol{[}, domain{]})
&
\sphinxAtStartPar
Find singularities of a given function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{singularityintegrate}}(f, x)
&
\sphinxAtStartPar
This function handles the indefinite integrations of Singularity functions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{smtlib\_code}}(expr{[}, auto\_assert, ...{]})
&
\sphinxAtStartPar
Converts \sphinxcode{\sphinxupquote{expr}} to a string of smtlib code.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{solve}}(f, *symbols, **flags)
&
\sphinxAtStartPar
Algebraically solves equations and systems of equations.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{solve\_linear}}(lhs{[}, rhs, symbols, exclude{]})
&
\sphinxAtStartPar
Return a tuple derived from \sphinxcode{\sphinxupquote{f = lhs \sphinxhyphen{} rhs}} that is one of the following: \sphinxcode{\sphinxupquote{(0, 1)}}, \sphinxcode{\sphinxupquote{(0, 0)}}, \sphinxcode{\sphinxupquote{(symbol, solution)}}, \sphinxcode{\sphinxupquote{(n, d)}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{solve\_linear\_system}}(system, *symbols, **flags)
&
\sphinxAtStartPar
Solve system of \$N\$ linear equations with \$M\$ variables, which means both under\sphinxhyphen{} and overdetermined systems are supported.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{solve\_linear\_system\_LU}}(matrix, syms)
&
\sphinxAtStartPar
Solves the augmented matrix system using \sphinxcode{\sphinxupquote{LUsolve}} and returns a dictionary in which solutions are keyed to the symbols of \sphinxstyleemphasis{syms} as ordered.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{solve\_poly\_inequality}}(poly, rel)
&
\sphinxAtStartPar
Solve a polynomial inequality with rational coefficients.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{solve\_poly\_system}}(seq, *gens{[}, strict{]})
&
\sphinxAtStartPar
Return a list of solutions for the system of polynomial equations or else None.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{solve\_rational\_inequalities}}(eqs)
&
\sphinxAtStartPar
Solve a system of rational inequalities with rational coefficients.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{solve\_triangulated}}(polys, *gens, **args)
&
\sphinxAtStartPar
Solve a polynomial system using Gianni\sphinxhyphen{}Kalkbrenner algorithm.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{solve\_undetermined\_coeffs}}(equ, coeffs, ...)
&
\sphinxAtStartPar
Solve a system of equations in \$k\$ parameters that is formed by matching coefficients in variables \sphinxcode{\sphinxupquote{coeffs}} that are on factors dependent on the remaining variables (or those given explicitly by \sphinxcode{\sphinxupquote{syms}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{solve\_univariate\_inequality}}(expr, gen{[}, ...{]})
&
\sphinxAtStartPar
Solves a real univariate inequality.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{solveset}}(f{[}, symbol, domain{]})
&
\sphinxAtStartPar
Solves a given inequality or equation with set as output
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sqf}}(f, *gens, **args)
&
\sphinxAtStartPar
Compute square\sphinxhyphen{}free factorization of \sphinxcode{\sphinxupquote{f}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sqf\_list}}(f, *gens, **args)
&
\sphinxAtStartPar
Compute a list of square\sphinxhyphen{}free factors of \sphinxcode{\sphinxupquote{f}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sqf\_norm}}(f, *gens, **args)
&
\sphinxAtStartPar
Compute square\sphinxhyphen{}free norm of \sphinxcode{\sphinxupquote{f}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sqf\_part}}(f, *gens, **args)
&
\sphinxAtStartPar
Compute square\sphinxhyphen{}free part of \sphinxcode{\sphinxupquote{f}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sqrt}}(arg{[}, evaluate{]})
&
\sphinxAtStartPar
Returns the principal square root.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sqrt\_mod}}(a, p{[}, all\_roots{]})
&
\sphinxAtStartPar
Find a root of \sphinxcode{\sphinxupquote{x**2 = a mod p}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sqrt\_mod\_iter}}(a, p{[}, domain{]})
&
\sphinxAtStartPar
Iterate over solutions to \sphinxcode{\sphinxupquote{x**2 = a mod p}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sqrtdenest}}(expr{[}, max\_iter{]})
&
\sphinxAtStartPar
Denests sqrts in an expression that contain other square roots if possible, otherwise returns the expr unchanged.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sring}}(exprs, *symbols, **options)
&
\sphinxAtStartPar
Construct a ring deriving generators and domain from options and input expressions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{stationary\_points}}(f, symbol{[}, domain{]})
&
\sphinxAtStartPar
Returns the stationary points of a function (where derivative of the function is 0) in the given domain.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sturm}}(f, *gens, **args)
&
\sphinxAtStartPar
Compute Sturm sequence of \sphinxcode{\sphinxupquote{f}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{subresultants}}(f, g, *gens, **args)
&
\sphinxAtStartPar
Compute subresultant PRS of \sphinxcode{\sphinxupquote{f}} and \sphinxcode{\sphinxupquote{g}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{subsets}}(seq{[}, k, repetition{]})
&
\sphinxAtStartPar
Generates all \sphinxtitleref{k}\sphinxhyphen{}subsets (combinations) from an \sphinxtitleref{n}\sphinxhyphen{}element set, \sphinxcode{\sphinxupquote{seq}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{substitution}}(system, symbols{[}, result, ...{]})
&
\sphinxAtStartPar
Solves the \sphinxtitleref{system} using substitution method.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{summation}}(f, *symbols, **kwargs)
&
\sphinxAtStartPar
Compute the summation of f with respect to symbols.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{swinnerton\_dyer\_poly}}(n{[}, x, polys{]})
&
\sphinxAtStartPar
Generates n\sphinxhyphen{}th Swinnerton\sphinxhyphen{}Dyer polynomial in \sphinxtitleref{x}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{symarray}}(prefix, shape, **kwargs)
&
\sphinxAtStartPar
Create a numpy ndarray of symbols (as an object array).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{symbols}}(names, *{[}, cls{]})
&
\sphinxAtStartPar
Transform strings into instances of \sphinxcode{\sphinxupquote{Symbol}} class.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{symmetric\_poly}}(n, *gens{[}, polys{]})
&
\sphinxAtStartPar
Generates symmetric polynomial of order \sphinxtitleref{n}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{symmetrize}}(F, *gens, **args)
&
\sphinxAtStartPar
Rewrite a polynomial in terms of elementary symmetric polynomials.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sympify}}(a{[}, locals, convert\_xor, strict, ...{]})
&
\sphinxAtStartPar
Converts an arbitrary expression to a type that can be used inside SymPy.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{take}}(iter, n)
&
\sphinxAtStartPar
Return \sphinxcode{\sphinxupquote{n}} items from \sphinxcode{\sphinxupquote{iter}} iterator.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{tensorcontraction}}(array, *contraction\_axes)
&
\sphinxAtStartPar
Contraction of an array\sphinxhyphen{}like object on the specified axes.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{tensordiagonal}}(array, *diagonal\_axes)
&
\sphinxAtStartPar
Diagonalization of an array\sphinxhyphen{}like object on the specified axes.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{tensorproduct}}(*args)
&
\sphinxAtStartPar
Tensor product among scalars or array\sphinxhyphen{}like objects.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{terms\_gcd}}(f, *gens, **args)
&
\sphinxAtStartPar
Remove GCD of terms from \sphinxcode{\sphinxupquote{f}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{textplot}}(expr, a, b{[}, W, H{]})
&
\sphinxAtStartPar
Print a crude ASCII art plot of the SymPy expression \textquotesingle{}expr\textquotesingle{} (which should contain a single symbol, e.g. x or something else) over the interval {[}a, b{]}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{threaded}}(func)
&
\sphinxAtStartPar
Apply \sphinxcode{\sphinxupquote{func}} to sub\sphinxhyphen{}\sphinxhyphen{}elements of an object, including \sphinxcode{\sphinxupquote{Add}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{timed}}(func{[}, setup, limit{]})
&
\sphinxAtStartPar
Adaptively measure execution time of a function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{to\_cnf}}(expr{[}, simplify, force{]})
&
\sphinxAtStartPar
Convert a propositional logical sentence \sphinxcode{\sphinxupquote{expr}} to conjunctive normal form: \sphinxcode{\sphinxupquote{((A | \textasciitilde{}B | ...) \& (B | C | ...) \& ...)}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{to\_dnf}}(expr{[}, simplify, force{]})
&
\sphinxAtStartPar
Convert a propositional logical sentence \sphinxcode{\sphinxupquote{expr}} to disjunctive normal form: \sphinxcode{\sphinxupquote{((A \& \textasciitilde{}B \& ...) | (B \& C \& ...) | ...)}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{to\_nnf}}(expr{[}, simplify{]})
&
\sphinxAtStartPar
Converts \sphinxcode{\sphinxupquote{expr}} to Negation Normal Form (NNF).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{to\_number\_field}}(extension{[}, theta, gen, alias{]})
&
\sphinxAtStartPar
Express one algebraic number in the field generated by another.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{together}}(expr{[}, deep, fraction{]})
&
\sphinxAtStartPar
Denest and combine rational expressions using symbolic methods.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{topological\_sort}}(graph{[}, key{]})
&
\sphinxAtStartPar
Topological sort of graph\textquotesingle{}s vertices.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{total\_degree}}(f, *gens)
&
\sphinxAtStartPar
Return the total\_degree of \sphinxcode{\sphinxupquote{f}} in the given variables.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{trace}}(expr)
&
\sphinxAtStartPar
Trace of a Matrix.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{trailing}}(n)
&
\sphinxAtStartPar
Count the number of trailing zero digits in the binary representation of n, i.e. determine the largest power of 2 that divides n.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{trigsimp}}(expr{[}, inverse{]})
&
\sphinxAtStartPar
Returns a reduced expression by using known trig identities.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{trunc}}(f, p, *gens, **args)
&
\sphinxAtStartPar
Reduce \sphinxcode{\sphinxupquote{f}} modulo a constant \sphinxcode{\sphinxupquote{p}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{unbranched\_argument}}(arg)
&
\sphinxAtStartPar
Returns periodic argument of arg with period as infinity.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{unflatten}}(iter{[}, n{]})
&
\sphinxAtStartPar
Group \sphinxcode{\sphinxupquote{iter}} into tuples of length \sphinxcode{\sphinxupquote{n}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{unpolarify}}(eq{[}, subs, exponents\_only{]})
&
\sphinxAtStartPar
If \sphinxtitleref{p} denotes the projection from the Riemann surface of the logarithm to the complex line, return a simplified version \sphinxtitleref{eq\textquotesingle{}} of \sphinxtitleref{eq} such that \sphinxtitleref{p(eq\textquotesingle{}) = p(eq)}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{use}}(expr, func{[}, level, args, kwargs{]})
&
\sphinxAtStartPar
Use \sphinxcode{\sphinxupquote{func}} to transform \sphinxcode{\sphinxupquote{expr}} at the given level.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{var}}(names, **args)
&
\sphinxAtStartPar
Create symbols and inject them into the global namespace.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{variations}}(seq, n{[}, repetition{]})
&
\sphinxAtStartPar
Returns an iterator over the n\sphinxhyphen{}sized variations of \sphinxcode{\sphinxupquote{seq}} (size N).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{vfield}}(symbols, domain{[}, order{]})
&
\sphinxAtStartPar
Construct new rational function field and inject generators into global namespace.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{viete}}(f{[}, roots{]})
&
\sphinxAtStartPar
Generate Viete\textquotesingle{}s formulas for \sphinxcode{\sphinxupquote{f}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{vring}}(symbols, domain{[}, order{]})
&
\sphinxAtStartPar
Construct a polynomial ring and inject \sphinxcode{\sphinxupquote{x\_1, ..., x\_n}} into the global namespace.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{wronskian}}(functions, var{[}, method{]})
&
\sphinxAtStartPar
Compute Wronskian for {[}{]} of functions
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{xfield}}(symbols, domain{[}, order{]})
&
\sphinxAtStartPar
Construct new rational function field returning (field, (x1, ..., xn)).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{xring}}(symbols, domain{[}, order{]})
&
\sphinxAtStartPar
Construct a polynomial ring returning \sphinxcode{\sphinxupquote{(ring, (x\_1, ..., x\_n))}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{xthreaded}}(func)
&
\sphinxAtStartPar
Apply \sphinxcode{\sphinxupquote{func}} to sub\sphinxhyphen{}\sphinxhyphen{}elements of an object, excluding \sphinxcode{\sphinxupquote{Add}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{zeros}}(*args, **kwargs)
&
\sphinxAtStartPar
Returns a matrix of zeros with \sphinxcode{\sphinxupquote{rows}} rows and \sphinxcode{\sphinxupquote{cols}} columns; if \sphinxcode{\sphinxupquote{cols}} is omitted a square matrix will be returned.
\\
\sphinxbottomrule
\end{longtable}
\sphinxtableafterendhook
\sphinxatlongtableend
\end{savenotes}
\subsubsection*{Classes}


\begin{savenotes}
\sphinxatlongtablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\makeatletter
  \LTleft \@totalleftmargin plus1fill
  \LTright\dimexpr\columnwidth-\@totalleftmargin-\linewidth\relax plus1fill
\makeatother
\begin{longtable}{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\endfirsthead

\multicolumn{2}{c}{\sphinxnorowcolor
    \makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}%
}\\
\sphinxtoprule
\endhead

\sphinxbottomrule
\multicolumn{2}{r}{\sphinxnorowcolor
    \makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}%
}\\
\endfoot

\endlastfoot
\sphinxtableatstartofbodyhook

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Abs}}(arg)
&
\sphinxAtStartPar
Return the absolute value of the argument.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{AccumBounds}}
&
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{AccumulationBounds}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Add}}(*args{[}, evaluate, \_sympify{]})
&
\sphinxAtStartPar
Expression representing addition operation for algebraic group.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Adjoint}}(*args, **kwargs)
&
\sphinxAtStartPar
The Hermitian adjoint of a matrix expression.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{AlgebraicField}}(dom, *ext{[}, alias{]})
&
\sphinxAtStartPar
Algebraic number field \DUrole{xref}{\DUrole{std}{\DUrole{std-ref}{QQ(a)}}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{AlgebraicNumber}}(expr{[}, coeffs, alias{]})
&
\sphinxAtStartPar
Class for representing algebraic numbers in SymPy.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{And}}(*args)
&
\sphinxAtStartPar
Logical AND function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{AppliedPredicate}}(predicate, *args)
&
\sphinxAtStartPar
The class of expressions resulting from applying \sphinxcode{\sphinxupquote{Predicate}} to the arguments.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Array}}
&
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{ImmutableDenseNDimArray}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{AssumptionsContext}}
&
\sphinxAtStartPar
Set containing default assumptions which are applied to the \sphinxcode{\sphinxupquote{ask()}} function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Atom}}(*args)
&
\sphinxAtStartPar
A parent class for atomic things.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{AtomicExpr}}(*args)
&
\sphinxAtStartPar
A parent class for object which are both atoms and Exprs.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.sensitivity.sensitivity_tools:src.sensitivity.sensitivity_tools.AutoSympy}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{AutoSympy}}}}}(model)
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Basic}}(*args)
&
\sphinxAtStartPar
Base class for all SymPy objects.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{BlockDiagMatrix}}(*mats)
&
\sphinxAtStartPar
A sparse matrix with block matrices along its diagonals
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{BlockMatrix}}(*args, **kwargs)
&
\sphinxAtStartPar
A BlockMatrix is a Matrix comprised of other matrices.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{CRootOf}}
&
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{ComplexRootOf}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Chi}}(z)
&
\sphinxAtStartPar
Cosh integral.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Ci}}(z)
&
\sphinxAtStartPar
Cosine integral.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Circle}}(*args, **kwargs)
&
\sphinxAtStartPar
A circle in space.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Complement}}(a, b{[}, evaluate{]})
&
\sphinxAtStartPar
Represents the set difference or relative complement of a set with another set.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ComplexField}}({[}prec, dps, tol{]})
&
\sphinxAtStartPar
Complex numbers up to the given precision.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ComplexRegion}}(sets{[}, polar{]})
&
\sphinxAtStartPar
Represents the Set of all Complex Numbers.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ComplexRootOf}}(f, x{[}, index, radicals, expand{]})
&
\sphinxAtStartPar
Represents an indexed complex root of a polynomial.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ConditionSet}}(sym, condition{[}, base\_set{]})
&
\sphinxAtStartPar
Set of elements which satisfies a given condition.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Contains}}(x, s)
&
\sphinxAtStartPar
Asserts that x is an element of the set S.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.sensitivity.sensitivity_tools:src.sensitivity.sensitivity_tools.CoordMap}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{CoordMap}}}}}(var\_vector, eq\_duals, ineq\_duals, ...)
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{CosineTransform}}(*args)
&
\sphinxAtStartPar
Class representing unevaluated cosine transforms.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Curve}}(function, limits)
&
\sphinxAtStartPar
A curve in space.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{DeferredVector}}(name, **assumptions)
&
\sphinxAtStartPar
A vector whose components are deferred (e.g. for use with lambdify).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{DenseNDimArray}}(*args, **kwargs)
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Derivative}}(expr, *variables, **kwargs)
&
\sphinxAtStartPar
Carries out differentiation of the given expression with respect to symbols.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Determinant}}(mat)
&
\sphinxAtStartPar
Matrix Determinant
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{DiagMatrix}}(vector)
&
\sphinxAtStartPar
Turn a vector into a diagonal matrix.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{DiagonalMatrix}}(*args, **kwargs)
&
\sphinxAtStartPar
DiagonalMatrix(M) will create a matrix expression that behaves as though all off\sphinxhyphen{}diagonal elements, \sphinxtitleref{M{[}i, j{]}} where \sphinxtitleref{i != j}, are zero.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{DiagonalOf}}(*args, **kwargs)
&
\sphinxAtStartPar
DiagonalOf(M) will create a matrix expression that is equivalent to the diagonal of \sphinxtitleref{M}, represented as a single column matrix.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Dict}}(*args)
&
\sphinxAtStartPar
Wrapper around the builtin dict object.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.sensitivity.sensitivity_tools:src.sensitivity.sensitivity_tools.DifferentialMapping}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{DifferentialMapping}}}}}(US, coord2item, ...)
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{DiracDelta}}(arg{[}, k{]})
&
\sphinxAtStartPar
The DiracDelta function and its derivatives.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{DisjointUnion}}(*sets)
&
\sphinxAtStartPar
Represents the disjoint union (also known as the external disjoint union) of a finite number of sets.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Domain}}()
&
\sphinxAtStartPar
Superclass for all domains in the polys domains system.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{DotProduct}}(arg1, arg2)
&
\sphinxAtStartPar
Dot product of vector matrices
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Dummy}}({[}name, dummy\_index{]})
&
\sphinxAtStartPar
Dummy symbols are each unique, even if they have the same name:
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{EPath}}(path)
&
\sphinxAtStartPar
Manipulate expressions using paths.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Ei}}(z)
&
\sphinxAtStartPar
The classical exponential integral.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Ellipse}}({[}center, hradius, vradius, eccentricity{]})
&
\sphinxAtStartPar
An elliptical GeometryEntity.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Eq}}
&
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{Equality}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Equality}}(lhs, rhs, **options)
&
\sphinxAtStartPar
An equal relation between two objects.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Equivalent}}(*args)
&
\sphinxAtStartPar
Equivalence relation.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Expr}}(*args)
&
\sphinxAtStartPar
Base class for algebraic expressions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ExpressionDomain}}()
&
\sphinxAtStartPar
A class for arbitrary expressions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{FF}}
&
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{FiniteField}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{FF\_gmpy}}
&
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{GMPYFiniteField}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{FF\_python}}
&
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{PythonFiniteField}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{FallingFactorial}}(x, k)
&
\sphinxAtStartPar
Falling factorial (related to rising factorial) is a double valued function arising in concrete mathematics, hypergeometric functions and series expansions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{FiniteField}}(mod{[}, symmetric{]})
&
\sphinxAtStartPar
Finite field of prime order \DUrole{xref}{\DUrole{std}{\DUrole{std-ref}{GF(p)}}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{FiniteSet}}(*args, **kwargs)
&
\sphinxAtStartPar
Represents a finite set of Sympy expressions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Float}}(num{[}, dps, precision{]})
&
\sphinxAtStartPar
Represent a floating\sphinxhyphen{}point number of arbitrary precision.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{FourierTransform}}(*args)
&
\sphinxAtStartPar
Class representing unevaluated Fourier transforms.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{FractionField}}(domain\_or\_field{[}, symbols, order{]})
&
\sphinxAtStartPar
A class for representing multivariate rational function fields.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Function}}(*args)
&
\sphinxAtStartPar
Base class for applied mathematical functions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{FunctionClass}}(*args, **kwargs)
&
\sphinxAtStartPar
Base class for function classes.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{FunctionMatrix}}(rows, cols, lamda)
&
\sphinxAtStartPar
Represents a matrix using a function (\sphinxcode{\sphinxupquote{Lambda}}) which gives outputs according to the coordinates of each matrix entries.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{GF}}
&
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{FiniteField}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{GMPYFiniteField}}(mod{[}, symmetric{]})
&
\sphinxAtStartPar
Finite field based on GMPY integers.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{GMPYIntegerRing}}()
&
\sphinxAtStartPar
Integer ring based on GMPY\textquotesingle{}s \sphinxcode{\sphinxupquote{mpz}} type.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{GMPYRationalField}}()
&
\sphinxAtStartPar
Rational field based on GMPY\textquotesingle{}s \sphinxcode{\sphinxupquote{mpq}} type.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Ge}}
&
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{GreaterThan}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{GreaterThan}}(lhs, rhs, **options)
&
\sphinxAtStartPar
Class representations of inequalities.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{GroebnerBasis}}(F, *gens, **args)
&
\sphinxAtStartPar
Represents a reduced Groebner basis.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Gt}}
&
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{StrictGreaterThan}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{HadamardPower}}(base, exp)
&
\sphinxAtStartPar
Elementwise power of matrix expressions
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{HadamardProduct}}(*args{[}, evaluate, check{]})
&
\sphinxAtStartPar
Elementwise product of matrix expressions
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{HankelTransform}}(*args)
&
\sphinxAtStartPar
Class representing unevaluated Hankel transforms.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Heaviside}}(arg{[}, H0{]})
&
\sphinxAtStartPar
Heaviside step function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ITE}}(*args)
&
\sphinxAtStartPar
If\sphinxhyphen{}then\sphinxhyphen{}else clause.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Identity}}(n)
&
\sphinxAtStartPar
The Matrix Identity I \sphinxhyphen{} multiplicative identity
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Idx}}(label{[}, range{]})
&
\sphinxAtStartPar
Represents an integer index as an \sphinxcode{\sphinxupquote{Integer}} or integer expression.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ImageSet}}(flambda, *sets)
&
\sphinxAtStartPar
Image of a set under a mathematical function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ImmutableDenseMatrix}}(*args, **kwargs)
&
\sphinxAtStartPar
Create an immutable version of a matrix.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ImmutableDenseNDimArray}}(iterable{[}, shape{]})
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ImmutableMatrix}}
&
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{ImmutableDenseMatrix}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ImmutableSparseMatrix}}(*args, **kwargs)
&
\sphinxAtStartPar
Create an immutable version of a sparse matrix.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ImmutableSparseNDimArray}}({[}iterable, shape{]})
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Implies}}(*args)
&
\sphinxAtStartPar
Logical implication.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Indexed}}(base, *args, **kw\_args)
&
\sphinxAtStartPar
Represents a mathematical object with indices.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{IndexedBase}}(label{[}, shape, offset, strides{]})
&
\sphinxAtStartPar
Represent the base or stem of an indexed object
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Integer}}(i)
&
\sphinxAtStartPar
Represents integer numbers of any size.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{IntegerRing}}()
&
\sphinxAtStartPar
The domain \sphinxcode{\sphinxupquote{ZZ}} representing the integers \sphinxtitleref{mathbb\{Z\}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Integral}}(function, *symbols, **assumptions)
&
\sphinxAtStartPar
Represents unevaluated integral.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Intersection}}(*args, **kwargs)
&
\sphinxAtStartPar
Represents an intersection of sets as a \sphinxcode{\sphinxupquote{Set}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Interval}}(start, end{[}, left\_open, right\_open{]})
&
\sphinxAtStartPar
Represents a real interval as a Set.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Inverse}}(mat{[}, exp{]})
&
\sphinxAtStartPar
The multiplicative inverse of a matrix expression
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{InverseCosineTransform}}(*args)
&
\sphinxAtStartPar
Class representing unevaluated inverse cosine transforms.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{InverseFourierTransform}}(*args)
&
\sphinxAtStartPar
Class representing unevaluated inverse Fourier transforms.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{InverseHankelTransform}}(*args)
&
\sphinxAtStartPar
Class representing unevaluated inverse Hankel transforms.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{InverseLaplaceTransform}}(*args)
&
\sphinxAtStartPar
Class representing unevaluated inverse Laplace transforms.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{InverseMellinTransform}}(*args)
&
\sphinxAtStartPar
Class representing unevaluated inverse Mellin transforms.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{InverseSineTransform}}(*args)
&
\sphinxAtStartPar
Class representing unevaluated inverse sine transforms.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{KroneckerDelta}}(i, j{[}, delta\_range{]})
&
\sphinxAtStartPar
The discrete, or Kronecker, delta function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{KroneckerProduct}}(*args{[}, check{]})
&
\sphinxAtStartPar
The Kronecker product of two or more arguments.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Lambda}}(signature, expr)
&
\sphinxAtStartPar
Lambda(x, expr) represents a lambda function similar to Python\textquotesingle{}s \textquotesingle{}lambda x: expr\textquotesingle{}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{LambertW}}(x{[}, k{]})
&
\sphinxAtStartPar
The Lambert W function \$W(z)\$ is defined as the inverse function of \$w exp(w)\$ {\color{red}\bfseries{}{[}1{]}\_}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{LaplaceTransform}}(*args)
&
\sphinxAtStartPar
Class representing unevaluated Laplace transforms.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Le}}
&
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{LessThan}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{LessThan}}(lhs, rhs, **options)
&
\sphinxAtStartPar
Class representations of inequalities.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{LeviCivita}}(*args)
&
\sphinxAtStartPar
Represent the Levi\sphinxhyphen{}Civita symbol.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Li}}(z)
&
\sphinxAtStartPar
The offset logarithmic integral.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Limit}}(e, z, z0{[}, dir{]})
&
\sphinxAtStartPar
Represents an unevaluated limit.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Line}}(*args, **kwargs)
&
\sphinxAtStartPar
An infinite line in space.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Line2D}}(p1{[}, pt, slope{]})
&
\sphinxAtStartPar
An infinite line in space 2D.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Line3D}}(p1{[}, pt, direction\_ratio{]})
&
\sphinxAtStartPar
An infinite 3D line in space.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Lt}}
&
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{StrictLessThan}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{MatAdd}}(*args{[}, evaluate, check, \_sympify{]})
&
\sphinxAtStartPar
A Sum of Matrix Expressions
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{MatMul}}(*args{[}, evaluate, check, \_sympify{]})
&
\sphinxAtStartPar
A product of matrix expressions
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{MatPow}}(base, exp{[}, evaluate{]})
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Matrix}}
&
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{MutableDenseMatrix}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{MatrixBase}}()
&
\sphinxAtStartPar
Base class for matrix objects.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{MatrixExpr}}(*args, **kwargs)
&
\sphinxAtStartPar
Superclass for Matrix Expressions
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{MatrixPermute}}(mat, perm{[}, axis{]})
&
\sphinxAtStartPar
Symbolic representation for permuting matrix rows or columns.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{MatrixSlice}}(parent, rowslice, colslice)
&
\sphinxAtStartPar
A MatrixSlice of a Matrix Expression
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{MatrixSymbol}}(name, n, m)
&
\sphinxAtStartPar
Symbolic representation of a Matrix object
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Max}}(*args)
&
\sphinxAtStartPar
Return, if possible, the maximum value of the list.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{MellinTransform}}(*args)
&
\sphinxAtStartPar
Class representing unevaluated Mellin transforms.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Min}}(*args)
&
\sphinxAtStartPar
Return, if possible, the minimum value of the list.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Mod}}(p, q)
&
\sphinxAtStartPar
Represents a modulo operation on symbolic expressions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Monomial}}(monom{[}, gens{]})
&
\sphinxAtStartPar
Class representing a monomial, i.e. a product of powers.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Mul}}(*args{[}, evaluate, \_sympify{]})
&
\sphinxAtStartPar
Expression representing multiplication operation for algebraic field.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{MutableDenseMatrix}}(*args, **kwargs)
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{MutableDenseNDimArray}}({[}iterable, shape{]})
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{MutableMatrix}}
&
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{MutableDenseMatrix}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{MutableSparseMatrix}}(*args, **kwargs)
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{MutableSparseNDimArray}}({[}iterable, shape{]})
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{NDimArray}}(iterable{[}, shape{]})
&
\sphinxAtStartPar
N\sphinxhyphen{}dimensional array.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Nand}}(*args)
&
\sphinxAtStartPar
Logical NAND function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Ne}}
&
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{Unequality}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Nor}}(*args)
&
\sphinxAtStartPar
Logical NOR function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Not}}(arg)
&
\sphinxAtStartPar
Logical Not function (negation)
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Number}}(*obj)
&
\sphinxAtStartPar
Represents atomic numbers in SymPy.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{NumberSymbol}}()
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{O}}
&
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{Order}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{OmegaPower}}(a, b)
&
\sphinxAtStartPar
Represents ordinal exponential and multiplication terms one of the building blocks of the \sphinxcode{\sphinxupquote{Ordinal}} class.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{OneMatrix}}(m, n{[}, evaluate{]})
&
\sphinxAtStartPar
Matrix whose all entries are ones.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Options}}(gens, args{[}, flags, strict{]})
&
\sphinxAtStartPar
Options manager for polynomial manipulation module.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Or}}(*args)
&
\sphinxAtStartPar
Logical OR function
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Order}}(expr, *args, **kwargs)
&
\sphinxAtStartPar
Represents the limiting behavior of some function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Ordinal}}(*terms)
&
\sphinxAtStartPar
Represents ordinals in Cantor normal form.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Parabola}}({[}focus, directrix{]})
&
\sphinxAtStartPar
A parabolic GeometryEntity.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Permanent}}(mat)
&
\sphinxAtStartPar
Matrix Permanent
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{PermutationMatrix}}(perm)
&
\sphinxAtStartPar
A Permutation Matrix
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Piecewise}}(*\_args)
&
\sphinxAtStartPar
Represents a piecewise function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Plane}}(p1{[}, a, b{]})
&
\sphinxAtStartPar
A plane is a flat, two\sphinxhyphen{}dimensional surface.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Point}}(*args, **kwargs)
&
\sphinxAtStartPar
A point in a n\sphinxhyphen{}dimensional Euclidean space.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Point2D}}(*args{[}, \_nocheck{]})
&
\sphinxAtStartPar
A point in a 2\sphinxhyphen{}dimensional Euclidean space.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Point3D}}(*args{[}, \_nocheck{]})
&
\sphinxAtStartPar
A point in a 3\sphinxhyphen{}dimensional Euclidean space.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Poly}}(rep, *gens, **args)
&
\sphinxAtStartPar
Generic class for representing and operating on polynomial expressions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Polygon}}(*args{[}, n{]})
&
\sphinxAtStartPar
A two\sphinxhyphen{}dimensional polygon.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{PolynomialRing}}(domain\_or\_ring{[}, symbols, order{]})
&
\sphinxAtStartPar
A class for representing multivariate polynomial rings.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Pow}}(b, e{[}, evaluate{]})
&
\sphinxAtStartPar
Defines the expression x**y as "x raised to a power y"
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{PowerSet}}(arg{[}, evaluate{]})
&
\sphinxAtStartPar
A symbolic object representing a power set.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Predicate}}(*args, **kwargs)
&
\sphinxAtStartPar
Base class for mathematical predicates.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Product}}(function, *symbols, **assumptions)
&
\sphinxAtStartPar
Represents unevaluated products.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ProductSet}}(*sets, **assumptions)
&
\sphinxAtStartPar
Represents a Cartesian Product of Sets.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{PurePoly}}(rep, *gens, **args)
&
\sphinxAtStartPar
Class for representing pure polynomials.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{PythonFiniteField}}(mod{[}, symmetric{]})
&
\sphinxAtStartPar
Finite field based on Python\textquotesingle{}s integers.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{PythonIntegerRing}}()
&
\sphinxAtStartPar
Integer ring based on Python\textquotesingle{}s \sphinxcode{\sphinxupquote{int}} type.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{PythonRational}}
&
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{PythonMPQ}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{QQ\_gmpy}}
&
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{GMPYRationalField}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{QQ\_python}}
&
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{PythonRationalField}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Quaternion}}({[}a, b, c, d, real\_field, norm{]})
&
\sphinxAtStartPar
Provides basic quaternion operations.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Range}}(*args)
&
\sphinxAtStartPar
Represents a range of integers.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Rational}}(p{[}, q, gcd{]})
&
\sphinxAtStartPar
Represents rational numbers (p/q) of any size.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{RationalField}}()
&
\sphinxAtStartPar
Abstract base class for the domain \DUrole{xref}{\DUrole{std}{\DUrole{std-ref}{QQ}}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Ray}}(p1{[}, p2{]})
&
\sphinxAtStartPar
A Ray is a semi\sphinxhyphen{}line in the space with a source point and a direction.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Ray2D}}(p1{[}, pt, angle{]})
&
\sphinxAtStartPar
A Ray is a semi\sphinxhyphen{}line in the space with a source point and a direction.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Ray3D}}(p1{[}, pt, direction\_ratio{]})
&
\sphinxAtStartPar
A Ray is a semi\sphinxhyphen{}line in the space with a source point and a direction.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{RealField}}({[}prec, dps, tol{]})
&
\sphinxAtStartPar
Real numbers up to the given precision.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{RealNumber}}
&
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{Float}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{RegularPolygon}}(c, r, n{[}, rot{]})
&
\sphinxAtStartPar
A regular polygon.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Rel}}
&
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{Relational}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Rem}}(p, q)
&
\sphinxAtStartPar
Returns the remainder when \sphinxcode{\sphinxupquote{p}} is divided by \sphinxcode{\sphinxupquote{q}} where \sphinxcode{\sphinxupquote{p}} is finite and \sphinxcode{\sphinxupquote{q}} is not equal to zero.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{RisingFactorial}}(x, k)
&
\sphinxAtStartPar
Rising factorial (also called Pochhammer symbol {\color{red}\bfseries{}{[}1{]}\_}) is a double valued function arising in concrete mathematics, hypergeometric functions and series expansions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{RootOf}}(f, x{[}, index, radicals, expand{]})
&
\sphinxAtStartPar
Represents a root of a univariate polynomial.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{RootSum}}(expr{[}, func, x, auto, quadratic{]})
&
\sphinxAtStartPar
Represents a sum of all roots of a univariate polynomial.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Segment}}(p1, p2, **kwargs)
&
\sphinxAtStartPar
A line segment in space.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Segment2D}}(p1, p2, **kwargs)
&
\sphinxAtStartPar
A line segment in 2D space.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Segment3D}}(p1, p2, **kwargs)
&
\sphinxAtStartPar
A line segment in a 3D space.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.sensitivity.sensitivity_tools:src.sensitivity.sensitivity_tools.SensitivityMatrix}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{SensitivityMatrix}}}}}(sympification, duals, ...)
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SeqAdd}}(*args, **kwargs)
&
\sphinxAtStartPar
Represents term\sphinxhyphen{}wise addition of sequences.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SeqFormula}}(formula{[}, limits{]})
&
\sphinxAtStartPar
Represents sequence based on a formula.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SeqMul}}(*args, **kwargs)
&
\sphinxAtStartPar
Represents term\sphinxhyphen{}wise multiplication of sequences.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SeqPer}}(periodical{[}, limits{]})
&
\sphinxAtStartPar
Represents a periodic sequence.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Set}}(*args)
&
\sphinxAtStartPar
The base class for any kind of set.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Shi}}(z)
&
\sphinxAtStartPar
Sinh integral.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Si}}(z)
&
\sphinxAtStartPar
Sine integral.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Sieve}}()
&
\sphinxAtStartPar
An infinite list of prime numbers, implemented as a dynamically growing sieve of Eratosthenes.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SineTransform}}(*args)
&
\sphinxAtStartPar
Class representing unevaluated sine transforms.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SingularityFunction}}(variable, offset, exponent)
&
\sphinxAtStartPar
Singularity functions are a class of discontinuous functions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SparseMatrix}}
&
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{MutableSparseMatrix}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SparseNDimArray}}(*args, **kwargs)
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{StrPrinter}}({[}settings{]})
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{StrictGreaterThan}}(lhs, rhs, **options)
&
\sphinxAtStartPar
Class representations of inequalities.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{StrictLessThan}}(lhs, rhs, **options)
&
\sphinxAtStartPar
Class representations of inequalities.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Subs}}(expr, variables, point, **assumptions)
&
\sphinxAtStartPar
Represents unevaluated substitutions of an expression.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Sum}}(function, *symbols, **assumptions)
&
\sphinxAtStartPar
Represents unevaluated summation.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Symbol}}(name, **assumptions)
&
\sphinxAtStartPar
Assumptions:
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SymmetricDifference}}(a, b{[}, evaluate{]})
&
\sphinxAtStartPar
Represents the set of elements which are in either of the sets and not in their intersection.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{TableForm}}(data, **kwarg)
&
\sphinxAtStartPar
Create a nice table representation of data.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Trace}}(mat)
&
\sphinxAtStartPar
Matrix Trace
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Transpose}}(*args, **kwargs)
&
\sphinxAtStartPar
The transpose of a matrix expression.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Triangle}}(*args, **kwargs)
&
\sphinxAtStartPar
A polygon with three vertices and three sides.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Tuple}}(*args, **kwargs)
&
\sphinxAtStartPar
Wrapper around the builtin tuple object.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Unequality}}(lhs, rhs, **options)
&
\sphinxAtStartPar
An unequal relation between two objects.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{UnevaluatedExpr}}(arg, **kwargs)
&
\sphinxAtStartPar
Expression that is not evaluated unless released.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Union}}(*args, **kwargs)
&
\sphinxAtStartPar
Represents a union of sets as a \sphinxcode{\sphinxupquote{Set}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Wild}}(name{[}, exclude, properties{]})
&
\sphinxAtStartPar
A Wild symbol matches anything, or anything without whatever is explicitly excluded.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{WildFunction}}(*args)
&
\sphinxAtStartPar
A WildFunction function matches any function (with its arguments).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Xor}}(*args)
&
\sphinxAtStartPar
Logical XOR (exclusive OR) function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Ynm}}(n, m, theta, phi)
&
\sphinxAtStartPar
Spherical harmonics defined as
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ZZ\_gmpy}}
&
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{GMPYIntegerRing}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ZZ\_python}}
&
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{PythonIntegerRing}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ZeroMatrix}}(m, n)
&
\sphinxAtStartPar
The Matrix Zero 0 \sphinxhyphen{} additive identity
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Znm}}(n, m, theta, phi)
&
\sphinxAtStartPar
Real spherical harmonics defined as
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{acos}}(arg)
&
\sphinxAtStartPar
The inverse cosine function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{acosh}}(arg)
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{acosh(x)}} is the inverse hyperbolic cosine of \sphinxcode{\sphinxupquote{x}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{acot}}(arg)
&
\sphinxAtStartPar
The inverse cotangent function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{acoth}}(arg)
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{acoth(x)}} is the inverse hyperbolic cotangent of \sphinxcode{\sphinxupquote{x}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{acsc}}(arg)
&
\sphinxAtStartPar
The inverse cosecant function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{acsch}}(arg)
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{acsch(x)}} is the inverse hyperbolic cosecant of \sphinxcode{\sphinxupquote{x}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{adjoint}}(arg)
&
\sphinxAtStartPar
Conjugate transpose or Hermite conjugation.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{airyai}}(arg)
&
\sphinxAtStartPar
The Airy function \$operatorname\{Ai\}\$ of the first kind.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{airyaiprime}}(arg)
&
\sphinxAtStartPar
The derivative \$operatorname\{Ai\}\textasciicircum{}prime\$ of the Airy function of the first kind.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{airybi}}(arg)
&
\sphinxAtStartPar
The Airy function \$operatorname\{Bi\}\$ of the second kind.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{airybiprime}}(arg)
&
\sphinxAtStartPar
The derivative \$operatorname\{Bi\}\textasciicircum{}prime\$ of the Airy function of the first kind.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{andre}}(n)
&
\sphinxAtStartPar
Andre numbers / Andre function
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{appellf1}}(a, b1, b2, c, x, y)
&
\sphinxAtStartPar
This is the Appell hypergeometric function of two variables as:
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{arg}}(arg)
&
\sphinxAtStartPar
Returns the argument (in radians) of a complex number.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{asec}}(arg)
&
\sphinxAtStartPar
The inverse secant function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{asech}}(arg)
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{asech(x)}} is the inverse hyperbolic secant of \sphinxcode{\sphinxupquote{x}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{asin}}(arg)
&
\sphinxAtStartPar
The inverse sine function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{asinh}}(arg)
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{asinh(x)}} is the inverse hyperbolic sine of \sphinxcode{\sphinxupquote{x}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{assoc\_laguerre}}(n, alpha, x)
&
\sphinxAtStartPar
Returns the \$n\$th generalized Laguerre polynomial in \$x\$, \$L\_n(x)\$.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{assoc\_legendre}}(n, m, x)
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{assoc\_legendre(n, m, x)}} gives \$P\_n\textasciicircum{}m(x)\$, where \$n\$ and \$m\$ are the degree and order or an expression which is related to the nth order Legendre polynomial, \$P\_n(x)\$ in the following manner:
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{atan}}(arg)
&
\sphinxAtStartPar
The inverse tangent function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{atan2}}(y, x)
&
\sphinxAtStartPar
The function \sphinxcode{\sphinxupquote{atan2(y, x)}} computes \sphinxtitleref{operatorname\{atan\}(y/x)} taking two arguments \sphinxtitleref{y} and \sphinxtitleref{x}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{atanh}}(arg)
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{atanh(x)}} is the inverse hyperbolic tangent of \sphinxcode{\sphinxupquote{x}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{bell}}(n{[}, k\_sym, symbols{]})
&
\sphinxAtStartPar
Bell numbers / Bell polynomials
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{bernoulli}}(n{[}, x{]})
&
\sphinxAtStartPar
Bernoulli numbers / Bernoulli polynomials / Bernoulli function
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{besseli}}(nu, z)
&
\sphinxAtStartPar
Modified Bessel function of the first kind.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{besselj}}(nu, z)
&
\sphinxAtStartPar
Bessel function of the first kind.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{besselk}}(nu, z)
&
\sphinxAtStartPar
Modified Bessel function of the second kind.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{bessely}}(nu, z)
&
\sphinxAtStartPar
Bessel function of the second kind.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{beta}}(x{[}, y{]})
&
\sphinxAtStartPar
The beta integral is called the Eulerian integral of the first kind by Legendre:
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{betainc}}(*args)
&
\sphinxAtStartPar
The Generalized Incomplete Beta function is defined as
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{betainc\_regularized}}(*args)
&
\sphinxAtStartPar
The Generalized Regularized Incomplete Beta function is given by
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{binomial}}(n, k)
&
\sphinxAtStartPar
Implementation of the binomial coefficient.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{carmichael}}(*args)
&
\sphinxAtStartPar
Carmichael Numbers:
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{cartes}}
&
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{product}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{catalan}}(n)
&
\sphinxAtStartPar
Catalan numbers
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ceiling}}(arg)
&
\sphinxAtStartPar
Ceiling is a univariate function which returns the smallest integer value not less than its argument.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{chebyshevt}}(n, x)
&
\sphinxAtStartPar
Chebyshev polynomial of the first kind, \$T\_n(x)\$.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{chebyshevt\_root}}(n, k)
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{chebyshev\_root(n, k)}} returns the \$k\$th root (indexed from zero) of the \$n\$th Chebyshev polynomial of the first kind; that is, if \$0 le k \textless{} n\$, \sphinxcode{\sphinxupquote{chebyshevt(n, chebyshevt\_root(n, k)) == 0}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{chebyshevu}}(n, x)
&
\sphinxAtStartPar
Chebyshev polynomial of the second kind, \$U\_n(x)\$.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{chebyshevu\_root}}(n, k)
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{chebyshevu\_root(n, k)}} returns the \$k\$th root (indexed from zero) of the \$n\$th Chebyshev polynomial of the second kind; that is, if \$0 le k \textless{} n\$, \sphinxcode{\sphinxupquote{chebyshevu(n, chebyshevu\_root(n, k)) == 0}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{conjugate}}(arg)
&
\sphinxAtStartPar
Returns the \sphinxstyleemphasis{complex conjugate} {\color{red}\bfseries{}{[}1{]}\_} of an argument.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{cos}}(arg)
&
\sphinxAtStartPar
The cosine function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{cosh}}(arg)
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{cosh(x)}} is the hyperbolic cosine of \sphinxcode{\sphinxupquote{x}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{cot}}(arg)
&
\sphinxAtStartPar
The cotangent function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{coth}}(arg)
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{coth(x)}} is the hyperbolic cotangent of \sphinxcode{\sphinxupquote{x}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{csc}}(arg)
&
\sphinxAtStartPar
The cosecant function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{csch}}(arg)
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{csch(x)}} is the hyperbolic cosecant of \sphinxcode{\sphinxupquote{x}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{defaultdict}}
&
\sphinxAtStartPar
defaultdict(default\_factory=None, /, {[}...{]}) \sphinxhyphen{}\sphinxhyphen{}\textgreater{} dict with default factory
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{digamma}}(z)
&
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{digamma}} function is the first derivative of the \sphinxcode{\sphinxupquote{loggamma}} function
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{dirichlet\_eta}}(s{[}, a{]})
&
\sphinxAtStartPar
Dirichlet eta function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{divisor\_sigma}}(n{[}, k{]})
&
\sphinxAtStartPar
Calculate the divisor function \sphinxtitleref{sigma\_k(n)} for positive integer n
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{elliptic\_e}}(m{[}, z{]})
&
\sphinxAtStartPar
Called with two arguments \$z\$ and \$m\$, evaluates the incomplete elliptic integral of the second kind, defined by
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{elliptic\_f}}(z, m)
&
\sphinxAtStartPar
The Legendre incomplete elliptic integral of the first kind, defined by
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{elliptic\_k}}(m)
&
\sphinxAtStartPar
The complete elliptic integral of the first kind, defined by
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{elliptic\_pi}}(n, m{[}, z{]})
&
\sphinxAtStartPar
Called with three arguments \$n\$, \$z\$ and \$m\$, evaluates the Legendre incomplete elliptic integral of the third kind, defined by
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{erf}}(arg)
&
\sphinxAtStartPar
The Gauss error function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{erf2}}(x, y)
&
\sphinxAtStartPar
Two\sphinxhyphen{}argument error function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{erf2inv}}(x, y)
&
\sphinxAtStartPar
Two\sphinxhyphen{}argument Inverse error function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{erfc}}(arg)
&
\sphinxAtStartPar
Complementary Error Function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{erfcinv}}(z)
&
\sphinxAtStartPar
Inverse Complementary Error Function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{erfi}}(z)
&
\sphinxAtStartPar
Imaginary error function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{erfinv}}(z)
&
\sphinxAtStartPar
Inverse Error Function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{euler}}(n{[}, x{]})
&
\sphinxAtStartPar
Euler numbers / Euler polynomials / Euler function
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{exp}}(arg)
&
\sphinxAtStartPar
The exponential function, \(e^x\).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{exp\_polar}}(*args)
&
\sphinxAtStartPar
Represent a \sphinxstyleemphasis{polar number} (see g\sphinxhyphen{}function Sphinx documentation).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{expint}}(nu, z)
&
\sphinxAtStartPar
Generalized exponential integral.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{factorial}}(n)
&
\sphinxAtStartPar
Implementation of factorial function over nonnegative integers.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{factorial2}}(arg)
&
\sphinxAtStartPar
The double factorial \sphinxtitleref{n!!}, not to be confused with \sphinxtitleref{(n!)!}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ff}}
&
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{FallingFactorial}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{fibonacci}}(n{[}, sym{]})
&
\sphinxAtStartPar
Fibonacci numbers / Fibonacci polynomials
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{floor}}(arg)
&
\sphinxAtStartPar
Floor is a univariate function which returns the largest integer value not greater than its argument.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{frac}}(arg)
&
\sphinxAtStartPar
Represents the fractional part of x
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{fresnelc}}(z)
&
\sphinxAtStartPar
Fresnel integral C.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{fresnels}}(z)
&
\sphinxAtStartPar
Fresnel integral S.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{gamma}}(arg)
&
\sphinxAtStartPar
The gamma function
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{gegenbauer}}(n, a, x)
&
\sphinxAtStartPar
Gegenbauer polynomial \$C\_n\textasciicircum{}\{left(alpharight)\}(x)\$.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{genocchi}}(n{[}, x{]})
&
\sphinxAtStartPar
Genocchi numbers / Genocchi polynomials / Genocchi function
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hankel1}}(nu, z)
&
\sphinxAtStartPar
Hankel function of the first kind.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hankel2}}(nu, z)
&
\sphinxAtStartPar
Hankel function of the second kind.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{harmonic}}(n{[}, m{]})
&
\sphinxAtStartPar
Harmonic numbers
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hermite}}(n, x)
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hermite(n, x)}} gives the \$n\$th Hermite polynomial in \$x\$, \$H\_n(x)\$.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hermite\_prob}}(n, x)
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hermite\_prob(n, x)}} gives the \$n\$th probabilist\textquotesingle{}s Hermite polynomial in \$x\$, \$He\_n(x)\$.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hn1}}(nu, z)
&
\sphinxAtStartPar
Spherical Hankel function of the first kind.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hn2}}(nu, z)
&
\sphinxAtStartPar
Spherical Hankel function of the second kind.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hyper}}(ap, bq, z)
&
\sphinxAtStartPar
The generalized hypergeometric function is defined by a series where the ratios of successive terms are a rational function of the summation index.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{im}}(arg)
&
\sphinxAtStartPar
Returns imaginary part of expression.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{jacobi}}(n, a, b, x)
&
\sphinxAtStartPar
Jacobi polynomial \$P\_n\textasciicircum{}\{left(alpha, betaright)\}(x)\$.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{jn}}(nu, z)
&
\sphinxAtStartPar
Spherical Bessel function of the first kind.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{laguerre}}(n, x)
&
\sphinxAtStartPar
Returns the \$n\$th Laguerre polynomial in \$x\$, \$L\_n(x)\$.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{legendre}}(n, x)
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{legendre(n, x)}} gives the \$n\$th Legendre polynomial of \$x\$, \$P\_n(x)\$
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{lerchphi}}(*args)
&
\sphinxAtStartPar
Lerch transcendent (Lerch phi function).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{li}}(z)
&
\sphinxAtStartPar
The classical logarithmic integral.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ln}}
&
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{log}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{log}}(arg{[}, base{]})
&
\sphinxAtStartPar
The natural logarithm function \sphinxtitleref{ln(x)} or \sphinxtitleref{log(x)}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{loggamma}}(z)
&
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{loggamma}} function implements the logarithm of the gamma function (i.e., \$logGamma(x)\$).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{lowergamma}}(a, x)
&
\sphinxAtStartPar
The lower incomplete gamma function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{lucas}}(n)
&
\sphinxAtStartPar
Lucas numbers
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{marcumq}}(m, a, b)
&
\sphinxAtStartPar
The Marcum Q\sphinxhyphen{}function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mathieuc}}(a, q, z)
&
\sphinxAtStartPar
The Mathieu Cosine function \$C(a,q,z)\$.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mathieucprime}}(a, q, z)
&
\sphinxAtStartPar
The derivative \$C\textasciicircum{}\{prime\}(a,q,z)\$ of the Mathieu Cosine function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mathieus}}(a, q, z)
&
\sphinxAtStartPar
The Mathieu Sine function \$S(a,q,z)\$.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mathieusprime}}(a, q, z)
&
\sphinxAtStartPar
The derivative \$S\textasciicircum{}\{prime\}(a,q,z)\$ of the Mathieu Sine function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{meijerg}}(*args)
&
\sphinxAtStartPar
The Meijer G\sphinxhyphen{}function is defined by a Mellin\sphinxhyphen{}Barnes type integral that resembles an inverse Mellin transform.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mobius}}(n)
&
\sphinxAtStartPar
Mobius function maps natural number to \{\sphinxhyphen{}1, 0, 1\}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{motzkin}}(n)
&
\sphinxAtStartPar
The nth Motzkin number is the number
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{multigamma}}(x, p)
&
\sphinxAtStartPar
The multivariate gamma function is a generalization of the gamma function
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{partition}}(n)
&
\sphinxAtStartPar
Partition numbers
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{periodic\_argument}}(ar, period)
&
\sphinxAtStartPar
Represent the argument on a quotient of the Riemann surface of the logarithm.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{polar\_lift}}(arg)
&
\sphinxAtStartPar
Lift argument to the Riemann surface of the logarithm, using the standard branch.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{polygamma}}(n, z)
&
\sphinxAtStartPar
The function \sphinxcode{\sphinxupquote{polygamma(n, z)}} returns \sphinxcode{\sphinxupquote{log(gamma(z)).diff(n + 1)}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{polylog}}(s, z)
&
\sphinxAtStartPar
Polylogarithm function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{preorder\_traversal}}(node{[}, keys{]})
&
\sphinxAtStartPar
Do a pre\sphinxhyphen{}order traversal of a tree.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{primenu}}(n)
&
\sphinxAtStartPar
Calculate the number of distinct prime factors for a positive integer n.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{primeomega}}(n)
&
\sphinxAtStartPar
Calculate the number of prime factors counting multiplicities for a positive integer n.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{primepi}}(n)
&
\sphinxAtStartPar
Represents the prime counting function pi(n) = the number of prime numbers less than or equal to n.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{principal\_branch}}(x, period)
&
\sphinxAtStartPar
Represent a polar number reduced to its principal branch on a quotient of the Riemann surface of the logarithm.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{re}}(arg)
&
\sphinxAtStartPar
Returns real part of expression.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{reduced\_totient}}(n)
&
\sphinxAtStartPar
Calculate the Carmichael reduced totient function lambda(n)
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{rf}}
&
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{RisingFactorial}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{riemann\_xi}}(s)
&
\sphinxAtStartPar
Riemann Xi function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sec}}(arg)
&
\sphinxAtStartPar
The secant function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sech}}(arg)
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sech(x)}} is the hyperbolic secant of \sphinxcode{\sphinxupquote{x}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sign}}(arg)
&
\sphinxAtStartPar
Returns the complex sign of an expression:
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sin}}(arg)
&
\sphinxAtStartPar
The sine function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sinc}}(arg)
&
\sphinxAtStartPar
Represents an unnormalized sinc function:
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sinh}}(arg)
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sinh(x)}} is the hyperbolic sine of \sphinxcode{\sphinxupquote{x}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{stieltjes}}(n{[}, a{]})
&
\sphinxAtStartPar
Represents Stieltjes constants, \$gamma\_\{k\}\$ that occur in Laurent Series expansion of the Riemann zeta function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{subfactorial}}(arg)
&
\sphinxAtStartPar
The subfactorial counts the derangements of \$n\$ items and is defined for non\sphinxhyphen{}negative integers as:
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{tan}}(arg)
&
\sphinxAtStartPar
The tangent function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{tanh}}(arg)
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{tanh(x)}} is the hyperbolic tangent of \sphinxcode{\sphinxupquote{x}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{totient}}(n)
&
\sphinxAtStartPar
Calculate the Euler totient function phi(n)
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{transpose}}(arg)
&
\sphinxAtStartPar
Linear map transposition.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{tribonacci}}(n{[}, sym{]})
&
\sphinxAtStartPar
Tribonacci numbers / Tribonacci polynomials
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{trigamma}}(z)
&
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{trigamma}} function is the second derivative of the \sphinxcode{\sphinxupquote{loggamma}} function
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{uppergamma}}(a, z)
&
\sphinxAtStartPar
The upper incomplete gamma function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{vectorize}}(*mdargs)
&
\sphinxAtStartPar
Generalizes a function taking scalars to accept multidimensional arguments.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{yn}}(nu, z)
&
\sphinxAtStartPar
Spherical Bessel function of the second kind.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{zeta}}(s{[}, a{]})
&
\sphinxAtStartPar
Hurwitz zeta function (or Riemann zeta function).
\\
\sphinxbottomrule
\end{longtable}
\sphinxtableafterendhook
\sphinxatlongtableend
\end{savenotes}
\subsubsection*{Exceptions}


\begin{savenotes}
\sphinxatlongtablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\makeatletter
  \LTleft \@totalleftmargin plus1fill
  \LTright\dimexpr\columnwidth-\@totalleftmargin-\linewidth\relax plus1fill
\makeatother
\begin{longtable}{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\endfirsthead

\multicolumn{2}{c}{\sphinxnorowcolor
    \makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}%
}\\
\sphinxtoprule
\endhead

\sphinxbottomrule
\multicolumn{2}{r}{\sphinxnorowcolor
    \makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}%
}\\
\endfoot

\endlastfoot
\sphinxtableatstartofbodyhook

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{BasePolynomialError}}
&
\sphinxAtStartPar
Base class for polynomial related exceptions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{CoercionFailed}}
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ComputationFailed}}(func, nargs, exc)
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{DomainError}}
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{EvaluationFailed}}
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ExactQuotientFailed}}(f, g{[}, dom{]})
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ExtraneousFactors}}
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{FlagError}}
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{GeneratorsError}}
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{GeneratorsNeeded}}
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{GeometryError}}
&
\sphinxAtStartPar
An exception raised by classes in the geometry module.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{HeuristicGCDFailed}}
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{HomomorphismFailed}}
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{IsomorphismFailed}}
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{MultivariatePolynomialError}}
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{NonSquareMatrixError}}
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{NotAlgebraic}}
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{NotInvertible}}
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{NotReversible}}
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{OperationNotSupported}}(poly, func)
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{OptionError}}
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{PoleError}}
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{PolificationFailed}}(opt, origs, exprs{[}, seq{]})
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{PolynomialDivisionFailed}}(f, g, domain)
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{PolynomialError}}
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{PrecisionExhausted}}
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{RefinementFailed}}
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ShapeError}}
&
\sphinxAtStartPar
Wrong matrix shape
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SympifyError}}(expr{[}, base\_exc{]})
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{UnificationFailed}}
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{UnivariatePolynomialError}}
&
\sphinxAtStartPar

\\
\sphinxbottomrule
\end{longtable}
\sphinxtableafterendhook
\sphinxatlongtableend
\end{savenotes}
\index{AutoSympy (class in src.sensitivity.sensitivity\_tools)@\spxentry{AutoSympy}\spxextra{class in src.sensitivity.sensitivity\_tools}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.sensitivity.sensitivity_tools:src.sensitivity.sensitivity_tools.AutoSympy}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{\DUrole{k}{class}\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{src.sensitivity.sensitivity\_tools.}}\sphinxbfcode{\sphinxupquote{AutoSympy}}}
{\sphinxparam{\DUrole{n}{model}}}
{}
\pysigstopsignatures\index{check\_complimentarity\_all() (src.sensitivity.sensitivity\_tools.AutoSympy method)@\spxentry{check\_complimentarity\_all()}\spxextra{src.sensitivity.sensitivity\_tools.AutoSympy method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.sensitivity.sensitivity_tools:src.sensitivity.sensitivity_tools.AutoSympy.check_complimentarity_all}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{check\_complimentarity\_all}}}
{}
{}
\pysigstopsignatures
\sphinxAtStartPar
quick check of complementarity conditions

\end{fulllineitems}

\index{generate\_duals() (src.sensitivity.sensitivity\_tools.AutoSympy method)@\spxentry{generate\_duals()}\spxextra{src.sensitivity.sensitivity\_tools.AutoSympy method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.sensitivity.sensitivity_tools:src.sensitivity.sensitivity_tools.AutoSympy.generate_duals}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{generate\_duals}}}
{\sphinxparam{\DUrole{n}{constraints}}\sphinxparamcomma \sphinxparam{\DUrole{n}{duals}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
cycles through constraints, extracts duals, categorizes by complementary slackness conditions
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{constraints}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} iterator of pyomo constraints

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{duals}} (\sphinxstyleliteralemphasis{\sphinxupquote{obj}}) \textendash{} duals object from pyomo model

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
dictionary of duals sorts by type

\sphinxlineitem{Return type}
\sphinxAtStartPar
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_constraints() (src.sensitivity.sensitivity\_tools.AutoSympy method)@\spxentry{get\_constraints()}\spxextra{src.sensitivity.sensitivity\_tools.AutoSympy method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.sensitivity.sensitivity_tools:src.sensitivity.sensitivity_tools.AutoSympy.get_constraints}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{get\_constraints}}}
{}
{}
\pysigstopsignatures
\sphinxAtStartPar
extract constraint expressions from self.model and convert to Sympy expressions
in terms of the extracted Sympy Symbols for variables and parameters
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{equality\_constraints} (\sphinxstyleemphasis{dict}) \textendash{} dictionary of names and indices of equality constraints:Sympy expression for lhs of constraint

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{inequality\_constraints} (\sphinxstyleemphasis{dict}) \textendash{} dictionary of names and indices of inequality constraints:Sympy expression for lhs of constraint

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{get\_objective() (src.sensitivity.sensitivity\_tools.AutoSympy method)@\spxentry{get\_objective()}\spxextra{src.sensitivity.sensitivity\_tools.AutoSympy method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.sensitivity.sensitivity_tools:src.sensitivity.sensitivity_tools.AutoSympy.get_objective}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{get\_objective}}}
{}
{}
\pysigstopsignatures
\sphinxAtStartPar
extract objective expression from self.model
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
objective expression

\sphinxlineitem{Return type}
\sphinxAtStartPar
expr

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_parameters() (src.sensitivity.sensitivity\_tools.AutoSympy method)@\spxentry{get\_parameters()}\spxextra{src.sensitivity.sensitivity\_tools.AutoSympy method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.sensitivity.sensitivity_tools:src.sensitivity.sensitivity_tools.AutoSympy.get_parameters}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{get\_parameters}}}
{}
{}
\pysigstopsignatures
\sphinxAtStartPar
extracts parameters from self.model and converts to Sympy Symbol or IndexedBase + index objects
depending on whether they are indexed components or not.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{parameters} (\sphinxstyleemphasis{dict}) \textendash{} dictionary of parameter names:IndexedBase objects with that name

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{parameters\_values} (\sphinxstyleemphasis{dict}) \textendash{} dictionary of Sympy objects:their numeric value

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{parameter\_index\_sets} (\sphinxstyleemphasis{dict}) \textendash{} dictionary of parameter name:list of indices for the name

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{get\_sensitivity\_matrix() (src.sensitivity.sensitivity\_tools.AutoSympy method)@\spxentry{get\_sensitivity\_matrix()}\spxextra{src.sensitivity.sensitivity\_tools.AutoSympy method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.sensitivity.sensitivity_tools:src.sensitivity.sensitivity_tools.AutoSympy.get_sensitivity_matrix}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{get\_sensitivity\_matrix}}}
{\sphinxparam{\DUrole{n}{parameters\_of\_interest}\DUrole{o}{=}\DUrole{default_value}{None}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
generates a SensitivityMatrix object based on the sympy representation, keeping parameters in parameters\_of\_interest
and substituting numeric values for the rest in all expressions.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{parameters\_of\_interest}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} list of parameters to keep symbolic. These are the parameters to evaluate sensitivity for. Defaults to None.

\sphinxlineitem{Returns}
\sphinxAtStartPar
SensitivityMatrix object for the model, with parameters\_of\_interest considered.

\sphinxlineitem{Return type}
\sphinxAtStartPar
obj

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_sets() (src.sensitivity.sensitivity\_tools.AutoSympy method)@\spxentry{get\_sets()}\spxextra{src.sensitivity.sensitivity\_tools.AutoSympy method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.sensitivity.sensitivity_tools:src.sensitivity.sensitivity_tools.AutoSympy.get_sets}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{get\_sets}}}
{}
{}
\pysigstopsignatures
\sphinxAtStartPar
extracts sets from self.model and converts them to Sympy Idx objects
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{sets} (\sphinxstyleemphasis{dict}) \textendash{} dictionary of set names:Idx objects

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{set\_values} (\sphinxstyleemphasis{dict}) \textendash{} dictionary of Idx objects:corresponding element of the Pyomo set

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{get\_variables() (src.sensitivity.sensitivity\_tools.AutoSympy method)@\spxentry{get\_variables()}\spxextra{src.sensitivity.sensitivity\_tools.AutoSympy method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.sensitivity.sensitivity_tools:src.sensitivity.sensitivity_tools.AutoSympy.get_variables}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{get\_variables}}}
{}
{}
\pysigstopsignatures
\sphinxAtStartPar
extracts variables from self.model and converts them to Sympy Symbol or IndexedBase + index objects
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{variables} (\sphinxstyleemphasis{dict}) \textendash{} dictionary of variable names:corresponding Sympy object (Symbol or IndexedBase)

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{variable\_values} (\sphinxstyleemphasis{dict}) \textendash{} dictionary of Sympy objects (Symbol or IndexedBase):numeric value

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{substitute\_values() (src.sensitivity.sensitivity\_tools.AutoSympy method)@\spxentry{substitute\_values()}\spxextra{src.sensitivity.sensitivity\_tools.AutoSympy method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.sensitivity.sensitivity_tools:src.sensitivity.sensitivity_tools.AutoSympy.substitute_values}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{substitute\_values}}}
{\sphinxparam{\DUrole{n}{substitution\_dict}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
subsitutes numeric values for sympy symbols according to substitution\_dict
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{substitution\_dict}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} dictionary of symbols:values to substitute

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{CoordMap (class in src.sensitivity.sensitivity\_tools)@\spxentry{CoordMap}\spxextra{class in src.sensitivity.sensitivity\_tools}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.sensitivity.sensitivity_tools:src.sensitivity.sensitivity_tools.CoordMap}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{\DUrole{k}{class}\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{src.sensitivity.sensitivity\_tools.}}\sphinxbfcode{\sphinxupquote{CoordMap}}}
{\sphinxparam{\DUrole{n}{var\_vector}}\sphinxparamcomma \sphinxparam{\DUrole{n}{eq\_duals}}\sphinxparamcomma \sphinxparam{\DUrole{n}{ineq\_duals}}\sphinxparamcomma \sphinxparam{\DUrole{n}{params}}}
{}
\pysigstopsignatures
\end{fulllineitems}

\index{DifferentialMapping (class in src.sensitivity.sensitivity\_tools)@\spxentry{DifferentialMapping}\spxextra{class in src.sensitivity.sensitivity\_tools}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.sensitivity.sensitivity_tools:src.sensitivity.sensitivity_tools.DifferentialMapping}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{\DUrole{k}{class}\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{src.sensitivity.sensitivity\_tools.}}\sphinxbfcode{\sphinxupquote{DifferentialMapping}}}
{\sphinxparam{\DUrole{n}{US}}\sphinxparamcomma \sphinxparam{\DUrole{n}{coord2item}}\sphinxparamcomma \sphinxparam{\DUrole{n}{item2coord}}\sphinxparamcomma \sphinxparam{\DUrole{n}{param2coord}}\sphinxparamcomma \sphinxparam{\DUrole{n}{coord2param}}}
{}
\pysigstopsignatures\index{extrapolate() (src.sensitivity.sensitivity\_tools.DifferentialMapping method)@\spxentry{extrapolate()}\spxextra{src.sensitivity.sensitivity\_tools.DifferentialMapping method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.sensitivity.sensitivity_tools:src.sensitivity.sensitivity_tools.DifferentialMapping.extrapolate}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{extrapolate}}}
{\sphinxparam{\DUrole{n}{current\_values}}\sphinxparamcomma \sphinxparam{\DUrole{n}{param\_delta}}}
{}
\pysigstopsignatures\begin{description}
\sphinxlineitem{given the current value of all varying quantities (variables, duals, objective) as a vector,}
\sphinxAtStartPar
and a delta of parameter values as a vector, calculates the effect of perturbing the parameters
by the parameter delta.

\end{description}
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{current\_values}} (\sphinxstyleliteralemphasis{\sphinxupquote{Matrix}}) \textendash{} vector of {[}variables values, dual values, objective value{]}

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{param\_delta}} (\sphinxstyleliteralemphasis{\sphinxupquote{Matrix}}) \textendash{} vector of {[}parameter values{]}

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{item\_delta} (\sphinxstyleemphasis{obj}) \textendash{} column Matrix of items

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{item\_delta\_map} (\sphinxstyleemphasis{dict}) \textendash{} map between items and their changes

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{item\_new\_value} (\sphinxstyleemphasis{Matrix}) \textendash{} column Matrix of new values after change

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{item\_new\_value\_map} (\sphinxstyleemphasis{dict}) \textendash{} map between items and their new values

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{sensitivity() (src.sensitivity.sensitivity\_tools.DifferentialMapping method)@\spxentry{sensitivity()}\spxextra{src.sensitivity.sensitivity\_tools.DifferentialMapping method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.sensitivity.sensitivity_tools:src.sensitivity.sensitivity_tools.DifferentialMapping.sensitivity}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{sensitivity}}}
{\sphinxparam{\DUrole{n}{item}}\sphinxparamcomma \sphinxparam{\DUrole{n}{parameter}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
picks out the sensitivity of item with respect to parameters
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{item}} (\sphinxstyleliteralemphasis{\sphinxupquote{symbol}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} however the particular item was stored, usually symbol

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{parameter}} (\sphinxstyleliteralemphasis{\sphinxupquote{symbol}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} however the particular parameter was stored, usually symbol

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
the sensitivity of item with respect to parameter.

\sphinxlineitem{Return type}
\sphinxAtStartPar
float

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{SensitivityMatrix (class in src.sensitivity.sensitivity\_tools)@\spxentry{SensitivityMatrix}\spxextra{class in src.sensitivity.sensitivity\_tools}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.sensitivity.sensitivity_tools:src.sensitivity.sensitivity_tools.SensitivityMatrix}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{\DUrole{k}{class}\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{src.sensitivity.sensitivity\_tools.}}\sphinxbfcode{\sphinxupquote{SensitivityMatrix}}}
{\sphinxparam{\DUrole{n}{sympification}}\sphinxparamcomma \sphinxparam{\DUrole{n}{duals}}\sphinxparamcomma \sphinxparam{\DUrole{n}{parameters\_of\_interest}}}
{}
\pysigstopsignatures\index{create\_substitution\_dictionary() (src.sensitivity.sensitivity\_tools.SensitivityMatrix method)@\spxentry{create\_substitution\_dictionary()}\spxextra{src.sensitivity.sensitivity\_tools.SensitivityMatrix method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.sensitivity.sensitivity_tools:src.sensitivity.sensitivity_tools.SensitivityMatrix.create_substitution_dictionary}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{create\_substitution\_dictionary}}}
{\sphinxparam{\DUrole{n}{values\_of\_interest}\DUrole{o}{=}\DUrole{default_value}{None}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
creates a single dictionary with all values to be substituted into the sensitivity matrix.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{values\_of\_interest}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Subset of all possible substitutions you’d like to perform. Defaults to None.

\sphinxlineitem{Returns}
\sphinxAtStartPar
dictionary of substitution values

\sphinxlineitem{Return type}
\sphinxAtStartPar
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{generate\_matrix() (src.sensitivity.sensitivity\_tools.SensitivityMatrix method)@\spxentry{generate\_matrix()}\spxextra{src.sensitivity.sensitivity\_tools.SensitivityMatrix method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.sensitivity.sensitivity_tools:src.sensitivity.sensitivity_tools.SensitivityMatrix.generate_matrix}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{generate\_matrix}}}
{}
{}
\pysigstopsignatures
\sphinxAtStartPar
generates the submatrix components of the sensitivity matrix that will be used to express sensitivities and extrapolate from a given solution point
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
dictionary of submatrix name:Matrix object.

\sphinxlineitem{Return type}
\sphinxAtStartPar
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_sensitivities() (src.sensitivity.sensitivity\_tools.SensitivityMatrix method)@\spxentry{get\_sensitivities()}\spxextra{src.sensitivity.sensitivity\_tools.SensitivityMatrix method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.sensitivity.sensitivity_tools:src.sensitivity.sensitivity_tools.SensitivityMatrix.get_sensitivities}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{get\_sensitivities}}}
{}
{}
\pysigstopsignatures
\sphinxAtStartPar
creates a set of dictionaries to keep track of the relationships between symbol names, symbol objects,
and their position in the respective vectors of parameters and variable quantities. Calculates U\textasciicircum{}\sphinxhyphen{}1*S and Creates a DifferentialMapping object.
Sensitivities of quantities with respect to parameters will be corresponding entries in the matrix generated,
which can be queried directly in the DifferentialMapping object
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
an DifferentialMapping object that stores the sensitivity matrix and dictionaries matching coordinates to symbols

\sphinxlineitem{Return type}
\sphinxAtStartPar
obj

\end{description}\end{quote}

\end{fulllineitems}

\index{matrix\_assembly() (src.sensitivity.sensitivity\_tools.SensitivityMatrix method)@\spxentry{matrix\_assembly()}\spxextra{src.sensitivity.sensitivity\_tools.SensitivityMatrix method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.sensitivity.sensitivity_tools:src.sensitivity.sensitivity_tools.SensitivityMatrix.matrix_assembly}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{matrix\_assembly}}}
{\sphinxparam{\DUrole{n}{components}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
assemble the submatrix components into U,S
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{components}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} dictionary of submatrix names:Matrix objects

\sphinxlineitem{Returns}
\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{obj} \textendash{} Matrix object U

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{obj} \textendash{} Matrix object S

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{resolve\_kronecker() (src.sensitivity.sensitivity\_tools.SensitivityMatrix method)@\spxentry{resolve\_kronecker()}\spxextra{src.sensitivity.sensitivity\_tools.SensitivityMatrix method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.sensitivity.sensitivity_tools:src.sensitivity.sensitivity_tools.SensitivityMatrix.resolve_kronecker}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{resolve\_kronecker}}}
{\sphinxparam{\DUrole{n}{expr}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
evaluates KroneckerDelta terms
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{obj}} \textendash{} sympy expression

\sphinxlineitem{Returns}
\sphinxAtStartPar
sympy expr with KroneckerDelta terms evaluated to 0 or 1

\sphinxlineitem{Return type}
\sphinxAtStartPar
obj

\end{description}\end{quote}

\end{fulllineitems}

\index{substitute\_values() (src.sensitivity.sensitivity\_tools.SensitivityMatrix method)@\spxentry{substitute\_values()}\spxextra{src.sensitivity.sensitivity\_tools.SensitivityMatrix method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.sensitivity.sensitivity_tools:src.sensitivity.sensitivity_tools.SensitivityMatrix.substitute_values}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{substitute\_values}}}
{\sphinxparam{\DUrole{n}{values\_dict}\DUrole{o}{=}\DUrole{default_value}{None}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
substitute values into self.U and self.S according to a given substitution dictionary, or a substition dictionary for all values
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{values\_dict}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} dictionary of symbols:values

\sphinxlineitem{Returns}
\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{obj} \textendash{} the stored Matrix object U after substituting numeric values

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{obj} \textendash{} the stored matrix S after substituting numeric values

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}


\sphinxstepscope


\paragraph{src.sensitivity.speed\_test}
\label{\detokenize{src.sensitivity.speed_test:module-src.sensitivity.speed_test}}\label{\detokenize{src.sensitivity.speed_test:src-sensitivity-speed-test}}\label{\detokenize{src.sensitivity.speed_test::doc}}\index{module@\spxentry{module}!src.sensitivity.speed\_test@\spxentry{src.sensitivity.speed\_test}}\index{src.sensitivity.speed\_test@\spxentry{src.sensitivity.speed\_test}!module@\spxentry{module}}
\sphinxAtStartPar
Speed Test
This is a script with some functions to run speed and accuracy tests on test models constructed with babymodel.

\sphinxAtStartPar
It can be run directly. Parameter values are at the top of the file and any desired value can be entered into the declarations.
The script will then run a sequence of functions to time the build, sympification, and sensitivity calculation for the TestBabyModel
constructed with those input values.
\subsubsection*{Functions}


\begin{savenotes}
\sphinxatlongtablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\makeatletter
  \LTleft \@totalleftmargin plus1fill
  \LTright\dimexpr\columnwidth-\@totalleftmargin-\linewidth\relax plus1fill
\makeatother
\begin{longtable}{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\endfirsthead

\multicolumn{2}{c}{\sphinxnorowcolor
    \makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}%
}\\
\sphinxtoprule
\endhead

\sphinxbottomrule
\multicolumn{2}{r}{\sphinxnorowcolor
    \makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}%
}\\
\endfoot

\endlastfoot
\sphinxtableatstartofbodyhook

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{E1}}(z)
&
\sphinxAtStartPar
Classical case of the generalized exponential integral.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Eijk}}(*args, **kwargs)
&
\sphinxAtStartPar
Represent the Levi\sphinxhyphen{}Civita symbol.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{GramSchmidt}}(vlist{[}, orthonormal{]})
&
\sphinxAtStartPar
Apply the Gram\sphinxhyphen{}Schmidt process to a set of vectors.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{LC}}(f, *gens, **args)
&
\sphinxAtStartPar
Return the leading coefficient of \sphinxcode{\sphinxupquote{f}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{LM}}(f, *gens, **args)
&
\sphinxAtStartPar
Return the leading monomial of \sphinxcode{\sphinxupquote{f}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{LT}}(f, *gens, **args)
&
\sphinxAtStartPar
Return the leading term of \sphinxcode{\sphinxupquote{f}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{N}}(x{[}, n{]})
&
\sphinxAtStartPar
Calls x.evalf(n, **options).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{POSform}}(variables, minterms{[}, dontcares{]})
&
\sphinxAtStartPar
The POSform function uses simplified\_pairs and a redundant\sphinxhyphen{}group eliminating algorithm to convert the list of all input combinations that generate \textquotesingle{}1\textquotesingle{} (the minterms) into the smallest product\sphinxhyphen{}of\sphinxhyphen{}sums form.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SOPform}}(variables, minterms{[}, dontcares{]})
&
\sphinxAtStartPar
The SOPform function uses simplified\_pairs and a redundant group\sphinxhyphen{} eliminating algorithm to convert the list of all input combos that generate \textquotesingle{}1\textquotesingle{} (the minterms) into the smallest sum\sphinxhyphen{}of\sphinxhyphen{}products form.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Ynm\_c}}(n, m, theta, phi)
&
\sphinxAtStartPar
Conjugate spherical harmonics defined as
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{abundance}}(n)
&
\sphinxAtStartPar
Returns the difference between the sum of the positive proper divisors of a number and the number.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{apart}}(f{[}, x, full{]})
&
\sphinxAtStartPar
Compute partial fraction decomposition of a rational function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{apart\_list}}(f{[}, x, dummies{]})
&
\sphinxAtStartPar
Compute partial fraction decomposition of a rational function and return the result in structured form.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{apply\_finite\_diff}}(order, x\_list, y\_list{[}, x0{]})
&
\sphinxAtStartPar
Calculates the finite difference approximation of the derivative of requested order at \sphinxcode{\sphinxupquote{x0}} from points provided in \sphinxcode{\sphinxupquote{x\_list}} and \sphinxcode{\sphinxupquote{y\_list}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{approximants}}(l{[}, X, simplify{]})
&
\sphinxAtStartPar
Return a generator for consecutive Pade approximants for a series.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{are\_similar}}(e1, e2)
&
\sphinxAtStartPar
Are two geometrical entities similar.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{arity}}(cls)
&
\sphinxAtStartPar
Return the arity of the function if it is known, else None.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ask}}(proposition{[}, assumptions, context{]})
&
\sphinxAtStartPar
Function to evaluate the proposition with assumptions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{assemble\_partfrac\_list}}(partial\_list)
&
\sphinxAtStartPar
Reassemble a full partial fraction decomposition from a structured result obtained by the function \sphinxcode{\sphinxupquote{apart\_list}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{assuming}}(*assumptions)
&
\sphinxAtStartPar
Context manager for assumptions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{banded}}(*args, **kwargs)
&
\sphinxAtStartPar
Returns a SparseMatrix from the given dictionary describing the diagonals of the matrix.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{besselsimp}}(expr)
&
\sphinxAtStartPar
Simplify bessel\sphinxhyphen{}type functions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{binomial\_coefficients}}(n)
&
\sphinxAtStartPar
Return a dictionary containing pairs \({(k1,k2) : C_kn}\) where \(C_kn\) are binomial coefficients and \(n=k1+k2\).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{binomial\_coefficients\_list}}(n)
&
\sphinxAtStartPar
Return a list of binomial coefficients as rows of the Pascal\textquotesingle{}s triangle.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{block\_collapse}}(expr)
&
\sphinxAtStartPar
Evaluates a block matrix expression
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{blockcut}}(expr, rowsizes, colsizes)
&
\sphinxAtStartPar
Cut a matrix expression into Blocks
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{bool\_map}}(bool1, bool2)
&
\sphinxAtStartPar
Return the simplified version of \sphinxstyleemphasis{bool1}, and the mapping of variables that makes the two expressions \sphinxstyleemphasis{bool1} and \sphinxstyleemphasis{bool2} represent the same logical behaviour for some correspondence between the variables of each.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{bottom\_up}}(rv, F{[}, atoms, nonbasic{]})
&
\sphinxAtStartPar
Apply \sphinxcode{\sphinxupquote{F}} to all expressions in an expression tree from the bottom up.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{bspline\_basis}}(d, knots, n, x)
&
\sphinxAtStartPar
The \$n\$\sphinxhyphen{}th B\sphinxhyphen{}spline at \$x\$ of degree \$d\$ with knots.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{bspline\_basis\_set}}(d, knots, x)
&
\sphinxAtStartPar
Return the \sphinxcode{\sphinxupquote{len(knots)\sphinxhyphen{}d\sphinxhyphen{}1}} B\sphinxhyphen{}splines at \sphinxstyleemphasis{x} of degree \sphinxstyleemphasis{d} with \sphinxstyleemphasis{knots}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{cacheit}}(func)
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{cancel}}(f, *gens{[}, \_signsimp{]})
&
\sphinxAtStartPar
Cancel common factors in a rational function \sphinxcode{\sphinxupquote{f}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{capture}}(func)
&
\sphinxAtStartPar
Return the printed output of func().
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{casoratian}}(seqs, n{[}, zero{]})
&
\sphinxAtStartPar
Given linear difference operator L of order \textquotesingle{}k\textquotesingle{} and homogeneous equation Ly = 0 we want to compute kernel of L, which is a set of \textquotesingle{}k\textquotesingle{} sequences: a(n), b(n), .
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{cbrt}}(arg{[}, evaluate{]})
&
\sphinxAtStartPar
Returns the principal cube root.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ccode}}(expr{[}, assign\_to, standard{]})
&
\sphinxAtStartPar
Converts an expr to a string of c code
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{centroid}}(*args)
&
\sphinxAtStartPar
Find the centroid (center of mass) of the collection containing only Points, Segments or Polygons.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{chebyshevt\_poly}}(n{[}, x, polys{]})
&
\sphinxAtStartPar
Generates the Chebyshev polynomial of the first kind \sphinxtitleref{T\_n(x)}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{chebyshevu\_poly}}(n{[}, x, polys{]})
&
\sphinxAtStartPar
Generates the Chebyshev polynomial of the second kind \sphinxtitleref{U\_n(x)}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{check\_assumptions}}(expr{[}, against{]})
&
\sphinxAtStartPar
Checks whether assumptions of \sphinxcode{\sphinxupquote{expr}} match the T/F assumptions given (or possessed by \sphinxcode{\sphinxupquote{against}}).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{checkodesol}}(ode, sol{[}, func, order, ...{]})
&
\sphinxAtStartPar
Substitutes \sphinxcode{\sphinxupquote{sol}} into \sphinxcode{\sphinxupquote{ode}} and checks that the result is \sphinxcode{\sphinxupquote{0}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{checkpdesol}}(pde, sol{[}, func, solve\_for\_func{]})
&
\sphinxAtStartPar
Checks if the given solution satisfies the partial differential equation.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{checksol}}(f, symbol{[}, sol{]})
&
\sphinxAtStartPar
Checks whether sol is a solution of equation f == 0.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{classify\_ode}}(eq{[}, func, dict, ics, prep, ...{]})
&
\sphinxAtStartPar
Returns a tuple of possible \sphinxcode{\sphinxupquote{dsolve()}} classifications for an ODE.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{classify\_pde}}(eq{[}, func, dict, prep{]})
&
\sphinxAtStartPar
Returns a tuple of possible pdsolve() classifications for a PDE.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{closest\_points}}(*args)
&
\sphinxAtStartPar
Return the subset of points from a set of points that were the closest to each other in the 2D plane.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{cofactors}}(f, g, *gens, **args)
&
\sphinxAtStartPar
Compute GCD and cofactors of \sphinxcode{\sphinxupquote{f}} and \sphinxcode{\sphinxupquote{g}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{collect}}(expr, syms{[}, func, evaluate, exact, ...{]})
&
\sphinxAtStartPar
Collect additive terms of an expression.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{collect\_const}}(expr, *vars{[}, Numbers{]})
&
\sphinxAtStartPar
A non\sphinxhyphen{}greedy collection of terms with similar number coefficients in an Add expr.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{combsimp}}(expr)
&
\sphinxAtStartPar
Simplify combinatorial expressions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{comp}}(z1, z2{[}, tol{]})
&
\sphinxAtStartPar
Return a bool indicating whether the error between z1 and z2 is \$le\$ \sphinxcode{\sphinxupquote{tol}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{compose}}(f, g, *gens, **args)
&
\sphinxAtStartPar
Compute functional composition \sphinxcode{\sphinxupquote{f(g)}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{composite}}(nth)
&
\sphinxAtStartPar
Return the nth composite number, with the composite numbers indexed as composite(1) = 4, composite(2) = 6, etc....
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{compositepi}}(n)
&
\sphinxAtStartPar
Return the number of positive composite numbers less than or equal to n.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{connect\_regions}}(region\_map, hubmap, ...)
&
\sphinxAtStartPar
given a mapping of regions to lists of hubs, and hubs to regions, creates a set of arcs between hubs such that:
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{construct\_domain}}(obj, **args)
&
\sphinxAtStartPar
Construct a minimal domain for a list of expressions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{content}}(f, *gens, **args)
&
\sphinxAtStartPar
Compute GCD of coefficients of \sphinxcode{\sphinxupquote{f}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{continued\_fraction}}(a)
&
\sphinxAtStartPar
Return the continued fraction representation of a Rational or quadratic irrational.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{continued\_fraction\_convergents}}(cf)
&
\sphinxAtStartPar
Return an iterator over the convergents of a continued fraction (cf).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{continued\_fraction\_iterator}}(x)
&
\sphinxAtStartPar
Return continued fraction expansion of x as iterator.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{continued\_fraction\_periodic}}(p, q{[}, d, s{]})
&
\sphinxAtStartPar
Find the periodic continued fraction expansion of a quadratic irrational.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{continued\_fraction\_reduce}}(cf)
&
\sphinxAtStartPar
Reduce a continued fraction to a rational or quadratic irrational.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{convex\_hull}}(*args{[}, polygon{]})
&
\sphinxAtStartPar
The convex hull surrounding the Points contained in the list of entities.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{convolution}}(a, b{[}, cycle, dps, prime, ...{]})
&
\sphinxAtStartPar
Performs convolution by determining the type of desired convolution using hints.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{cosine\_transform}}(f, x, k, **hints)
&
\sphinxAtStartPar
Compute the unitary, ordinary\sphinxhyphen{}frequency cosine transform of \sphinxtitleref{f}, defined as
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{count\_ops}}(expr{[}, visual{]})
&
\sphinxAtStartPar
Return a representation (integer or expression) of the operations in expr.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{count\_roots}}(f{[}, inf, sup{]})
&
\sphinxAtStartPar
Return the number of roots of \sphinxcode{\sphinxupquote{f}} in \sphinxcode{\sphinxupquote{{[}inf, sup{]}}} interval.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{covering\_product}}(a, b)
&
\sphinxAtStartPar
Returns the covering product of given sequences.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{cse}}(exprs{[}, symbols, optimizations, ...{]})
&
\sphinxAtStartPar
Perform common subexpression elimination on an expression.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{cxxcode}}(expr{[}, assign\_to, standard{]})
&
\sphinxAtStartPar
C++ equivalent of \sphinxcode{\sphinxupquote{ccode()}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{cycle\_length}}(f, x0{[}, nmax, values{]})
&
\sphinxAtStartPar
For a given iterated sequence, return a generator that gives the length of the iterated cycle (lambda) and the length of terms before the cycle begins (mu); if \sphinxcode{\sphinxupquote{values}} is True then the terms of the sequence will be returned instead.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{cyclotomic\_poly}}(n{[}, x, polys{]})
&
\sphinxAtStartPar
Generates cyclotomic polynomial of order \sphinxtitleref{n} in \sphinxtitleref{x}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{decompogen}}(f, symbol)
&
\sphinxAtStartPar
Computes General functional decomposition of \sphinxcode{\sphinxupquote{f}}. Given an expression \sphinxcode{\sphinxupquote{f}}, returns a list \sphinxcode{\sphinxupquote{{[}f\_1, f\_2, ..., f\_n{]}}}, where::           f = f\_1 o f\_2 o ... f\_n = f\_1(f\_2(... f\_n)).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{decompose}}(f, *gens, **args)
&
\sphinxAtStartPar
Compute functional decomposition of \sphinxcode{\sphinxupquote{f}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{default\_sort\_key}}(item{[}, order{]})
&
\sphinxAtStartPar
Return a key that can be used for sorting.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{deg}}(r)
&
\sphinxAtStartPar
Return the degree value for the given radians (pi = 180 degrees).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{degree}}(f{[}, gen{]})
&
\sphinxAtStartPar
Return the degree of \sphinxcode{\sphinxupquote{f}} in the given variable.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{degree\_list}}(f, *gens, **args)
&
\sphinxAtStartPar
Return a list of degrees of \sphinxcode{\sphinxupquote{f}} in all variables.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{denom}}(expr)
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{derive\_by\_array}}(expr, dx)
&
\sphinxAtStartPar
Derivative by arrays.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{det}}(matexpr)
&
\sphinxAtStartPar
Matrix Determinant
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{det\_quick}}(M{[}, method{]})
&
\sphinxAtStartPar
Return \sphinxcode{\sphinxupquote{det(M)}} assuming that either there are lots of zeros or the size of the matrix is small.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{diag}}(*values{[}, strict, unpack{]})
&
\sphinxAtStartPar
Returns a matrix with the provided values placed on the diagonal.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{diagonalize\_vector}}(vector)
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{dict\_merge}}(*dicts)
&
\sphinxAtStartPar
Merge dictionaries into a single dictionary.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{diff}}(f, *symbols, **kwargs)
&
\sphinxAtStartPar
Differentiate f with respect to symbols.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{difference\_delta}}(expr{[}, n, step{]})
&
\sphinxAtStartPar
Difference Operator.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{differentiate\_finite}}(expr, *symbols{[}, ...{]})
&
\sphinxAtStartPar
Differentiate expr and replace Derivatives with finite differences.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{diophantine}}(eq{[}, param, syms, permute{]})
&
\sphinxAtStartPar
Simplify the solution procedure of diophantine equation \sphinxcode{\sphinxupquote{eq}} by converting it into a product of terms which should equal zero.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{discrete\_log}}(n, a, b{[}, order, prime\_order{]})
&
\sphinxAtStartPar
Compute the discrete logarithm of \sphinxcode{\sphinxupquote{a}} to the base \sphinxcode{\sphinxupquote{b}} modulo \sphinxcode{\sphinxupquote{n}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{discriminant}}(f, *gens, **args)
&
\sphinxAtStartPar
Compute discriminant of \sphinxcode{\sphinxupquote{f}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{div}}(f, g, *gens, **args)
&
\sphinxAtStartPar
Compute polynomial division of \sphinxcode{\sphinxupquote{f}} and \sphinxcode{\sphinxupquote{g}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{divisor\_count}}(n{[}, modulus, proper{]})
&
\sphinxAtStartPar
Return the number of divisors of \sphinxcode{\sphinxupquote{n}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{divisors}}(n{[}, generator, proper{]})
&
\sphinxAtStartPar
Return all divisors of n sorted from 1..n by default.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{dotprint}}(expr{[}, styles, atom, maxdepth, ...{]})
&
\sphinxAtStartPar
DOT description of a SymPy expression tree
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{dsolve}}(eq{[}, func, hint, simplify, ics, xi, ...{]})
&
\sphinxAtStartPar
Solves any (supported) kind of ordinary differential equation and system of ordinary differential equations.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{egyptian\_fraction}}(r{[}, algorithm{]})
&
\sphinxAtStartPar
Return the list of denominators of an Egyptian fraction expansion {\color{red}\bfseries{}{[}1{]}\_} of the said rational \sphinxtitleref{r}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{epath}}(path{[}, expr, func, args, kwargs{]})
&
\sphinxAtStartPar
Manipulate parts of an expression selected by a path.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{euler\_equations}}(L{[}, funcs, vars{]})
&
\sphinxAtStartPar
Find the Euler\sphinxhyphen{}Lagrange equations {\color{red}\bfseries{}{[}1{]}\_} for a given Lagrangian.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{evaluate}}(x)
&
\sphinxAtStartPar
Control automatic evaluation
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{expand}}(e{[}, deep, modulus, power\_base, ...{]})
&
\sphinxAtStartPar
Expand an expression using methods given as hints.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{expand\_complex}}(expr{[}, deep{]})
&
\sphinxAtStartPar
Wrapper around expand that only uses the complex hint.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{expand\_func}}(expr{[}, deep{]})
&
\sphinxAtStartPar
Wrapper around expand that only uses the func hint.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{expand\_log}}(expr{[}, deep, force, factor{]})
&
\sphinxAtStartPar
Wrapper around expand that only uses the log hint.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{expand\_mul}}(expr{[}, deep{]})
&
\sphinxAtStartPar
Wrapper around expand that only uses the mul hint.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{expand\_multinomial}}(expr{[}, deep{]})
&
\sphinxAtStartPar
Wrapper around expand that only uses the multinomial hint.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{expand\_power\_base}}(expr{[}, deep, force{]})
&
\sphinxAtStartPar
Wrapper around expand that only uses the power\_base hint.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{expand\_power\_exp}}(expr{[}, deep{]})
&
\sphinxAtStartPar
Wrapper around expand that only uses the power\_exp hint.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{expand\_trig}}(expr{[}, deep{]})
&
\sphinxAtStartPar
Wrapper around expand that only uses the trig hint.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{exptrigsimp}}(expr)
&
\sphinxAtStartPar
Simplifies exponential / trigonometric / hyperbolic functions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{exquo}}(f, g, *gens, **args)
&
\sphinxAtStartPar
Compute polynomial exact quotient of \sphinxcode{\sphinxupquote{f}} and \sphinxcode{\sphinxupquote{g}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{eye}}(*args, **kwargs)
&
\sphinxAtStartPar
Create square identity matrix n x n
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{factor}}(f, *gens{[}, deep{]})
&
\sphinxAtStartPar
Compute the factorization of expression, \sphinxcode{\sphinxupquote{f}}, into irreducibles.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{factor\_list}}(f, *gens, **args)
&
\sphinxAtStartPar
Compute a list of irreducible factors of \sphinxcode{\sphinxupquote{f}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{factor\_nc}}(expr)
&
\sphinxAtStartPar
Return the factored form of \sphinxcode{\sphinxupquote{expr}} while handling non\sphinxhyphen{}commutative expressions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{factor\_terms}}(expr{[}, radical, clear, ...{]})
&
\sphinxAtStartPar
Remove common factors from terms in all arguments without changing the underlying structure of the expr.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{factorint}}(n{[}, limit, use\_trial, use\_rho, ...{]})
&
\sphinxAtStartPar
Given a positive integer \sphinxcode{\sphinxupquote{n}}, \sphinxcode{\sphinxupquote{factorint(n)}} returns a dict containing the prime factors of \sphinxcode{\sphinxupquote{n}} as keys and their respective multiplicities as values.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{factorrat}}(rat{[}, limit, use\_trial, use\_rho, ...{]})
&
\sphinxAtStartPar
Given a Rational \sphinxcode{\sphinxupquote{r}}, \sphinxcode{\sphinxupquote{factorrat(r)}} returns a dict containing the prime factors of \sphinxcode{\sphinxupquote{r}} as keys and their respective multiplicities as values.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{failing\_assumptions}}(expr, **assumptions)
&
\sphinxAtStartPar
Return a dictionary containing assumptions with values not matching those of the passed assumptions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{farthest\_points}}(*args)
&
\sphinxAtStartPar
Return the subset of points from a set of points that were the furthest apart from each other in the 2D plane.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{fcode}}(expr{[}, assign\_to{]})
&
\sphinxAtStartPar
Converts an expr to a string of fortran code
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{fft}}(seq{[}, dps{]})
&
\sphinxAtStartPar
Performs the Discrete Fourier Transform (\sphinxstylestrong{DFT}) in the complex domain.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{field}}(symbols, domain{[}, order{]})
&
\sphinxAtStartPar
Construct new rational function field returning (field, x1, ..., xn).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{field\_isomorphism}}(a, b, *{[}, fast{]})
&
\sphinxAtStartPar
Find an embedding of one number field into another.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{filldedent}}(s{[}, w{]})
&
\sphinxAtStartPar
Strips leading and trailing empty lines from a copy of \sphinxcode{\sphinxupquote{s}}, then dedents, fills and returns it.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{finite\_diff\_weights}}(order, x\_list{[}, x0{]})
&
\sphinxAtStartPar
Calculates the finite difference weights for an arbitrarily spaced one\sphinxhyphen{}dimensional grid (\sphinxcode{\sphinxupquote{x\_list}}) for derivatives at \sphinxcode{\sphinxupquote{x0}} of order 0, 1, ..., up to \sphinxcode{\sphinxupquote{order}} using a recursive formula.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{flatten}}(iterable{[}, levels, cls{]})
&
\sphinxAtStartPar
Recursively denest iterable containers.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{fourier\_series}}(f{[}, limits, finite{]})
&
\sphinxAtStartPar
Computes the Fourier trigonometric series expansion.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{fourier\_transform}}(f, x, k, **hints)
&
\sphinxAtStartPar
Compute the unitary, ordinary\sphinxhyphen{}frequency Fourier transform of \sphinxcode{\sphinxupquote{f}}, defined as
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{fps}}(f{[}, x, x0, dir, hyper, order, rational, ...{]})
&
\sphinxAtStartPar
Generates Formal Power Series of \sphinxcode{\sphinxupquote{f}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{fraction}}(expr{[}, exact{]})
&
\sphinxAtStartPar
Returns a pair with expression\textquotesingle{}s numerator and denominator.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{fu}}(rv{[}, measure{]})
&
\sphinxAtStartPar
Attempt to simplify expression by using transformation rules given in the algorithm by Fu et al.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{fwht}}(seq)
&
\sphinxAtStartPar
Performs the Walsh Hadamard Transform (\sphinxstylestrong{WHT}), and uses Hadamard ordering for the sequence.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{galois\_group}}(f, *gens{[}, by\_name, max\_tries, ...{]})
&
\sphinxAtStartPar
Compute the Galois group for polynomials \sphinxstyleemphasis{f} up to degree 6.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{gammasimp}}(expr)
&
\sphinxAtStartPar
Simplify expressions with gamma functions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{gcd}}(f{[}, g{]})
&
\sphinxAtStartPar
Compute GCD of \sphinxcode{\sphinxupquote{f}} and \sphinxcode{\sphinxupquote{g}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{gcd\_list}}(seq, *gens, **args)
&
\sphinxAtStartPar
Compute GCD of a list of polynomials.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{gcd\_terms}}(terms{[}, isprimitive, clear, fraction{]})
&
\sphinxAtStartPar
Compute the GCD of \sphinxcode{\sphinxupquote{terms}} and put them together.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{gcdex}}(f, g, *gens, **args)
&
\sphinxAtStartPar
Extended Euclidean algorithm of \sphinxcode{\sphinxupquote{f}} and \sphinxcode{\sphinxupquote{g}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{generate}}({[}num\_regions, hubs\_per\_region, ...{]})
&
\sphinxAtStartPar
generates a random network with all parameters required to initialize a ToyBabyModel
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{getLogger}}({[}name{]})
&
\sphinxAtStartPar
Return a logger with the specified name, creating it if necessary.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{get\_contraction\_structure}}(expr)
&
\sphinxAtStartPar
Determine dummy indices of \sphinxcode{\sphinxupquote{expr}} and describe its structure
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{get\_indices}}(expr)
&
\sphinxAtStartPar
Determine the outer indices of expression \sphinxcode{\sphinxupquote{expr}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{gff}}(f, *gens, **args)
&
\sphinxAtStartPar
Compute greatest factorial factorization of \sphinxcode{\sphinxupquote{f}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{gff\_list}}(f, *gens, **args)
&
\sphinxAtStartPar
Compute a list of greatest factorial factors of \sphinxcode{\sphinxupquote{f}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{glsl\_code}}(expr{[}, assign\_to{]})
&
\sphinxAtStartPar
Converts an expr to a string of GLSL code
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{groebner}}(F, *gens, **args)
&
\sphinxAtStartPar
Computes the reduced Groebner basis for a set of polynomials.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ground\_roots}}(f, *gens, **args)
&
\sphinxAtStartPar
Compute roots of \sphinxcode{\sphinxupquote{f}} by factorization in the ground domain.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{group}}(seq{[}, multiple{]})
&
\sphinxAtStartPar
Splits a sequence into a list of lists of equal, adjacent elements.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{gruntz}}(e, z, z0{[}, dir{]})
&
\sphinxAtStartPar
Compute the limit of e(z) at the point z0 using the Gruntz algorithm.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hadamard\_product}}(*matrices)
&
\sphinxAtStartPar
Return the elementwise (aka Hadamard) product of matrices.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{half\_gcdex}}(f, g, *gens, **args)
&
\sphinxAtStartPar
Half extended Euclidean algorithm of \sphinxcode{\sphinxupquote{f}} and \sphinxcode{\sphinxupquote{g}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hankel\_transform}}(f, r, k, nu, **hints)
&
\sphinxAtStartPar
Compute the Hankel transform of \sphinxtitleref{f}, defined as
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{has\_dups}}(seq)
&
\sphinxAtStartPar
Return True if there are any duplicate elements in \sphinxcode{\sphinxupquote{seq}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{has\_variety}}(seq)
&
\sphinxAtStartPar
Return True if there are any different elements in \sphinxcode{\sphinxupquote{seq}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hermite\_poly}}(n{[}, x, polys{]})
&
\sphinxAtStartPar
Generates the Hermite polynomial \sphinxtitleref{H\_n(x)}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hermite\_prob\_poly}}(n{[}, x, polys{]})
&
\sphinxAtStartPar
Generates the probabilist\textquotesingle{}s Hermite polynomial \sphinxtitleref{He\_n(x)}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hessian}}(f, varlist{[}, constraints{]})
&
\sphinxAtStartPar
Compute Hessian matrix for a function f wrt parameters in varlist which may be given as a sequence or a row/column vector.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{homogeneous\_order}}(eq, *symbols)
&
\sphinxAtStartPar
Returns the order \sphinxtitleref{n} if \sphinxtitleref{g} is homogeneous and \sphinxcode{\sphinxupquote{None}} if it is not homogeneous.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{horner}}(f, *gens, **args)
&
\sphinxAtStartPar
Rewrite a polynomial in Horner form.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hyperexpand}}(f{[}, allow\_hyper, rewrite, place{]})
&
\sphinxAtStartPar
Expand hypergeometric functions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hypersimilar}}(f, g, k)
&
\sphinxAtStartPar
Returns True if \sphinxcode{\sphinxupquote{f}} and \sphinxcode{\sphinxupquote{g}} are hyper\sphinxhyphen{}similar.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hypersimp}}(f, k)
&
\sphinxAtStartPar
Given combinatorial term f(k) simplify its consecutive term ratio i.e. f(k+1)/f(k).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{idiff}}(eq, y, x{[}, n{]})
&
\sphinxAtStartPar
Return \sphinxcode{\sphinxupquote{dy/dx}} assuming that \sphinxcode{\sphinxupquote{eq == 0}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ifft}}(seq{[}, dps{]})
&
\sphinxAtStartPar
Performs the Discrete Fourier Transform (\sphinxstylestrong{DFT}) in the complex domain.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ifwht}}(seq)
&
\sphinxAtStartPar
Performs the Walsh Hadamard Transform (\sphinxstylestrong{WHT}), and uses Hadamard ordering for the sequence.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{igcd}}(*args)
&
\sphinxAtStartPar
Computes nonnegative integer greatest common divisor.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ilcm}}(*args)
&
\sphinxAtStartPar
Computes integer least common multiple.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{imageset}}(*args)
&
\sphinxAtStartPar
Return an image of the set under transformation \sphinxcode{\sphinxupquote{f}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{init\_printing}}({[}pretty\_print, order, ...{]})
&
\sphinxAtStartPar
Initializes pretty\sphinxhyphen{}printer depending on the environment.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{init\_session}}({[}ipython, pretty\_print, order, ...{]})
&
\sphinxAtStartPar
Initialize an embedded IPython or Python session.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{integer\_log}}(y, x)
&
\sphinxAtStartPar
Returns \sphinxcode{\sphinxupquote{(e, bool)}} where e is the largest nonnegative integer such that \(|y| \geq |x^e|\) and \sphinxcode{\sphinxupquote{bool}} is True if \$y = x\textasciicircum{}e\$.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{integer\_nthroot}}(y, n)
&
\sphinxAtStartPar
Return a tuple containing x = floor(y**(1/n)) and a boolean indicating whether the result is exact (that is, whether x**n == y).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{integrate}}(f, var, ...)
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{interactive\_traversal}}(expr)
&
\sphinxAtStartPar
Traverse a tree asking a user which branch to choose.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{interpolate}}(data, x)
&
\sphinxAtStartPar
Construct an interpolating polynomial for the data points evaluated at point x (which can be symbolic or numeric).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{interpolating\_poly}}(n, x{[}, X, Y{]})
&
\sphinxAtStartPar
Construct Lagrange interpolating polynomial for \sphinxcode{\sphinxupquote{n}} data points.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{interpolating\_spline}}(d, x, X, Y)
&
\sphinxAtStartPar
Return spline of degree \sphinxstyleemphasis{d}, passing through the given \sphinxstyleemphasis{X} and \sphinxstyleemphasis{Y} values.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{intersecting\_product}}(a, b)
&
\sphinxAtStartPar
Returns the intersecting product of given sequences.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{intersection}}(*entities{[}, pairwise{]})
&
\sphinxAtStartPar
The intersection of a collection of GeometryEntity instances.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{intervals}}(F{[}, all, eps, inf, sup, strict, ...{]})
&
\sphinxAtStartPar
Compute isolating intervals for roots of \sphinxcode{\sphinxupquote{f}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{intt}}(seq, prime)
&
\sphinxAtStartPar
Performs the Number Theoretic Transform (\sphinxstylestrong{NTT}), which specializes the Discrete Fourier Transform (\sphinxstylestrong{DFT}) over quotient ring \sphinxtitleref{Z/pZ} for prime \sphinxtitleref{p} instead of complex numbers \sphinxtitleref{C}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{inv\_quick}}(M)
&
\sphinxAtStartPar
Return the inverse of \sphinxcode{\sphinxupquote{M}}, assuming that either there are lots of zeros or the size of the matrix is small.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{inverse\_cosine\_transform}}(F, k, x, **hints)
&
\sphinxAtStartPar
Compute the unitary, ordinary\sphinxhyphen{}frequency inverse cosine transform of \sphinxtitleref{F}, defined as
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{inverse\_fourier\_transform}}(F, k, x, **hints)
&
\sphinxAtStartPar
Compute the unitary, ordinary\sphinxhyphen{}frequency inverse Fourier transform of \sphinxtitleref{F}, defined as
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{inverse\_hankel\_transform}}(F, k, r, nu, **hints)
&
\sphinxAtStartPar
Compute the inverse Hankel transform of \sphinxtitleref{F} defined as
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{inverse\_laplace\_transform}}(F, s, t{[}, plane{]})
&
\sphinxAtStartPar
Compute the inverse Laplace transform of \sphinxtitleref{F(s)}, defined as
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{inverse\_mellin\_transform}}(F, s, x, strip, **hints)
&
\sphinxAtStartPar
Compute the inverse Mellin transform of \sphinxtitleref{F(s)} over the fundamental strip given by \sphinxcode{\sphinxupquote{strip=(a, b)}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{inverse\_mobius\_transform}}(seq{[}, subset{]})
&
\sphinxAtStartPar
Performs the Mobius Transform for subset lattice with indices of sequence as bitmasks.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{inverse\_sine\_transform}}(F, k, x, **hints)
&
\sphinxAtStartPar
Compute the unitary, ordinary\sphinxhyphen{}frequency inverse sine transform of \sphinxtitleref{F}, defined as
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{invert}}(f, g, *gens, **args)
&
\sphinxAtStartPar
Invert \sphinxcode{\sphinxupquote{f}} modulo \sphinxcode{\sphinxupquote{g}} when possible.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{is\_abundant}}(n)
&
\sphinxAtStartPar
Returns True if \sphinxcode{\sphinxupquote{n}} is an abundant number, else False.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{is\_amicable}}(m, n)
&
\sphinxAtStartPar
Returns True if the numbers \sphinxtitleref{m} and \sphinxtitleref{n} are "amicable", else False.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{is\_convex}}(f, *syms{[}, domain{]})
&
\sphinxAtStartPar
Determines the  convexity of the function passed in the argument.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{is\_decreasing}}(expression{[}, interval, symbol{]})
&
\sphinxAtStartPar
Return whether the function is decreasing in the given interval.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{is\_deficient}}(n)
&
\sphinxAtStartPar
Returns True if \sphinxcode{\sphinxupquote{n}} is a deficient number, else False.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{is\_increasing}}(expression{[}, interval, symbol{]})
&
\sphinxAtStartPar
Return whether the function is increasing in the given interval.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{is\_mersenne\_prime}}(n)
&
\sphinxAtStartPar
Returns True if  \sphinxcode{\sphinxupquote{n}} is a Mersenne prime, else False.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{is\_monotonic}}(expression{[}, interval, symbol{]})
&
\sphinxAtStartPar
Return whether the function is monotonic in the given interval.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{is\_nthpow\_residue}}(a, n, m)
&
\sphinxAtStartPar
Returns True if \sphinxcode{\sphinxupquote{x**n == a (mod m)}} has solutions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{is\_perfect}}(n)
&
\sphinxAtStartPar
Returns True if \sphinxcode{\sphinxupquote{n}} is a perfect number, else False.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{is\_primitive\_root}}(a, p)
&
\sphinxAtStartPar
Returns True if \sphinxcode{\sphinxupquote{a}} is a primitive root of \sphinxcode{\sphinxupquote{p}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{is\_quad\_residue}}(a, p)
&
\sphinxAtStartPar
Returns True if \sphinxcode{\sphinxupquote{a}} (mod \sphinxcode{\sphinxupquote{p}}) is in the set of squares mod \sphinxcode{\sphinxupquote{p}}, i.e a \% p in set({[}i**2 \% p for i in range(p){]}).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{is\_strictly\_decreasing}}(expression{[}, ...{]})
&
\sphinxAtStartPar
Return whether the function is strictly decreasing in the given interval.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{is\_strictly\_increasing}}(expression{[}, ...{]})
&
\sphinxAtStartPar
Return whether the function is strictly increasing in the given interval.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{is\_zero\_dimensional}}(F, *gens, **args)
&
\sphinxAtStartPar
Checks if the ideal generated by a Groebner basis is zero\sphinxhyphen{}dimensional.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{isolate}}(alg{[}, eps, fast{]})
&
\sphinxAtStartPar
Find a rational isolating interval for a real algebraic number.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{isprime}}(n)
&
\sphinxAtStartPar
Test if n is a prime number (True) or not (False).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{itermonomials}}(variables, max\_degrees{[}, ...{]})
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{max\_degrees}} and \sphinxcode{\sphinxupquote{min\_degrees}} are either both integers or both lists.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{jacobi\_normalized}}(n, a, b, x)
&
\sphinxAtStartPar
Jacobi polynomial \$P\_n\textasciicircum{}\{left(alpha, betaright)\}(x)\$.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{jacobi\_poly}}(n, a, b{[}, x, polys{]})
&
\sphinxAtStartPar
Generates the Jacobi polynomial \sphinxtitleref{P\_n\textasciicircum{}\{(a,b)\}(x)}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{jacobi\_symbol}}(m, n)
&
\sphinxAtStartPar
Returns the Jacobi symbol \sphinxtitleref{(m / n)}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{jn\_zeros}}(n, k{[}, method, dps{]})
&
\sphinxAtStartPar
Zeros of the spherical Bessel function of the first kind.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{jordan\_cell}}(eigenval, n)
&
\sphinxAtStartPar
Create a Jordan block:
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{jscode}}(expr{[}, assign\_to{]})
&
\sphinxAtStartPar
Converts an expr to a string of javascript code
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{julia\_code}}(expr{[}, assign\_to{]})
&
\sphinxAtStartPar
Converts \sphinxtitleref{expr} to a string of Julia code.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{kronecker\_product}}(*matrices)
&
\sphinxAtStartPar
The Kronecker product of two or more arguments.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{kroneckersimp}}(expr)
&
\sphinxAtStartPar
Simplify expressions with KroneckerDelta.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{laguerre\_poly}}(n{[}, x, alpha, polys{]})
&
\sphinxAtStartPar
Generates the Laguerre polynomial \sphinxtitleref{L\_n\textasciicircum{}\{(alpha)\}(x)}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{lambdify}}(args, expr{[}, modules, printer, ...{]})
&
\sphinxAtStartPar
Convert a SymPy expression into a function that allows for fast numeric evaluation.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{laplace\_transform}}(f, t, s{[}, legacy\_matrix{]})
&
\sphinxAtStartPar
Compute the Laplace Transform \sphinxtitleref{F(s)} of \sphinxtitleref{f(t)},
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{lcm}}(f{[}, g{]})
&
\sphinxAtStartPar
Compute LCM of \sphinxcode{\sphinxupquote{f}} and \sphinxcode{\sphinxupquote{g}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{lcm\_list}}(seq, *gens, **args)
&
\sphinxAtStartPar
Compute LCM of a list of polynomials.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{legendre\_poly}}(n{[}, x, polys{]})
&
\sphinxAtStartPar
Generates the Legendre polynomial \sphinxtitleref{P\_n(x)}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{legendre\_symbol}}(a, p)
&
\sphinxAtStartPar
Returns the Legendre symbol \sphinxtitleref{(a / p)}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{limit}}(e, z, z0{[}, dir{]})
&
\sphinxAtStartPar
Computes the limit of \sphinxcode{\sphinxupquote{e(z)}} at the point \sphinxcode{\sphinxupquote{z0}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{limit\_seq}}(expr{[}, n, trials{]})
&
\sphinxAtStartPar
Finds the limit of a sequence as index \sphinxcode{\sphinxupquote{n}} tends to infinity.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{line\_integrate}}(field, Curve, variables)
&
\sphinxAtStartPar
Compute the line integral.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{linear\_eq\_to\_matrix}}(equations, *symbols)
&
\sphinxAtStartPar
Converts a given System of Equations into Matrix form.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{linsolve}}(system, *symbols)
&
\sphinxAtStartPar
Solve system of \$N\$ linear equations with \$M\$ variables; both underdetermined and overdetermined systems are supported.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{list2numpy}}(l{[}, dtype{]})
&
\sphinxAtStartPar
Converts Python list of SymPy expressions to a NumPy array.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{logcombine}}(expr{[}, force{]})
&
\sphinxAtStartPar
Takes logarithms and combines them using the following rules:
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{maple\_code}}(expr{[}, assign\_to{]})
&
\sphinxAtStartPar
Converts \sphinxcode{\sphinxupquote{expr}} to a string of Maple code.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mathematica\_code}}(expr, **settings)
&
\sphinxAtStartPar
Converts an expr to a string of the Wolfram Mathematica code
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{matrix2numpy}}(m{[}, dtype{]})
&
\sphinxAtStartPar
Converts SymPy\textquotesingle{}s matrix to a NumPy array.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{matrix\_multiply\_elementwise}}(A, B)
&
\sphinxAtStartPar
Return the Hadamard product (elementwise product) of A and B
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{matrix\_symbols}}(expr)
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{maximum}}(f, symbol{[}, domain{]})
&
\sphinxAtStartPar
Returns the maximum value of a function in the given domain.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mellin\_transform}}(f, x, s, **hints)
&
\sphinxAtStartPar
Compute the Mellin transform \sphinxtitleref{F(s)} of \sphinxtitleref{f(x)},
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{memoize\_property}}(propfunc)
&
\sphinxAtStartPar
Property decorator that caches the value of potentially expensive \sphinxtitleref{propfunc} after the first evaluation.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mersenne\_prime\_exponent}}(nth)
&
\sphinxAtStartPar
Returns the exponent \sphinxcode{\sphinxupquote{i}} for the nth Mersenne prime (which has the form \sphinxtitleref{2\textasciicircum{}i \sphinxhyphen{} 1}).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{minimal\_polynomial}}(ex{[}, x, compose, polys, ...{]})
&
\sphinxAtStartPar
Computes the minimal polynomial of an algebraic element.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{minimum}}(f, symbol{[}, domain{]})
&
\sphinxAtStartPar
Returns the minimum value of a function in the given domain.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{minpoly}}(ex{[}, x, compose, polys, domain{]})
&
\sphinxAtStartPar
This is a synonym for \sphinxcode{\sphinxupquote{minimal\_polynomial()}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mobius\_transform}}(seq{[}, subset{]})
&
\sphinxAtStartPar
Performs the Mobius Transform for subset lattice with indices of sequence as bitmasks.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mod\_inverse}}(a, m)
&
\sphinxAtStartPar
Return the number \$c\$ such that, \$a times c = 1 pmod\{m\}\$ where \$c\$ has the same sign as \$m\$.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{monic}}(f, *gens, **args)
&
\sphinxAtStartPar
Divide all coefficients of \sphinxcode{\sphinxupquote{f}} by \sphinxcode{\sphinxupquote{LC(f)}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{multiline\_latex}}(lhs, rhs{[}, terms\_per\_line, ...{]})
&
\sphinxAtStartPar
This function generates a LaTeX equation with a multiline right\sphinxhyphen{}hand side in an \sphinxcode{\sphinxupquote{align*}}, \sphinxcode{\sphinxupquote{eqnarray}} or \sphinxcode{\sphinxupquote{IEEEeqnarray}} environment.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{multinomial\_coefficients}}(m, n)
&
\sphinxAtStartPar
Return a dictionary containing pairs \sphinxcode{\sphinxupquote{\{(k1,k2,..,km) : C\_kn\}}} where \sphinxcode{\sphinxupquote{C\_kn}} are multinomial coefficients such that \sphinxcode{\sphinxupquote{n=k1+k2+..+km}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{multiplicity}}(p, n)
&
\sphinxAtStartPar
Find the greatest integer m such that p**m divides n.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{n\_order}}(a, n)
&
\sphinxAtStartPar
Returns the order of \sphinxcode{\sphinxupquote{a}} modulo \sphinxcode{\sphinxupquote{n}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nextprime}}(n{[}, ith{]})
&
\sphinxAtStartPar
Return the ith prime greater than n.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nfloat}}(expr{[}, n, exponent, dkeys{]})
&
\sphinxAtStartPar
Make all Rationals in expr Floats except those in exponents (unless the exponents flag is set to True) and those in undefined functions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nonlinsolve}}(system, *symbols)
&
\sphinxAtStartPar
Solve system of \$N\$ nonlinear equations with \$M\$ variables, which means both under and overdetermined systems are supported.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{not\_empty\_in}}(finset\_intersection, *syms)
&
\sphinxAtStartPar
Finds the domain of the functions in \sphinxcode{\sphinxupquote{finset\_intersection}} in which the \sphinxcode{\sphinxupquote{finite\_set}} is not\sphinxhyphen{}empty.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{npartitions}}(n{[}, verbose{]})
&
\sphinxAtStartPar
Calculate the partition function P(n), i.e. the number of ways that n can be written as a sum of positive integers.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nroots}}(f{[}, n, maxsteps, cleanup{]})
&
\sphinxAtStartPar
Compute numerical approximations of roots of \sphinxcode{\sphinxupquote{f}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nsimplify}}(expr{[}, constants, tolerance, ...{]})
&
\sphinxAtStartPar
Find a simple representation for a number or, if there are free symbols or if \sphinxcode{\sphinxupquote{rational=True}}, then replace Floats with their Rational equivalents.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nsolve}}(*args{[}, dict{]})
&
\sphinxAtStartPar
Solve a nonlinear equation system numerically: \sphinxcode{\sphinxupquote{nsolve(f, {[}args,{]} x0, modules={[}\textquotesingle{}mpmath\textquotesingle{}{]}, **kwargs)}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nth\_power\_roots\_poly}}(f, n, *gens, **args)
&
\sphinxAtStartPar
Construct a polynomial with n\sphinxhyphen{}th powers of roots of \sphinxcode{\sphinxupquote{f}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nthroot\_mod}}(a, n, p{[}, all\_roots{]})
&
\sphinxAtStartPar
Find the solutions to \sphinxcode{\sphinxupquote{x**n = a mod p}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ntt}}(seq, prime)
&
\sphinxAtStartPar
Performs the Number Theoretic Transform (\sphinxstylestrong{NTT}), which specializes the Discrete Fourier Transform (\sphinxstylestrong{DFT}) over quotient ring \sphinxtitleref{Z/pZ} for prime \sphinxtitleref{p} instead of complex numbers \sphinxtitleref{C}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{numbered\_symbols}}({[}prefix, cls, start, exclude{]})
&
\sphinxAtStartPar
Generate an infinite stream of Symbols consisting of a prefix and increasing subscripts provided that they do not occur in \sphinxcode{\sphinxupquote{exclude}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{numer}}(expr)
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{octave\_code}}(expr{[}, assign\_to{]})
&
\sphinxAtStartPar
Converts \sphinxtitleref{expr} to a string of Octave (or Matlab) code.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ode\_order}}(expr, func)
&
\sphinxAtStartPar
Returns the order of a given differential equation with respect to func.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ones}}(*args, **kwargs)
&
\sphinxAtStartPar
Returns a matrix of ones with \sphinxcode{\sphinxupquote{rows}} rows and \sphinxcode{\sphinxupquote{cols}} columns; if \sphinxcode{\sphinxupquote{cols}} is omitted a square matrix will be returned.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ordered}}(seq{[}, keys, default, warn{]})
&
\sphinxAtStartPar
Return an iterator of the seq where keys are used to break ties in a conservative fashion: if, after applying a key, there are no ties then no other keys will be computed.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pager\_print}}(expr, **settings)
&
\sphinxAtStartPar
Prints expr using the pager, in pretty form.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{parallel\_poly\_from\_expr}}(exprs, *gens, **args)
&
\sphinxAtStartPar
Construct polynomials from expressions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{parse\_expr}}(s{[}, local\_dict, transformations, ...{]})
&
\sphinxAtStartPar
Converts the string \sphinxcode{\sphinxupquote{s}} to a SymPy expression, in \sphinxcode{\sphinxupquote{local\_dict}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pde\_separate}}(eq, fun, sep{[}, strategy{]})
&
\sphinxAtStartPar
Separate variables in partial differential equation either by additive or multiplicative separation approach.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pde\_separate\_add}}(eq, fun, sep)
&
\sphinxAtStartPar
Helper function for searching additive separable solutions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pde\_separate\_mul}}(eq, fun, sep)
&
\sphinxAtStartPar
Helper function for searching multiplicative separable solutions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pdiv}}(f, g, *gens, **args)
&
\sphinxAtStartPar
Compute polynomial pseudo\sphinxhyphen{}division of \sphinxcode{\sphinxupquote{f}} and \sphinxcode{\sphinxupquote{g}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pdsolve}}(eq{[}, func, hint, dict, solvefun{]})
&
\sphinxAtStartPar
Solves any (supported) kind of partial differential equation.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{per}}(matexpr)
&
\sphinxAtStartPar
Matrix Permanent
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{perfect\_power}}(n{[}, candidates, big, factor{]})
&
\sphinxAtStartPar
Return \sphinxcode{\sphinxupquote{(b, e)}} such that \sphinxcode{\sphinxupquote{n}} == \sphinxcode{\sphinxupquote{b**e}} if \sphinxcode{\sphinxupquote{n}} is a unique perfect power with \sphinxcode{\sphinxupquote{e \textgreater{} 1}}, else \sphinxcode{\sphinxupquote{False}} (e.g. 1 is not a perfect power).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{periodicity}}(f, symbol{[}, check{]})
&
\sphinxAtStartPar
Tests the given function for periodicity in the given symbol.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{permutedims}}(expr{[}, perm, index\_order\_old, ...{]})
&
\sphinxAtStartPar
Permutes the indices of an array.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pexquo}}(f, g, *gens, **args)
&
\sphinxAtStartPar
Compute polynomial exact pseudo\sphinxhyphen{}quotient of \sphinxcode{\sphinxupquote{f}} and \sphinxcode{\sphinxupquote{g}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{piecewise\_exclusive}}(expr, *{[}, skip\_nan, deep{]})
&
\sphinxAtStartPar
Rewrite \sphinxcode{\sphinxupquote{Piecewise}} with mutually exclusive conditions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{piecewise\_fold}}(expr{[}, evaluate{]})
&
\sphinxAtStartPar
Takes an expression containing a piecewise function and returns the expression in piecewise form.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{plot}}(*args{[}, show{]})
&
\sphinxAtStartPar
Plots a function of a single variable as a curve.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{plot\_implicit}}(expr{[}, x\_var, y\_var, ...{]})
&
\sphinxAtStartPar
A plot function to plot implicit equations / inequalities.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{plot\_parametric}}(*args{[}, show{]})
&
\sphinxAtStartPar
Plots a 2D parametric curve.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{polarify}}(eq{[}, subs, lift{]})
&
\sphinxAtStartPar
Turn all numbers in eq into their polar equivalents (under the standard choice of argument).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pollard\_pm1}}(n{[}, B, a, retries, seed{]})
&
\sphinxAtStartPar
Use Pollard\textquotesingle{}s p\sphinxhyphen{}1 method to try to extract a nontrivial factor of \sphinxcode{\sphinxupquote{n}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pollard\_rho}}(n{[}, s, a, retries, seed, ...{]})
&
\sphinxAtStartPar
Use Pollard\textquotesingle{}s rho method to try to extract a nontrivial factor of \sphinxcode{\sphinxupquote{n}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{poly}}(expr, *gens, **args)
&
\sphinxAtStartPar
Efficiently transform an expression into a polynomial.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{poly\_from\_expr}}(expr, *gens, **args)
&
\sphinxAtStartPar
Construct a polynomial from an expression.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{posify}}(eq)
&
\sphinxAtStartPar
Return \sphinxcode{\sphinxupquote{eq}} (with generic symbols made positive) and a dictionary containing the mapping between the old and new symbols.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{postfixes}}(seq)
&
\sphinxAtStartPar
Generate all postfixes of a sequence.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{postorder\_traversal}}(node{[}, keys{]})
&
\sphinxAtStartPar
Do a postorder traversal of a tree.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{powdenest}}(eq{[}, force, polar{]})
&
\sphinxAtStartPar
Collect exponents on powers as assumptions allow.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{powsimp}}(expr{[}, deep, combine, force, measure{]})
&
\sphinxAtStartPar
Reduce expression by combining powers with similar bases and exponents.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pprint}}(expr, **kwargs)
&
\sphinxAtStartPar
Prints expr in pretty form.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pprint\_try\_use\_unicode}}()
&
\sphinxAtStartPar
See if unicode output is available and leverage it if possible
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pprint\_use\_unicode}}({[}flag{]})
&
\sphinxAtStartPar
Set whether pretty\sphinxhyphen{}printer should use unicode by default
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pquo}}(f, g, *gens, **args)
&
\sphinxAtStartPar
Compute polynomial pseudo\sphinxhyphen{}quotient of \sphinxcode{\sphinxupquote{f}} and \sphinxcode{\sphinxupquote{g}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{prefixes}}(seq)
&
\sphinxAtStartPar
Generate all prefixes of a sequence.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{prem}}(f, g, *gens, **args)
&
\sphinxAtStartPar
Compute polynomial pseudo\sphinxhyphen{}remainder of \sphinxcode{\sphinxupquote{f}} and \sphinxcode{\sphinxupquote{g}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pretty\_print}}(expr, **kwargs)
&
\sphinxAtStartPar
Prints expr in pretty form.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{preview}}(expr{[}, output, viewer, euler, ...{]})
&
\sphinxAtStartPar
View expression or LaTeX markup in PNG, DVI, PostScript or PDF form.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{prevprime}}(n)
&
\sphinxAtStartPar
Return the largest prime smaller than n.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{prime}}(nth)
&
\sphinxAtStartPar
Return the nth prime, with the primes indexed as prime(1) = 2, prime(2) = 3, etc.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{prime\_decomp}}(p{[}, T, ZK, dK, radical{]})
&
\sphinxAtStartPar
Compute the decomposition of rational prime \sphinxstyleemphasis{p} in a number field.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{prime\_valuation}}(I, P)
&
\sphinxAtStartPar
Compute the \sphinxstyleemphasis{P}\sphinxhyphen{}adic valuation for an integral ideal \sphinxstyleemphasis{I}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{primefactors}}(n{[}, limit, verbose{]})
&
\sphinxAtStartPar
Return a sorted list of n\textquotesingle{}s prime factors, ignoring multiplicity and any composite factor that remains if the limit was set too low for complete factorization.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{primerange}}(a{[}, b{]})
&
\sphinxAtStartPar
Generate a list of all prime numbers in the range {[}2, a), or {[}a, b).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{primitive}}(f, *gens, **args)
&
\sphinxAtStartPar
Compute content and the primitive form of \sphinxcode{\sphinxupquote{f}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{primitive\_element}}(extension{[}, x, ex, polys{]})
&
\sphinxAtStartPar
Find a single generator for a number field given by several generators.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{primitive\_root}}(p)
&
\sphinxAtStartPar
Returns the smallest primitive root or None.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{primorial}}(n{[}, nth{]})
&
\sphinxAtStartPar
Returns the product of the first n primes (default) or the primes less than or equal to n (when \sphinxcode{\sphinxupquote{nth=False}}).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{print\_ccode}}(expr, **settings)
&
\sphinxAtStartPar
Prints C representation of the given expression.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{print\_fcode}}(expr, **settings)
&
\sphinxAtStartPar
Prints the Fortran representation of the given expression.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{print\_glsl}}(expr, **settings)
&
\sphinxAtStartPar
Prints the GLSL representation of the given expression.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{print\_gtk}}(x{[}, start\_viewer{]})
&
\sphinxAtStartPar
Print to Gtkmathview, a gtk widget capable of rendering MathML.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{print\_jscode}}(expr, **settings)
&
\sphinxAtStartPar
Prints the Javascript representation of the given expression.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{print\_latex}}(expr, **settings)
&
\sphinxAtStartPar
Prints LaTeX representation of the given expression.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{print\_maple\_code}}(expr, **settings)
&
\sphinxAtStartPar
Prints the Maple representation of the given expression.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{print\_mathml}}(expr{[}, printer{]})
&
\sphinxAtStartPar
Prints a pretty representation of the MathML code for expr.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{print\_python}}(expr, **settings)
&
\sphinxAtStartPar
Print output of python() function
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{print\_rcode}}(expr, **settings)
&
\sphinxAtStartPar
Prints R representation of the given expression.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{print\_tree}}(node{[}, assumptions{]})
&
\sphinxAtStartPar
Prints a tree representation of "node".
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{prod}}(a{[}, start{]})
&
\sphinxAtStartPar
Return product of elements of a. Start with int 1 so if only
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{product}}(*args, **kwargs)
&
\sphinxAtStartPar
Compute the product.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{proper\_divisor\_count}}(n{[}, modulus{]})
&
\sphinxAtStartPar
Return the number of proper divisors of \sphinxcode{\sphinxupquote{n}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{proper\_divisors}}(n{[}, generator{]})
&
\sphinxAtStartPar
Return all divisors of n except n, sorted by default.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{public}}(obj)
&
\sphinxAtStartPar
Append \sphinxcode{\sphinxupquote{obj}}\textquotesingle{}s name to global \sphinxcode{\sphinxupquote{\_\_all\_\_}} variable (call site).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pycode}}(expr, **settings)
&
\sphinxAtStartPar
Converts an expr to a string of Python code
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{python}}(expr, **settings)
&
\sphinxAtStartPar
Return Python interpretation of passed expression (can be passed to the exec() function without any modifications)
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{quadratic\_congruence}}(a, b, c, p)
&
\sphinxAtStartPar
Find the solutions to {\color{red}\bfseries{}\textasciigrave{}\textasciigrave{}}a x**2 + b x + c = 0 mod p.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{quadratic\_residues}}(p)
&
\sphinxAtStartPar
Returns the list of quadratic residues.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{quo}}(f, g, *gens, **args)
&
\sphinxAtStartPar
Compute polynomial quotient of \sphinxcode{\sphinxupquote{f}} and \sphinxcode{\sphinxupquote{g}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{rad}}(d)
&
\sphinxAtStartPar
Return the radian value for the given degrees (pi = 180 degrees).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{radsimp}}(expr{[}, symbolic, max\_terms{]})
&
\sphinxAtStartPar
Rationalize the denominator by removing square roots.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{randMatrix}}(r{[}, c, min, max, seed, ...{]})
&
\sphinxAtStartPar
Create random matrix with dimensions \sphinxcode{\sphinxupquote{r}} x \sphinxcode{\sphinxupquote{c}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{random\_poly}}(x, n, inf, sup{[}, domain, polys{]})
&
\sphinxAtStartPar
Generates a polynomial of degree \sphinxcode{\sphinxupquote{n}} with coefficients in \sphinxcode{\sphinxupquote{{[}inf, sup{]}}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{randprime}}(a, b)
&
\sphinxAtStartPar
Return a random prime number in the range {[}a, b).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{rational\_interpolate}}(data, degnum{[}, X{]})
&
\sphinxAtStartPar
Returns a rational interpolation, where the data points are element of any integral domain.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ratsimp}}(expr)
&
\sphinxAtStartPar
Put an expression over a common denominator, cancel and reduce.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ratsimpmodprime}}(expr, G, *gens{[}, quick, ...{]})
&
\sphinxAtStartPar
Simplifies a rational expression \sphinxcode{\sphinxupquote{expr}} modulo the prime ideal generated by \sphinxcode{\sphinxupquote{G}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{rcode}}(expr{[}, assign\_to{]})
&
\sphinxAtStartPar
Converts an expr to a string of r code
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{rcollect}}(expr, *vars)
&
\sphinxAtStartPar
Recursively collect sums in an expression.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{real\_root}}(arg{[}, n, evaluate{]})
&
\sphinxAtStartPar
Return the real \sphinxstyleemphasis{n}\textquotesingle{}th\sphinxhyphen{}root of \sphinxstyleemphasis{arg} if possible.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{real\_roots}}(f{[}, multiple{]})
&
\sphinxAtStartPar
Return a list of real roots with multiplicities of \sphinxcode{\sphinxupquote{f}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{reduce\_abs\_inequalities}}(exprs, gen)
&
\sphinxAtStartPar
Reduce a system of inequalities with nested absolute values.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{reduce\_abs\_inequality}}(expr, rel, gen)
&
\sphinxAtStartPar
Reduce an inequality with nested absolute values.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{reduce\_inequalities}}(inequalities{[}, symbols{]})
&
\sphinxAtStartPar
Reduce a system of inequalities with rational coefficients.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{reduced}}(f, G, *gens, **args)
&
\sphinxAtStartPar
Reduces a polynomial \sphinxcode{\sphinxupquote{f}} modulo a set of polynomials \sphinxcode{\sphinxupquote{G}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{refine}}(expr{[}, assumptions{]})
&
\sphinxAtStartPar
Simplify an expression using assumptions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{refine\_root}}(f, s, t{[}, eps, steps, fast, ...{]})
&
\sphinxAtStartPar
Refine an isolating interval of a root to the given precision.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{register\_handler}}(key, handler)
&
\sphinxAtStartPar
Register a handler in the ask system.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{rem}}(f, g, *gens, **args)
&
\sphinxAtStartPar
Compute polynomial remainder of \sphinxcode{\sphinxupquote{f}} and \sphinxcode{\sphinxupquote{g}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{remove\_handler}}(key, handler)
&
\sphinxAtStartPar
Removes a handler from the ask system.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{reshape}}(seq, how)
&
\sphinxAtStartPar
Reshape the sequence according to the template in \sphinxcode{\sphinxupquote{how}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{residue}}(expr, x, x0)
&
\sphinxAtStartPar
Finds the residue of \sphinxcode{\sphinxupquote{expr}} at the point x=x0.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{resultant}}(f, g, *gens{[}, includePRS{]})
&
\sphinxAtStartPar
Compute resultant of \sphinxcode{\sphinxupquote{f}} and \sphinxcode{\sphinxupquote{g}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ring}}(symbols, domain{[}, order{]})
&
\sphinxAtStartPar
Construct a polynomial ring returning \sphinxcode{\sphinxupquote{(ring, x\_1, ..., x\_n)}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{root}}(arg, n{[}, k, evaluate{]})
&
\sphinxAtStartPar
Returns the \sphinxstyleemphasis{k}\sphinxhyphen{}th \sphinxstyleemphasis{n}\sphinxhyphen{}th root of \sphinxcode{\sphinxupquote{arg}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{rootof}}(f, x{[}, index, radicals, expand{]})
&
\sphinxAtStartPar
An indexed root of a univariate polynomial.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{roots}}(f, *gens{[}, auto, cubics, trig, ...{]})
&
\sphinxAtStartPar
Computes symbolic roots of a univariate polynomial.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{rot\_axis1}}(theta)
&
\sphinxAtStartPar
Returns a rotation matrix for a rotation of theta (in radians) about the 1\sphinxhyphen{}axis.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{rot\_axis2}}(theta)
&
\sphinxAtStartPar
Returns a rotation matrix for a rotation of theta (in radians) about the 2\sphinxhyphen{}axis.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{rot\_axis3}}(theta)
&
\sphinxAtStartPar
Returns a rotation matrix for a rotation of theta (in radians) about the 3\sphinxhyphen{}axis.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{rot\_ccw\_axis1}}(theta)
&
\sphinxAtStartPar
Returns a rotation matrix for a rotation of theta (in radians) about the 1\sphinxhyphen{}axis.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{rot\_ccw\_axis2}}(theta)
&
\sphinxAtStartPar
Returns a rotation matrix for a rotation of theta (in radians) about the 2\sphinxhyphen{}axis.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{rot\_ccw\_axis3}}(theta)
&
\sphinxAtStartPar
Returns a rotation matrix for a rotation of theta (in radians) about the 3\sphinxhyphen{}axis.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{rot\_givens}}(i, j, theta{[}, dim{]})
&
\sphinxAtStartPar
Returns a a Givens rotation matrix, a a rotation in the plane spanned by two coordinates axes.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{rotations}}(s{[}, dir{]})
&
\sphinxAtStartPar
Return a generator giving the items in s as list where each subsequent list has the items rotated to the left (default) or right (\sphinxcode{\sphinxupquote{dir=\sphinxhyphen{}1}}) relative to the previous list.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{round\_two}}(T{[}, radicals{]})
&
\sphinxAtStartPar
Zassenhaus\textquotesingle{}s "Round 2" algorithm.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{rsolve}}(f, y{[}, init{]})
&
\sphinxAtStartPar
Solve univariate recurrence with rational coefficients.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{rsolve\_hyper}}(coeffs, f, n, **hints)
&
\sphinxAtStartPar
Given linear recurrence operator \sphinxtitleref{operatorname\{L\}} of order \sphinxtitleref{k} with polynomial coefficients and inhomogeneous equation \sphinxtitleref{operatorname\{L\} y = f} we seek for all hypergeometric solutions over field \sphinxtitleref{K} of characteristic zero.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{rsolve\_poly}}(coeffs, f, n{[}, shift{]})
&
\sphinxAtStartPar
Given linear recurrence operator \sphinxtitleref{operatorname\{L\}} of order \sphinxtitleref{k} with polynomial coefficients and inhomogeneous equation \sphinxtitleref{operatorname\{L\} y = f}, where \sphinxtitleref{f} is a polynomial, we seek for all polynomial solutions over field \sphinxtitleref{K} of characteristic zero.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{rsolve\_ratio}}(coeffs, f, n, **hints)
&
\sphinxAtStartPar
Given linear recurrence operator \sphinxtitleref{operatorname\{L\}} of order \sphinxtitleref{k} with polynomial coefficients and inhomogeneous equation \sphinxtitleref{operatorname\{L\} y = f}, where \sphinxtitleref{f} is a polynomial, we seek for all rational solutions over field \sphinxtitleref{K} of characteristic zero.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.sensitivity.speed_test:src.sensitivity.speed_test.run_timed}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{run\_timed}}}}}(params, parameter\_name)
&
\sphinxAtStartPar
generates an instance of TestBabyModel with given parameters, sympifies it, and follows the sequence of steps
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{rust\_code}}(expr{[}, assign\_to{]})
&
\sphinxAtStartPar
Converts an expr to a string of Rust code
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{satisfiable}}(expr{[}, algorithm, all\_models, ...{]})
&
\sphinxAtStartPar
Check satisfiability of a propositional sentence.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{separatevars}}(expr{[}, symbols, dict, force{]})
&
\sphinxAtStartPar
Separates variables in an expression, if possible.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sequence}}(seq{[}, limits{]})
&
\sphinxAtStartPar
Returns appropriate sequence object.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{series}}(expr{[}, x, x0, n, dir{]})
&
\sphinxAtStartPar
Series expansion of expr around point \sphinxtitleref{x = x0}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{seterr}}({[}divide{]})
&
\sphinxAtStartPar
Should SymPy raise an exception on 0/0 or return a nan?
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sfield}}(exprs, *symbols, **options)
&
\sphinxAtStartPar
Construct a field deriving generators and domain from options and input expressions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{shape}}()
&
\sphinxAtStartPar
Return the shape of the \sphinxstyleemphasis{expr} as a tuple.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sift}}(seq, keyfunc{[}, binary{]})
&
\sphinxAtStartPar
Sift the sequence, \sphinxcode{\sphinxupquote{seq}} according to \sphinxcode{\sphinxupquote{keyfunc}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{signsimp}}(expr{[}, evaluate{]})
&
\sphinxAtStartPar
Make all Add sub\sphinxhyphen{}expressions canonical wrt sign.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{simplify}}(expr{[}, ratio, measure, rational, ...{]})
&
\sphinxAtStartPar
Simplifies the given expression.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{simplify\_logic}}(expr{[}, form, deep, force, ...{]})
&
\sphinxAtStartPar
This function simplifies a boolean function to its simplified version in SOP or POS form.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sine\_transform}}(f, x, k, **hints)
&
\sphinxAtStartPar
Compute the unitary, ordinary\sphinxhyphen{}frequency sine transform of \sphinxtitleref{f}, defined as
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{singularities}}(expression, symbol{[}, domain{]})
&
\sphinxAtStartPar
Find singularities of a given function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{singularityintegrate}}(f, x)
&
\sphinxAtStartPar
This function handles the indefinite integrations of Singularity functions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{smtlib\_code}}(expr{[}, auto\_assert, ...{]})
&
\sphinxAtStartPar
Converts \sphinxcode{\sphinxupquote{expr}} to a string of smtlib code.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{solve}}(f, *symbols, **flags)
&
\sphinxAtStartPar
Algebraically solves equations and systems of equations.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{solve\_linear}}(lhs{[}, rhs, symbols, exclude{]})
&
\sphinxAtStartPar
Return a tuple derived from \sphinxcode{\sphinxupquote{f = lhs \sphinxhyphen{} rhs}} that is one of the following: \sphinxcode{\sphinxupquote{(0, 1)}}, \sphinxcode{\sphinxupquote{(0, 0)}}, \sphinxcode{\sphinxupquote{(symbol, solution)}}, \sphinxcode{\sphinxupquote{(n, d)}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{solve\_linear\_system}}(system, *symbols, **flags)
&
\sphinxAtStartPar
Solve system of \$N\$ linear equations with \$M\$ variables, which means both under\sphinxhyphen{} and overdetermined systems are supported.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{solve\_linear\_system\_LU}}(matrix, syms)
&
\sphinxAtStartPar
Solves the augmented matrix system using \sphinxcode{\sphinxupquote{LUsolve}} and returns a dictionary in which solutions are keyed to the symbols of \sphinxstyleemphasis{syms} as ordered.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{solve\_poly\_inequality}}(poly, rel)
&
\sphinxAtStartPar
Solve a polynomial inequality with rational coefficients.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{solve\_poly\_system}}(seq, *gens{[}, strict{]})
&
\sphinxAtStartPar
Return a list of solutions for the system of polynomial equations or else None.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{solve\_rational\_inequalities}}(eqs)
&
\sphinxAtStartPar
Solve a system of rational inequalities with rational coefficients.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{solve\_triangulated}}(polys, *gens, **args)
&
\sphinxAtStartPar
Solve a polynomial system using Gianni\sphinxhyphen{}Kalkbrenner algorithm.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{solve\_undetermined\_coeffs}}(equ, coeffs, ...)
&
\sphinxAtStartPar
Solve a system of equations in \$k\$ parameters that is formed by matching coefficients in variables \sphinxcode{\sphinxupquote{coeffs}} that are on factors dependent on the remaining variables (or those given explicitly by \sphinxcode{\sphinxupquote{syms}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{solve\_univariate\_inequality}}(expr, gen{[}, ...{]})
&
\sphinxAtStartPar
Solves a real univariate inequality.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{solveset}}(f{[}, symbol, domain{]})
&
\sphinxAtStartPar
Solves a given inequality or equation with set as output
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{src.sensitivity.speed_test:src.sensitivity.speed_test.speed_accuracy_test}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{speed\_accuracy\_test}}}}}(params, parameter\_name, p)
&
\sphinxAtStartPar
performs a run\_timed execution with given parameters, takes the returned values, and measures the effect of increasing and
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sqf}}(f, *gens, **args)
&
\sphinxAtStartPar
Compute square\sphinxhyphen{}free factorization of \sphinxcode{\sphinxupquote{f}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sqf\_list}}(f, *gens, **args)
&
\sphinxAtStartPar
Compute a list of square\sphinxhyphen{}free factors of \sphinxcode{\sphinxupquote{f}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sqf\_norm}}(f, *gens, **args)
&
\sphinxAtStartPar
Compute square\sphinxhyphen{}free norm of \sphinxcode{\sphinxupquote{f}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sqf\_part}}(f, *gens, **args)
&
\sphinxAtStartPar
Compute square\sphinxhyphen{}free part of \sphinxcode{\sphinxupquote{f}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sqrt}}(arg{[}, evaluate{]})
&
\sphinxAtStartPar
Returns the principal square root.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sqrt\_mod}}(a, p{[}, all\_roots{]})
&
\sphinxAtStartPar
Find a root of \sphinxcode{\sphinxupquote{x**2 = a mod p}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sqrt\_mod\_iter}}(a, p{[}, domain{]})
&
\sphinxAtStartPar
Iterate over solutions to \sphinxcode{\sphinxupquote{x**2 = a mod p}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sqrtdenest}}(expr{[}, max\_iter{]})
&
\sphinxAtStartPar
Denests sqrts in an expression that contain other square roots if possible, otherwise returns the expr unchanged.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sring}}(exprs, *symbols, **options)
&
\sphinxAtStartPar
Construct a ring deriving generators and domain from options and input expressions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{stationary\_points}}(f, symbol{[}, domain{]})
&
\sphinxAtStartPar
Returns the stationary points of a function (where derivative of the function is 0) in the given domain.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sturm}}(f, *gens, **args)
&
\sphinxAtStartPar
Compute Sturm sequence of \sphinxcode{\sphinxupquote{f}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{subresultants}}(f, g, *gens, **args)
&
\sphinxAtStartPar
Compute subresultant PRS of \sphinxcode{\sphinxupquote{f}} and \sphinxcode{\sphinxupquote{g}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{subsets}}(seq{[}, k, repetition{]})
&
\sphinxAtStartPar
Generates all \sphinxtitleref{k}\sphinxhyphen{}subsets (combinations) from an \sphinxtitleref{n}\sphinxhyphen{}element set, \sphinxcode{\sphinxupquote{seq}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{substitution}}(system, symbols{[}, result, ...{]})
&
\sphinxAtStartPar
Solves the \sphinxtitleref{system} using substitution method.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{summation}}(f, *symbols, **kwargs)
&
\sphinxAtStartPar
Compute the summation of f with respect to symbols.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{swinnerton\_dyer\_poly}}(n{[}, x, polys{]})
&
\sphinxAtStartPar
Generates n\sphinxhyphen{}th Swinnerton\sphinxhyphen{}Dyer polynomial in \sphinxtitleref{x}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{symarray}}(prefix, shape, **kwargs)
&
\sphinxAtStartPar
Create a numpy ndarray of symbols (as an object array).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{symbols}}(names, *{[}, cls{]})
&
\sphinxAtStartPar
Transform strings into instances of \sphinxcode{\sphinxupquote{Symbol}} class.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{symmetric\_poly}}(n, *gens{[}, polys{]})
&
\sphinxAtStartPar
Generates symmetric polynomial of order \sphinxtitleref{n}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{symmetrize}}(F, *gens, **args)
&
\sphinxAtStartPar
Rewrite a polynomial in terms of elementary symmetric polynomials.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sympify}}(a{[}, locals, convert\_xor, strict, ...{]})
&
\sphinxAtStartPar
Converts an arbitrary expression to a type that can be used inside SymPy.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{take}}(iter, n)
&
\sphinxAtStartPar
Return \sphinxcode{\sphinxupquote{n}} items from \sphinxcode{\sphinxupquote{iter}} iterator.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{tensorcontraction}}(array, *contraction\_axes)
&
\sphinxAtStartPar
Contraction of an array\sphinxhyphen{}like object on the specified axes.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{tensordiagonal}}(array, *diagonal\_axes)
&
\sphinxAtStartPar
Diagonalization of an array\sphinxhyphen{}like object on the specified axes.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{tensorproduct}}(*args)
&
\sphinxAtStartPar
Tensor product among scalars or array\sphinxhyphen{}like objects.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{terms\_gcd}}(f, *gens, **args)
&
\sphinxAtStartPar
Remove GCD of terms from \sphinxcode{\sphinxupquote{f}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{textplot}}(expr, a, b{[}, W, H{]})
&
\sphinxAtStartPar
Print a crude ASCII art plot of the SymPy expression \textquotesingle{}expr\textquotesingle{} (which should contain a single symbol, e.g. x or something else) over the interval {[}a, b{]}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{threaded}}(func)
&
\sphinxAtStartPar
Apply \sphinxcode{\sphinxupquote{func}} to sub\sphinxhyphen{}\sphinxhyphen{}elements of an object, including \sphinxcode{\sphinxupquote{Add}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{timed}}(func{[}, setup, limit{]})
&
\sphinxAtStartPar
Adaptively measure execution time of a function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{to\_cnf}}(expr{[}, simplify, force{]})
&
\sphinxAtStartPar
Convert a propositional logical sentence \sphinxcode{\sphinxupquote{expr}} to conjunctive normal form: \sphinxcode{\sphinxupquote{((A | \textasciitilde{}B | ...) \& (B | C | ...) \& ...)}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{to\_dnf}}(expr{[}, simplify, force{]})
&
\sphinxAtStartPar
Convert a propositional logical sentence \sphinxcode{\sphinxupquote{expr}} to disjunctive normal form: \sphinxcode{\sphinxupquote{((A \& \textasciitilde{}B \& ...) | (B \& C \& ...) | ...)}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{to\_nnf}}(expr{[}, simplify{]})
&
\sphinxAtStartPar
Converts \sphinxcode{\sphinxupquote{expr}} to Negation Normal Form (NNF).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{to\_number\_field}}(extension{[}, theta, gen, alias{]})
&
\sphinxAtStartPar
Express one algebraic number in the field generated by another.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{together}}(expr{[}, deep, fraction{]})
&
\sphinxAtStartPar
Denest and combine rational expressions using symbolic methods.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{topological\_sort}}(graph{[}, key{]})
&
\sphinxAtStartPar
Topological sort of graph\textquotesingle{}s vertices.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{total\_degree}}(f, *gens)
&
\sphinxAtStartPar
Return the total\_degree of \sphinxcode{\sphinxupquote{f}} in the given variables.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{trace}}(expr)
&
\sphinxAtStartPar
Trace of a Matrix.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{trailing}}(n)
&
\sphinxAtStartPar
Count the number of trailing zero digits in the binary representation of n, i.e. determine the largest power of 2 that divides n.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{trigsimp}}(expr{[}, inverse{]})
&
\sphinxAtStartPar
Returns a reduced expression by using known trig identities.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{trunc}}(f, p, *gens, **args)
&
\sphinxAtStartPar
Reduce \sphinxcode{\sphinxupquote{f}} modulo a constant \sphinxcode{\sphinxupquote{p}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{unbranched\_argument}}(arg)
&
\sphinxAtStartPar
Returns periodic argument of arg with period as infinity.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{unflatten}}(iter{[}, n{]})
&
\sphinxAtStartPar
Group \sphinxcode{\sphinxupquote{iter}} into tuples of length \sphinxcode{\sphinxupquote{n}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{unpolarify}}(eq{[}, subs, exponents\_only{]})
&
\sphinxAtStartPar
If \sphinxtitleref{p} denotes the projection from the Riemann surface of the logarithm to the complex line, return a simplified version \sphinxtitleref{eq\textquotesingle{}} of \sphinxtitleref{eq} such that \sphinxtitleref{p(eq\textquotesingle{}) = p(eq)}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{use}}(expr, func{[}, level, args, kwargs{]})
&
\sphinxAtStartPar
Use \sphinxcode{\sphinxupquote{func}} to transform \sphinxcode{\sphinxupquote{expr}} at the given level.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{var}}(names, **args)
&
\sphinxAtStartPar
Create symbols and inject them into the global namespace.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{variations}}(seq, n{[}, repetition{]})
&
\sphinxAtStartPar
Returns an iterator over the n\sphinxhyphen{}sized variations of \sphinxcode{\sphinxupquote{seq}} (size N).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{vfield}}(symbols, domain{[}, order{]})
&
\sphinxAtStartPar
Construct new rational function field and inject generators into global namespace.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{viete}}(f{[}, roots{]})
&
\sphinxAtStartPar
Generate Viete\textquotesingle{}s formulas for \sphinxcode{\sphinxupquote{f}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{vring}}(symbols, domain{[}, order{]})
&
\sphinxAtStartPar
Construct a polynomial ring and inject \sphinxcode{\sphinxupquote{x\_1, ..., x\_n}} into the global namespace.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{wronskian}}(functions, var{[}, method{]})
&
\sphinxAtStartPar
Compute Wronskian for {[}{]} of functions
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{xfield}}(symbols, domain{[}, order{]})
&
\sphinxAtStartPar
Construct new rational function field returning (field, (x1, ..., xn)).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{xring}}(symbols, domain{[}, order{]})
&
\sphinxAtStartPar
Construct a polynomial ring returning \sphinxcode{\sphinxupquote{(ring, (x\_1, ..., x\_n))}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{xthreaded}}(func)
&
\sphinxAtStartPar
Apply \sphinxcode{\sphinxupquote{func}} to sub\sphinxhyphen{}\sphinxhyphen{}elements of an object, excluding \sphinxcode{\sphinxupquote{Add}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{zeros}}(*args, **kwargs)
&
\sphinxAtStartPar
Returns a matrix of zeros with \sphinxcode{\sphinxupquote{rows}} rows and \sphinxcode{\sphinxupquote{cols}} columns; if \sphinxcode{\sphinxupquote{cols}} is omitted a square matrix will be returned.
\\
\sphinxbottomrule
\end{longtable}
\sphinxtableafterendhook
\sphinxatlongtableend
\end{savenotes}
\subsubsection*{Classes}


\begin{savenotes}
\sphinxatlongtablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\makeatletter
  \LTleft \@totalleftmargin plus1fill
  \LTright\dimexpr\columnwidth-\@totalleftmargin-\linewidth\relax plus1fill
\makeatother
\begin{longtable}{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\endfirsthead

\multicolumn{2}{c}{\sphinxnorowcolor
    \makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}%
}\\
\sphinxtoprule
\endhead

\sphinxbottomrule
\multicolumn{2}{r}{\sphinxnorowcolor
    \makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}%
}\\
\endfoot

\endlastfoot
\sphinxtableatstartofbodyhook

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Abs}}(arg)
&
\sphinxAtStartPar
Return the absolute value of the argument.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{AccumBounds}}
&
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{AccumulationBounds}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Add}}(*args{[}, evaluate, \_sympify{]})
&
\sphinxAtStartPar
Expression representing addition operation for algebraic group.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Adjoint}}(*args, **kwargs)
&
\sphinxAtStartPar
The Hermitian adjoint of a matrix expression.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{AlgebraicField}}(dom, *ext{[}, alias{]})
&
\sphinxAtStartPar
Algebraic number field \DUrole{xref}{\DUrole{std}{\DUrole{std-ref}{QQ(a)}}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{AlgebraicNumber}}(expr{[}, coeffs, alias{]})
&
\sphinxAtStartPar
Class for representing algebraic numbers in SymPy.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{And}}(*args)
&
\sphinxAtStartPar
Logical AND function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{AppliedPredicate}}(predicate, *args)
&
\sphinxAtStartPar
The class of expressions resulting from applying \sphinxcode{\sphinxupquote{Predicate}} to the arguments.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Array}}
&
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{ImmutableDenseNDimArray}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{AssumptionsContext}}
&
\sphinxAtStartPar
Set containing default assumptions which are applied to the \sphinxcode{\sphinxupquote{ask()}} function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Atom}}(*args)
&
\sphinxAtStartPar
A parent class for atomic things.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{AtomicExpr}}(*args)
&
\sphinxAtStartPar
A parent class for object which are both atoms and Exprs.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{AutoSympy}}(model)
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Basic}}(*args)
&
\sphinxAtStartPar
Base class for all SymPy objects.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{BlockDiagMatrix}}(*mats)
&
\sphinxAtStartPar
A sparse matrix with block matrices along its diagonals
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{BlockMatrix}}(*args, **kwargs)
&
\sphinxAtStartPar
A BlockMatrix is a Matrix comprised of other matrices.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{CRootOf}}
&
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{ComplexRootOf}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Chi}}(z)
&
\sphinxAtStartPar
Cosh integral.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Ci}}(z)
&
\sphinxAtStartPar
Cosine integral.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Circle}}(*args, **kwargs)
&
\sphinxAtStartPar
A circle in space.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Complement}}(a, b{[}, evaluate{]})
&
\sphinxAtStartPar
Represents the set difference or relative complement of a set with another set.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ComplexField}}({[}prec, dps, tol{]})
&
\sphinxAtStartPar
Complex numbers up to the given precision.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ComplexRegion}}(sets{[}, polar{]})
&
\sphinxAtStartPar
Represents the Set of all Complex Numbers.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ComplexRootOf}}(f, x{[}, index, radicals, expand{]})
&
\sphinxAtStartPar
Represents an indexed complex root of a polynomial.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ConditionSet}}(sym, condition{[}, base\_set{]})
&
\sphinxAtStartPar
Set of elements which satisfies a given condition.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Contains}}(x, s)
&
\sphinxAtStartPar
Asserts that x is an element of the set S.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{CoordMap}}(var\_vector, eq\_duals, ineq\_duals, ...)
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{CosineTransform}}(*args)
&
\sphinxAtStartPar
Class representing unevaluated cosine transforms.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Curve}}(function, limits)
&
\sphinxAtStartPar
A curve in space.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{DeferredVector}}(name, **assumptions)
&
\sphinxAtStartPar
A vector whose components are deferred (e.g. for use with lambdify).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{DenseNDimArray}}(*args, **kwargs)
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Derivative}}(expr, *variables, **kwargs)
&
\sphinxAtStartPar
Carries out differentiation of the given expression with respect to symbols.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Determinant}}(mat)
&
\sphinxAtStartPar
Matrix Determinant
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{DiagMatrix}}(vector)
&
\sphinxAtStartPar
Turn a vector into a diagonal matrix.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{DiagonalMatrix}}(*args, **kwargs)
&
\sphinxAtStartPar
DiagonalMatrix(M) will create a matrix expression that behaves as though all off\sphinxhyphen{}diagonal elements, \sphinxtitleref{M{[}i, j{]}} where \sphinxtitleref{i != j}, are zero.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{DiagonalOf}}(*args, **kwargs)
&
\sphinxAtStartPar
DiagonalOf(M) will create a matrix expression that is equivalent to the diagonal of \sphinxtitleref{M}, represented as a single column matrix.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Dict}}(*args)
&
\sphinxAtStartPar
Wrapper around the builtin dict object.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{DifferentialMapping}}(US, coord2item, ...)
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{DiracDelta}}(arg{[}, k{]})
&
\sphinxAtStartPar
The DiracDelta function and its derivatives.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{DisjointUnion}}(*sets)
&
\sphinxAtStartPar
Represents the disjoint union (also known as the external disjoint union) of a finite number of sets.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Domain}}()
&
\sphinxAtStartPar
Superclass for all domains in the polys domains system.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{DotProduct}}(arg1, arg2)
&
\sphinxAtStartPar
Dot product of vector matrices
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Dummy}}({[}name, dummy\_index{]})
&
\sphinxAtStartPar
Dummy symbols are each unique, even if they have the same name:
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{EPath}}(path)
&
\sphinxAtStartPar
Manipulate expressions using paths.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Ei}}(z)
&
\sphinxAtStartPar
The classical exponential integral.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Ellipse}}({[}center, hradius, vradius, eccentricity{]})
&
\sphinxAtStartPar
An elliptical GeometryEntity.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Eq}}
&
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{Equality}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Equality}}(lhs, rhs, **options)
&
\sphinxAtStartPar
An equal relation between two objects.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Equivalent}}(*args)
&
\sphinxAtStartPar
Equivalence relation.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Expr}}(*args)
&
\sphinxAtStartPar
Base class for algebraic expressions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ExpressionDomain}}()
&
\sphinxAtStartPar
A class for arbitrary expressions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{FF}}
&
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{FiniteField}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{FF\_gmpy}}
&
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{GMPYFiniteField}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{FF\_python}}
&
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{PythonFiniteField}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{FallingFactorial}}(x, k)
&
\sphinxAtStartPar
Falling factorial (related to rising factorial) is a double valued function arising in concrete mathematics, hypergeometric functions and series expansions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{FiniteField}}(mod{[}, symmetric{]})
&
\sphinxAtStartPar
Finite field of prime order \DUrole{xref}{\DUrole{std}{\DUrole{std-ref}{GF(p)}}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{FiniteSet}}(*args, **kwargs)
&
\sphinxAtStartPar
Represents a finite set of Sympy expressions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Float}}(num{[}, dps, precision{]})
&
\sphinxAtStartPar
Represent a floating\sphinxhyphen{}point number of arbitrary precision.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{FourierTransform}}(*args)
&
\sphinxAtStartPar
Class representing unevaluated Fourier transforms.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{FractionField}}(domain\_or\_field{[}, symbols, order{]})
&
\sphinxAtStartPar
A class for representing multivariate rational function fields.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Function}}(*args)
&
\sphinxAtStartPar
Base class for applied mathematical functions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{FunctionClass}}(*args, **kwargs)
&
\sphinxAtStartPar
Base class for function classes.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{FunctionMatrix}}(rows, cols, lamda)
&
\sphinxAtStartPar
Represents a matrix using a function (\sphinxcode{\sphinxupquote{Lambda}}) which gives outputs according to the coordinates of each matrix entries.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{GF}}
&
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{FiniteField}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{GMPYFiniteField}}(mod{[}, symmetric{]})
&
\sphinxAtStartPar
Finite field based on GMPY integers.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{GMPYIntegerRing}}()
&
\sphinxAtStartPar
Integer ring based on GMPY\textquotesingle{}s \sphinxcode{\sphinxupquote{mpz}} type.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{GMPYRationalField}}()
&
\sphinxAtStartPar
Rational field based on GMPY\textquotesingle{}s \sphinxcode{\sphinxupquote{mpq}} type.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Ge}}
&
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{GreaterThan}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{GreaterThan}}(lhs, rhs, **options)
&
\sphinxAtStartPar
Class representations of inequalities.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{GroebnerBasis}}(F, *gens, **args)
&
\sphinxAtStartPar
Represents a reduced Groebner basis.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Gt}}
&
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{StrictGreaterThan}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{HadamardPower}}(base, exp)
&
\sphinxAtStartPar
Elementwise power of matrix expressions
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{HadamardProduct}}(*args{[}, evaluate, check{]})
&
\sphinxAtStartPar
Elementwise product of matrix expressions
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{HankelTransform}}(*args)
&
\sphinxAtStartPar
Class representing unevaluated Hankel transforms.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Heaviside}}(arg{[}, H0{]})
&
\sphinxAtStartPar
Heaviside step function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ITE}}(*args)
&
\sphinxAtStartPar
If\sphinxhyphen{}then\sphinxhyphen{}else clause.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Identity}}(n)
&
\sphinxAtStartPar
The Matrix Identity I \sphinxhyphen{} multiplicative identity
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Idx}}(label{[}, range{]})
&
\sphinxAtStartPar
Represents an integer index as an \sphinxcode{\sphinxupquote{Integer}} or integer expression.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ImageSet}}(flambda, *sets)
&
\sphinxAtStartPar
Image of a set under a mathematical function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ImmutableDenseMatrix}}(*args, **kwargs)
&
\sphinxAtStartPar
Create an immutable version of a matrix.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ImmutableDenseNDimArray}}(iterable{[}, shape{]})
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ImmutableMatrix}}
&
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{ImmutableDenseMatrix}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ImmutableSparseMatrix}}(*args, **kwargs)
&
\sphinxAtStartPar
Create an immutable version of a sparse matrix.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ImmutableSparseNDimArray}}({[}iterable, shape{]})
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Implies}}(*args)
&
\sphinxAtStartPar
Logical implication.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Indexed}}(base, *args, **kw\_args)
&
\sphinxAtStartPar
Represents a mathematical object with indices.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{IndexedBase}}(label{[}, shape, offset, strides{]})
&
\sphinxAtStartPar
Represent the base or stem of an indexed object
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Integer}}(i)
&
\sphinxAtStartPar
Represents integer numbers of any size.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{IntegerRing}}()
&
\sphinxAtStartPar
The domain \sphinxcode{\sphinxupquote{ZZ}} representing the integers \sphinxtitleref{mathbb\{Z\}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Integral}}(function, *symbols, **assumptions)
&
\sphinxAtStartPar
Represents unevaluated integral.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Intersection}}(*args, **kwargs)
&
\sphinxAtStartPar
Represents an intersection of sets as a \sphinxcode{\sphinxupquote{Set}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Interval}}(start, end{[}, left\_open, right\_open{]})
&
\sphinxAtStartPar
Represents a real interval as a Set.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Inverse}}(mat{[}, exp{]})
&
\sphinxAtStartPar
The multiplicative inverse of a matrix expression
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{InverseCosineTransform}}(*args)
&
\sphinxAtStartPar
Class representing unevaluated inverse cosine transforms.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{InverseFourierTransform}}(*args)
&
\sphinxAtStartPar
Class representing unevaluated inverse Fourier transforms.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{InverseHankelTransform}}(*args)
&
\sphinxAtStartPar
Class representing unevaluated inverse Hankel transforms.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{InverseLaplaceTransform}}(*args)
&
\sphinxAtStartPar
Class representing unevaluated inverse Laplace transforms.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{InverseMellinTransform}}(*args)
&
\sphinxAtStartPar
Class representing unevaluated inverse Mellin transforms.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{InverseSineTransform}}(*args)
&
\sphinxAtStartPar
Class representing unevaluated inverse sine transforms.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{KroneckerDelta}}(i, j{[}, delta\_range{]})
&
\sphinxAtStartPar
The discrete, or Kronecker, delta function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{KroneckerProduct}}(*args{[}, check{]})
&
\sphinxAtStartPar
The Kronecker product of two or more arguments.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Lambda}}(signature, expr)
&
\sphinxAtStartPar
Lambda(x, expr) represents a lambda function similar to Python\textquotesingle{}s \textquotesingle{}lambda x: expr\textquotesingle{}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{LambertW}}(x{[}, k{]})
&
\sphinxAtStartPar
The Lambert W function \$W(z)\$ is defined as the inverse function of \$w exp(w)\$ {\color{red}\bfseries{}{[}1{]}\_}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{LaplaceTransform}}(*args)
&
\sphinxAtStartPar
Class representing unevaluated Laplace transforms.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Le}}
&
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{LessThan}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{LessThan}}(lhs, rhs, **options)
&
\sphinxAtStartPar
Class representations of inequalities.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{LeviCivita}}(*args)
&
\sphinxAtStartPar
Represent the Levi\sphinxhyphen{}Civita symbol.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Li}}(z)
&
\sphinxAtStartPar
The offset logarithmic integral.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Limit}}(e, z, z0{[}, dir{]})
&
\sphinxAtStartPar
Represents an unevaluated limit.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Line}}(*args, **kwargs)
&
\sphinxAtStartPar
An infinite line in space.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Line2D}}(p1{[}, pt, slope{]})
&
\sphinxAtStartPar
An infinite line in space 2D.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Line3D}}(p1{[}, pt, direction\_ratio{]})
&
\sphinxAtStartPar
An infinite 3D line in space.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Lt}}
&
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{StrictLessThan}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{MatAdd}}(*args{[}, evaluate, check, \_sympify{]})
&
\sphinxAtStartPar
A Sum of Matrix Expressions
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{MatMul}}(*args{[}, evaluate, check, \_sympify{]})
&
\sphinxAtStartPar
A product of matrix expressions
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{MatPow}}(base, exp{[}, evaluate{]})
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Matrix}}
&
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{MutableDenseMatrix}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{MatrixBase}}()
&
\sphinxAtStartPar
Base class for matrix objects.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{MatrixExpr}}(*args, **kwargs)
&
\sphinxAtStartPar
Superclass for Matrix Expressions
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{MatrixPermute}}(mat, perm{[}, axis{]})
&
\sphinxAtStartPar
Symbolic representation for permuting matrix rows or columns.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{MatrixSlice}}(parent, rowslice, colslice)
&
\sphinxAtStartPar
A MatrixSlice of a Matrix Expression
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{MatrixSymbol}}(name, n, m)
&
\sphinxAtStartPar
Symbolic representation of a Matrix object
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Max}}(*args)
&
\sphinxAtStartPar
Return, if possible, the maximum value of the list.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{MellinTransform}}(*args)
&
\sphinxAtStartPar
Class representing unevaluated Mellin transforms.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Min}}(*args)
&
\sphinxAtStartPar
Return, if possible, the minimum value of the list.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Mod}}(p, q)
&
\sphinxAtStartPar
Represents a modulo operation on symbolic expressions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Monomial}}(monom{[}, gens{]})
&
\sphinxAtStartPar
Class representing a monomial, i.e. a product of powers.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Mul}}(*args{[}, evaluate, \_sympify{]})
&
\sphinxAtStartPar
Expression representing multiplication operation for algebraic field.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{MutableDenseMatrix}}(*args, **kwargs)
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{MutableDenseNDimArray}}({[}iterable, shape{]})
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{MutableMatrix}}
&
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{MutableDenseMatrix}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{MutableSparseMatrix}}(*args, **kwargs)
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{MutableSparseNDimArray}}({[}iterable, shape{]})
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{NDimArray}}(iterable{[}, shape{]})
&
\sphinxAtStartPar
N\sphinxhyphen{}dimensional array.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Nand}}(*args)
&
\sphinxAtStartPar
Logical NAND function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Ne}}
&
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{Unequality}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Nor}}(*args)
&
\sphinxAtStartPar
Logical NOR function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Not}}(arg)
&
\sphinxAtStartPar
Logical Not function (negation)
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Number}}(*obj)
&
\sphinxAtStartPar
Represents atomic numbers in SymPy.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{NumberSymbol}}()
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{O}}
&
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{Order}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{OmegaPower}}(a, b)
&
\sphinxAtStartPar
Represents ordinal exponential and multiplication terms one of the building blocks of the \sphinxcode{\sphinxupquote{Ordinal}} class.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{OneMatrix}}(m, n{[}, evaluate{]})
&
\sphinxAtStartPar
Matrix whose all entries are ones.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Options}}(gens, args{[}, flags, strict{]})
&
\sphinxAtStartPar
Options manager for polynomial manipulation module.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Or}}(*args)
&
\sphinxAtStartPar
Logical OR function
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Order}}(expr, *args, **kwargs)
&
\sphinxAtStartPar
Represents the limiting behavior of some function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Ordinal}}(*terms)
&
\sphinxAtStartPar
Represents ordinals in Cantor normal form.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Parabola}}({[}focus, directrix{]})
&
\sphinxAtStartPar
A parabolic GeometryEntity.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Permanent}}(mat)
&
\sphinxAtStartPar
Matrix Permanent
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{PermutationMatrix}}(perm)
&
\sphinxAtStartPar
A Permutation Matrix
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Piecewise}}(*\_args)
&
\sphinxAtStartPar
Represents a piecewise function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Plane}}(p1{[}, a, b{]})
&
\sphinxAtStartPar
A plane is a flat, two\sphinxhyphen{}dimensional surface.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Point}}(*args, **kwargs)
&
\sphinxAtStartPar
A point in a n\sphinxhyphen{}dimensional Euclidean space.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Point2D}}(*args{[}, \_nocheck{]})
&
\sphinxAtStartPar
A point in a 2\sphinxhyphen{}dimensional Euclidean space.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Point3D}}(*args{[}, \_nocheck{]})
&
\sphinxAtStartPar
A point in a 3\sphinxhyphen{}dimensional Euclidean space.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Poly}}(rep, *gens, **args)
&
\sphinxAtStartPar
Generic class for representing and operating on polynomial expressions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Polygon}}(*args{[}, n{]})
&
\sphinxAtStartPar
A two\sphinxhyphen{}dimensional polygon.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{PolynomialRing}}(domain\_or\_ring{[}, symbols, order{]})
&
\sphinxAtStartPar
A class for representing multivariate polynomial rings.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Pow}}(b, e{[}, evaluate{]})
&
\sphinxAtStartPar
Defines the expression x**y as "x raised to a power y"
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{PowerSet}}(arg{[}, evaluate{]})
&
\sphinxAtStartPar
A symbolic object representing a power set.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Predicate}}(*args, **kwargs)
&
\sphinxAtStartPar
Base class for mathematical predicates.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Product}}(function, *symbols, **assumptions)
&
\sphinxAtStartPar
Represents unevaluated products.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ProductSet}}(*sets, **assumptions)
&
\sphinxAtStartPar
Represents a Cartesian Product of Sets.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{PurePoly}}(rep, *gens, **args)
&
\sphinxAtStartPar
Class for representing pure polynomials.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{PythonFiniteField}}(mod{[}, symmetric{]})
&
\sphinxAtStartPar
Finite field based on Python\textquotesingle{}s integers.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{PythonIntegerRing}}()
&
\sphinxAtStartPar
Integer ring based on Python\textquotesingle{}s \sphinxcode{\sphinxupquote{int}} type.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{PythonRational}}
&
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{PythonMPQ}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{QQ\_gmpy}}
&
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{GMPYRationalField}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{QQ\_python}}
&
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{PythonRationalField}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Quaternion}}({[}a, b, c, d, real\_field, norm{]})
&
\sphinxAtStartPar
Provides basic quaternion operations.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Range}}(*args)
&
\sphinxAtStartPar
Represents a range of integers.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Rational}}(p{[}, q, gcd{]})
&
\sphinxAtStartPar
Represents rational numbers (p/q) of any size.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{RationalField}}()
&
\sphinxAtStartPar
Abstract base class for the domain \DUrole{xref}{\DUrole{std}{\DUrole{std-ref}{QQ}}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Ray}}(p1{[}, p2{]})
&
\sphinxAtStartPar
A Ray is a semi\sphinxhyphen{}line in the space with a source point and a direction.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Ray2D}}(p1{[}, pt, angle{]})
&
\sphinxAtStartPar
A Ray is a semi\sphinxhyphen{}line in the space with a source point and a direction.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Ray3D}}(p1{[}, pt, direction\_ratio{]})
&
\sphinxAtStartPar
A Ray is a semi\sphinxhyphen{}line in the space with a source point and a direction.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{RealField}}({[}prec, dps, tol{]})
&
\sphinxAtStartPar
Real numbers up to the given precision.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{RealNumber}}
&
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{Float}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{RegularPolygon}}(c, r, n{[}, rot{]})
&
\sphinxAtStartPar
A regular polygon.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Rel}}
&
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{Relational}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Rem}}(p, q)
&
\sphinxAtStartPar
Returns the remainder when \sphinxcode{\sphinxupquote{p}} is divided by \sphinxcode{\sphinxupquote{q}} where \sphinxcode{\sphinxupquote{p}} is finite and \sphinxcode{\sphinxupquote{q}} is not equal to zero.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{RisingFactorial}}(x, k)
&
\sphinxAtStartPar
Rising factorial (also called Pochhammer symbol {\color{red}\bfseries{}{[}1{]}\_}) is a double valued function arising in concrete mathematics, hypergeometric functions and series expansions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{RootOf}}(f, x{[}, index, radicals, expand{]})
&
\sphinxAtStartPar
Represents a root of a univariate polynomial.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{RootSum}}(expr{[}, func, x, auto, quadratic{]})
&
\sphinxAtStartPar
Represents a sum of all roots of a univariate polynomial.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Segment}}(p1, p2, **kwargs)
&
\sphinxAtStartPar
A line segment in space.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Segment2D}}(p1, p2, **kwargs)
&
\sphinxAtStartPar
A line segment in 2D space.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Segment3D}}(p1, p2, **kwargs)
&
\sphinxAtStartPar
A line segment in a 3D space.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SensitivityMatrix}}(sympification, duals, ...)
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SeqAdd}}(*args, **kwargs)
&
\sphinxAtStartPar
Represents term\sphinxhyphen{}wise addition of sequences.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SeqFormula}}(formula{[}, limits{]})
&
\sphinxAtStartPar
Represents sequence based on a formula.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SeqMul}}(*args, **kwargs)
&
\sphinxAtStartPar
Represents term\sphinxhyphen{}wise multiplication of sequences.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SeqPer}}(periodical{[}, limits{]})
&
\sphinxAtStartPar
Represents a periodic sequence.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Set}}(*args)
&
\sphinxAtStartPar
The base class for any kind of set.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Shi}}(z)
&
\sphinxAtStartPar
Sinh integral.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Si}}(z)
&
\sphinxAtStartPar
Sine integral.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Sieve}}()
&
\sphinxAtStartPar
An infinite list of prime numbers, implemented as a dynamically growing sieve of Eratosthenes.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SineTransform}}(*args)
&
\sphinxAtStartPar
Class representing unevaluated sine transforms.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SingularityFunction}}(variable, offset, exponent)
&
\sphinxAtStartPar
Singularity functions are a class of discontinuous functions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SparseMatrix}}
&
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{MutableSparseMatrix}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SparseNDimArray}}(*args, **kwargs)
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{StrPrinter}}({[}settings{]})
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{StrictGreaterThan}}(lhs, rhs, **options)
&
\sphinxAtStartPar
Class representations of inequalities.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{StrictLessThan}}(lhs, rhs, **options)
&
\sphinxAtStartPar
Class representations of inequalities.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Subs}}(expr, variables, point, **assumptions)
&
\sphinxAtStartPar
Represents unevaluated substitutions of an expression.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Sum}}(function, *symbols, **assumptions)
&
\sphinxAtStartPar
Represents unevaluated summation.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Symbol}}(name, **assumptions)
&
\sphinxAtStartPar
Assumptions:
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SymmetricDifference}}(a, b{[}, evaluate{]})
&
\sphinxAtStartPar
Represents the set of elements which are in either of the sets and not in their intersection.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{TableForm}}(data, **kwarg)
&
\sphinxAtStartPar
Create a nice table representation of data.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{TestBabyModel}}(*args, **kwds)
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Trace}}(mat)
&
\sphinxAtStartPar
Matrix Trace
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Transpose}}(*args, **kwargs)
&
\sphinxAtStartPar
The transpose of a matrix expression.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Triangle}}(*args, **kwargs)
&
\sphinxAtStartPar
A polygon with three vertices and three sides.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Tuple}}(*args, **kwargs)
&
\sphinxAtStartPar
Wrapper around the builtin tuple object.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Unequality}}(lhs, rhs, **options)
&
\sphinxAtStartPar
An unequal relation between two objects.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{UnevaluatedExpr}}(arg, **kwargs)
&
\sphinxAtStartPar
Expression that is not evaluated unless released.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Union}}(*args, **kwargs)
&
\sphinxAtStartPar
Represents a union of sets as a \sphinxcode{\sphinxupquote{Set}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Wild}}(name{[}, exclude, properties{]})
&
\sphinxAtStartPar
A Wild symbol matches anything, or anything without whatever is explicitly excluded.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{WildFunction}}(*args)
&
\sphinxAtStartPar
A WildFunction function matches any function (with its arguments).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Xor}}(*args)
&
\sphinxAtStartPar
Logical XOR (exclusive OR) function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Ynm}}(n, m, theta, phi)
&
\sphinxAtStartPar
Spherical harmonics defined as
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ZZ\_gmpy}}
&
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{GMPYIntegerRing}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ZZ\_python}}
&
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{PythonIntegerRing}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ZeroMatrix}}(m, n)
&
\sphinxAtStartPar
The Matrix Zero 0 \sphinxhyphen{} additive identity
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Znm}}(n, m, theta, phi)
&
\sphinxAtStartPar
Real spherical harmonics defined as
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{acos}}(arg)
&
\sphinxAtStartPar
The inverse cosine function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{acosh}}(arg)
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{acosh(x)}} is the inverse hyperbolic cosine of \sphinxcode{\sphinxupquote{x}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{acot}}(arg)
&
\sphinxAtStartPar
The inverse cotangent function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{acoth}}(arg)
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{acoth(x)}} is the inverse hyperbolic cotangent of \sphinxcode{\sphinxupquote{x}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{acsc}}(arg)
&
\sphinxAtStartPar
The inverse cosecant function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{acsch}}(arg)
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{acsch(x)}} is the inverse hyperbolic cosecant of \sphinxcode{\sphinxupquote{x}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{adjoint}}(arg)
&
\sphinxAtStartPar
Conjugate transpose or Hermite conjugation.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{airyai}}(arg)
&
\sphinxAtStartPar
The Airy function \$operatorname\{Ai\}\$ of the first kind.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{airyaiprime}}(arg)
&
\sphinxAtStartPar
The derivative \$operatorname\{Ai\}\textasciicircum{}prime\$ of the Airy function of the first kind.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{airybi}}(arg)
&
\sphinxAtStartPar
The Airy function \$operatorname\{Bi\}\$ of the second kind.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{airybiprime}}(arg)
&
\sphinxAtStartPar
The derivative \$operatorname\{Bi\}\textasciicircum{}prime\$ of the Airy function of the first kind.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{andre}}(n)
&
\sphinxAtStartPar
Andre numbers / Andre function
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{appellf1}}(a, b1, b2, c, x, y)
&
\sphinxAtStartPar
This is the Appell hypergeometric function of two variables as:
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{arg}}(arg)
&
\sphinxAtStartPar
Returns the argument (in radians) of a complex number.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{asec}}(arg)
&
\sphinxAtStartPar
The inverse secant function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{asech}}(arg)
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{asech(x)}} is the inverse hyperbolic secant of \sphinxcode{\sphinxupquote{x}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{asin}}(arg)
&
\sphinxAtStartPar
The inverse sine function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{asinh}}(arg)
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{asinh(x)}} is the inverse hyperbolic sine of \sphinxcode{\sphinxupquote{x}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{assoc\_laguerre}}(n, alpha, x)
&
\sphinxAtStartPar
Returns the \$n\$th generalized Laguerre polynomial in \$x\$, \$L\_n(x)\$.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{assoc\_legendre}}(n, m, x)
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{assoc\_legendre(n, m, x)}} gives \$P\_n\textasciicircum{}m(x)\$, where \$n\$ and \$m\$ are the degree and order or an expression which is related to the nth order Legendre polynomial, \$P\_n(x)\$ in the following manner:
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{atan}}(arg)
&
\sphinxAtStartPar
The inverse tangent function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{atan2}}(y, x)
&
\sphinxAtStartPar
The function \sphinxcode{\sphinxupquote{atan2(y, x)}} computes \sphinxtitleref{operatorname\{atan\}(y/x)} taking two arguments \sphinxtitleref{y} and \sphinxtitleref{x}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{atanh}}(arg)
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{atanh(x)}} is the inverse hyperbolic tangent of \sphinxcode{\sphinxupquote{x}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{bell}}(n{[}, k\_sym, symbols{]})
&
\sphinxAtStartPar
Bell numbers / Bell polynomials
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{bernoulli}}(n{[}, x{]})
&
\sphinxAtStartPar
Bernoulli numbers / Bernoulli polynomials / Bernoulli function
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{besseli}}(nu, z)
&
\sphinxAtStartPar
Modified Bessel function of the first kind.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{besselj}}(nu, z)
&
\sphinxAtStartPar
Bessel function of the first kind.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{besselk}}(nu, z)
&
\sphinxAtStartPar
Modified Bessel function of the second kind.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{bessely}}(nu, z)
&
\sphinxAtStartPar
Bessel function of the second kind.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{beta}}(x{[}, y{]})
&
\sphinxAtStartPar
The beta integral is called the Eulerian integral of the first kind by Legendre:
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{betainc}}(*args)
&
\sphinxAtStartPar
The Generalized Incomplete Beta function is defined as
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{betainc\_regularized}}(*args)
&
\sphinxAtStartPar
The Generalized Regularized Incomplete Beta function is given by
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{binomial}}(n, k)
&
\sphinxAtStartPar
Implementation of the binomial coefficient.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{carmichael}}(*args)
&
\sphinxAtStartPar
Carmichael Numbers:
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{cartes}}
&
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{product}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{catalan}}(n)
&
\sphinxAtStartPar
Catalan numbers
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ceiling}}(arg)
&
\sphinxAtStartPar
Ceiling is a univariate function which returns the smallest integer value not less than its argument.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{chebyshevt}}(n, x)
&
\sphinxAtStartPar
Chebyshev polynomial of the first kind, \$T\_n(x)\$.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{chebyshevt\_root}}(n, k)
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{chebyshev\_root(n, k)}} returns the \$k\$th root (indexed from zero) of the \$n\$th Chebyshev polynomial of the first kind; that is, if \$0 le k \textless{} n\$, \sphinxcode{\sphinxupquote{chebyshevt(n, chebyshevt\_root(n, k)) == 0}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{chebyshevu}}(n, x)
&
\sphinxAtStartPar
Chebyshev polynomial of the second kind, \$U\_n(x)\$.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{chebyshevu\_root}}(n, k)
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{chebyshevu\_root(n, k)}} returns the \$k\$th root (indexed from zero) of the \$n\$th Chebyshev polynomial of the second kind; that is, if \$0 le k \textless{} n\$, \sphinxcode{\sphinxupquote{chebyshevu(n, chebyshevu\_root(n, k)) == 0}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{conjugate}}(arg)
&
\sphinxAtStartPar
Returns the \sphinxstyleemphasis{complex conjugate} {\color{red}\bfseries{}{[}1{]}\_} of an argument.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{cos}}(arg)
&
\sphinxAtStartPar
The cosine function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{cosh}}(arg)
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{cosh(x)}} is the hyperbolic cosine of \sphinxcode{\sphinxupquote{x}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{cot}}(arg)
&
\sphinxAtStartPar
The cotangent function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{coth}}(arg)
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{coth(x)}} is the hyperbolic cotangent of \sphinxcode{\sphinxupquote{x}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{csc}}(arg)
&
\sphinxAtStartPar
The cosecant function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{csch}}(arg)
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{csch(x)}} is the hyperbolic cosecant of \sphinxcode{\sphinxupquote{x}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{defaultdict}}
&
\sphinxAtStartPar
defaultdict(default\_factory=None, /, {[}...{]}) \sphinxhyphen{}\sphinxhyphen{}\textgreater{} dict with default factory
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{digamma}}(z)
&
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{digamma}} function is the first derivative of the \sphinxcode{\sphinxupquote{loggamma}} function
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{dirichlet\_eta}}(s{[}, a{]})
&
\sphinxAtStartPar
Dirichlet eta function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{divisor\_sigma}}(n{[}, k{]})
&
\sphinxAtStartPar
Calculate the divisor function \sphinxtitleref{sigma\_k(n)} for positive integer n
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{elliptic\_e}}(m{[}, z{]})
&
\sphinxAtStartPar
Called with two arguments \$z\$ and \$m\$, evaluates the incomplete elliptic integral of the second kind, defined by
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{elliptic\_f}}(z, m)
&
\sphinxAtStartPar
The Legendre incomplete elliptic integral of the first kind, defined by
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{elliptic\_k}}(m)
&
\sphinxAtStartPar
The complete elliptic integral of the first kind, defined by
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{elliptic\_pi}}(n, m{[}, z{]})
&
\sphinxAtStartPar
Called with three arguments \$n\$, \$z\$ and \$m\$, evaluates the Legendre incomplete elliptic integral of the third kind, defined by
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{erf}}(arg)
&
\sphinxAtStartPar
The Gauss error function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{erf2}}(x, y)
&
\sphinxAtStartPar
Two\sphinxhyphen{}argument error function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{erf2inv}}(x, y)
&
\sphinxAtStartPar
Two\sphinxhyphen{}argument Inverse error function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{erfc}}(arg)
&
\sphinxAtStartPar
Complementary Error Function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{erfcinv}}(z)
&
\sphinxAtStartPar
Inverse Complementary Error Function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{erfi}}(z)
&
\sphinxAtStartPar
Imaginary error function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{erfinv}}(z)
&
\sphinxAtStartPar
Inverse Error Function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{euler}}(n{[}, x{]})
&
\sphinxAtStartPar
Euler numbers / Euler polynomials / Euler function
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{exp}}(arg)
&
\sphinxAtStartPar
The exponential function, \(e^x\).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{exp\_polar}}(*args)
&
\sphinxAtStartPar
Represent a \sphinxstyleemphasis{polar number} (see g\sphinxhyphen{}function Sphinx documentation).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{expint}}(nu, z)
&
\sphinxAtStartPar
Generalized exponential integral.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{factorial}}(n)
&
\sphinxAtStartPar
Implementation of factorial function over nonnegative integers.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{factorial2}}(arg)
&
\sphinxAtStartPar
The double factorial \sphinxtitleref{n!!}, not to be confused with \sphinxtitleref{(n!)!}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ff}}
&
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{FallingFactorial}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{fibonacci}}(n{[}, sym{]})
&
\sphinxAtStartPar
Fibonacci numbers / Fibonacci polynomials
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{floor}}(arg)
&
\sphinxAtStartPar
Floor is a univariate function which returns the largest integer value not greater than its argument.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{frac}}(arg)
&
\sphinxAtStartPar
Represents the fractional part of x
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{fresnelc}}(z)
&
\sphinxAtStartPar
Fresnel integral C.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{fresnels}}(z)
&
\sphinxAtStartPar
Fresnel integral S.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{gamma}}(arg)
&
\sphinxAtStartPar
The gamma function
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{gegenbauer}}(n, a, x)
&
\sphinxAtStartPar
Gegenbauer polynomial \$C\_n\textasciicircum{}\{left(alpharight)\}(x)\$.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{genocchi}}(n{[}, x{]})
&
\sphinxAtStartPar
Genocchi numbers / Genocchi polynomials / Genocchi function
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hankel1}}(nu, z)
&
\sphinxAtStartPar
Hankel function of the first kind.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hankel2}}(nu, z)
&
\sphinxAtStartPar
Hankel function of the second kind.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{harmonic}}(n{[}, m{]})
&
\sphinxAtStartPar
Harmonic numbers
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hermite}}(n, x)
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hermite(n, x)}} gives the \$n\$th Hermite polynomial in \$x\$, \$H\_n(x)\$.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hermite\_prob}}(n, x)
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hermite\_prob(n, x)}} gives the \$n\$th probabilist\textquotesingle{}s Hermite polynomial in \$x\$, \$He\_n(x)\$.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hn1}}(nu, z)
&
\sphinxAtStartPar
Spherical Hankel function of the first kind.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hn2}}(nu, z)
&
\sphinxAtStartPar
Spherical Hankel function of the second kind.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hyper}}(ap, bq, z)
&
\sphinxAtStartPar
The generalized hypergeometric function is defined by a series where the ratios of successive terms are a rational function of the summation index.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{im}}(arg)
&
\sphinxAtStartPar
Returns imaginary part of expression.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{jacobi}}(n, a, b, x)
&
\sphinxAtStartPar
Jacobi polynomial \$P\_n\textasciicircum{}\{left(alpha, betaright)\}(x)\$.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{jn}}(nu, z)
&
\sphinxAtStartPar
Spherical Bessel function of the first kind.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{laguerre}}(n, x)
&
\sphinxAtStartPar
Returns the \$n\$th Laguerre polynomial in \$x\$, \$L\_n(x)\$.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{legendre}}(n, x)
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{legendre(n, x)}} gives the \$n\$th Legendre polynomial of \$x\$, \$P\_n(x)\$
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{lerchphi}}(*args)
&
\sphinxAtStartPar
Lerch transcendent (Lerch phi function).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{li}}(z)
&
\sphinxAtStartPar
The classical logarithmic integral.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ln}}
&
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{log}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{log}}(arg{[}, base{]})
&
\sphinxAtStartPar
The natural logarithm function \sphinxtitleref{ln(x)} or \sphinxtitleref{log(x)}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{loggamma}}(z)
&
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{loggamma}} function implements the logarithm of the gamma function (i.e., \$logGamma(x)\$).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{lowergamma}}(a, x)
&
\sphinxAtStartPar
The lower incomplete gamma function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{lucas}}(n)
&
\sphinxAtStartPar
Lucas numbers
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{marcumq}}(m, a, b)
&
\sphinxAtStartPar
The Marcum Q\sphinxhyphen{}function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mathieuc}}(a, q, z)
&
\sphinxAtStartPar
The Mathieu Cosine function \$C(a,q,z)\$.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mathieucprime}}(a, q, z)
&
\sphinxAtStartPar
The derivative \$C\textasciicircum{}\{prime\}(a,q,z)\$ of the Mathieu Cosine function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mathieus}}(a, q, z)
&
\sphinxAtStartPar
The Mathieu Sine function \$S(a,q,z)\$.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mathieusprime}}(a, q, z)
&
\sphinxAtStartPar
The derivative \$S\textasciicircum{}\{prime\}(a,q,z)\$ of the Mathieu Sine function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{meijerg}}(*args)
&
\sphinxAtStartPar
The Meijer G\sphinxhyphen{}function is defined by a Mellin\sphinxhyphen{}Barnes type integral that resembles an inverse Mellin transform.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mobius}}(n)
&
\sphinxAtStartPar
Mobius function maps natural number to \{\sphinxhyphen{}1, 0, 1\}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{motzkin}}(n)
&
\sphinxAtStartPar
The nth Motzkin number is the number
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{multigamma}}(x, p)
&
\sphinxAtStartPar
The multivariate gamma function is a generalization of the gamma function
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{partition}}(n)
&
\sphinxAtStartPar
Partition numbers
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{periodic\_argument}}(ar, period)
&
\sphinxAtStartPar
Represent the argument on a quotient of the Riemann surface of the logarithm.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{polar\_lift}}(arg)
&
\sphinxAtStartPar
Lift argument to the Riemann surface of the logarithm, using the standard branch.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{polygamma}}(n, z)
&
\sphinxAtStartPar
The function \sphinxcode{\sphinxupquote{polygamma(n, z)}} returns \sphinxcode{\sphinxupquote{log(gamma(z)).diff(n + 1)}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{polylog}}(s, z)
&
\sphinxAtStartPar
Polylogarithm function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{preorder\_traversal}}(node{[}, keys{]})
&
\sphinxAtStartPar
Do a pre\sphinxhyphen{}order traversal of a tree.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{primenu}}(n)
&
\sphinxAtStartPar
Calculate the number of distinct prime factors for a positive integer n.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{primeomega}}(n)
&
\sphinxAtStartPar
Calculate the number of prime factors counting multiplicities for a positive integer n.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{primepi}}(n)
&
\sphinxAtStartPar
Represents the prime counting function pi(n) = the number of prime numbers less than or equal to n.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{principal\_branch}}(x, period)
&
\sphinxAtStartPar
Represent a polar number reduced to its principal branch on a quotient of the Riemann surface of the logarithm.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{re}}(arg)
&
\sphinxAtStartPar
Returns real part of expression.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{reduced\_totient}}(n)
&
\sphinxAtStartPar
Calculate the Carmichael reduced totient function lambda(n)
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{rf}}
&
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{RisingFactorial}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{riemann\_xi}}(s)
&
\sphinxAtStartPar
Riemann Xi function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sec}}(arg)
&
\sphinxAtStartPar
The secant function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sech}}(arg)
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sech(x)}} is the hyperbolic secant of \sphinxcode{\sphinxupquote{x}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sign}}(arg)
&
\sphinxAtStartPar
Returns the complex sign of an expression:
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sin}}(arg)
&
\sphinxAtStartPar
The sine function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sinc}}(arg)
&
\sphinxAtStartPar
Represents an unnormalized sinc function:
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sinh}}(arg)
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sinh(x)}} is the hyperbolic sine of \sphinxcode{\sphinxupquote{x}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{stieltjes}}(n{[}, a{]})
&
\sphinxAtStartPar
Represents Stieltjes constants, \$gamma\_\{k\}\$ that occur in Laurent Series expansion of the Riemann zeta function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{subfactorial}}(arg)
&
\sphinxAtStartPar
The subfactorial counts the derangements of \$n\$ items and is defined for non\sphinxhyphen{}negative integers as:
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{tan}}(arg)
&
\sphinxAtStartPar
The tangent function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{tanh}}(arg)
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{tanh(x)}} is the hyperbolic tangent of \sphinxcode{\sphinxupquote{x}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{totient}}(n)
&
\sphinxAtStartPar
Calculate the Euler totient function phi(n)
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{transpose}}(arg)
&
\sphinxAtStartPar
Linear map transposition.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{tribonacci}}(n{[}, sym{]})
&
\sphinxAtStartPar
Tribonacci numbers / Tribonacci polynomials
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{trigamma}}(z)
&
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{trigamma}} function is the second derivative of the \sphinxcode{\sphinxupquote{loggamma}} function
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{uppergamma}}(a, z)
&
\sphinxAtStartPar
The upper incomplete gamma function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{vectorize}}(*mdargs)
&
\sphinxAtStartPar
Generalizes a function taking scalars to accept multidimensional arguments.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{yn}}(nu, z)
&
\sphinxAtStartPar
Spherical Bessel function of the second kind.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{zeta}}(s{[}, a{]})
&
\sphinxAtStartPar
Hurwitz zeta function (or Riemann zeta function).
\\
\sphinxbottomrule
\end{longtable}
\sphinxtableafterendhook
\sphinxatlongtableend
\end{savenotes}
\subsubsection*{Exceptions}


\begin{savenotes}
\sphinxatlongtablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\makeatletter
  \LTleft \@totalleftmargin plus1fill
  \LTright\dimexpr\columnwidth-\@totalleftmargin-\linewidth\relax plus1fill
\makeatother
\begin{longtable}{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\endfirsthead

\multicolumn{2}{c}{\sphinxnorowcolor
    \makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}%
}\\
\sphinxtoprule
\endhead

\sphinxbottomrule
\multicolumn{2}{r}{\sphinxnorowcolor
    \makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}%
}\\
\endfoot

\endlastfoot
\sphinxtableatstartofbodyhook

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{BasePolynomialError}}
&
\sphinxAtStartPar
Base class for polynomial related exceptions.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{CoercionFailed}}
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ComputationFailed}}(func, nargs, exc)
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{DomainError}}
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{EvaluationFailed}}
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ExactQuotientFailed}}(f, g{[}, dom{]})
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ExtraneousFactors}}
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{FlagError}}
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{GeneratorsError}}
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{GeneratorsNeeded}}
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{GeometryError}}
&
\sphinxAtStartPar
An exception raised by classes in the geometry module.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{HeuristicGCDFailed}}
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{HomomorphismFailed}}
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{IsomorphismFailed}}
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{MultivariatePolynomialError}}
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{NonSquareMatrixError}}
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{NotAlgebraic}}
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{NotInvertible}}
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{NotReversible}}
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{OperationNotSupported}}(poly, func)
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{OptionError}}
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{PoleError}}
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{PolificationFailed}}(opt, origs, exprs{[}, seq{]})
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{PolynomialDivisionFailed}}(f, g, domain)
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{PolynomialError}}
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{PrecisionExhausted}}
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{RefinementFailed}}
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ShapeError}}
&
\sphinxAtStartPar
Wrong matrix shape
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SympifyError}}(expr{[}, base\_exc{]})
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{UnificationFailed}}
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{UnivariatePolynomialError}}
&
\sphinxAtStartPar

\\
\sphinxbottomrule
\end{longtable}
\sphinxtableafterendhook
\sphinxatlongtableend
\end{savenotes}
\index{run\_timed() (in module src.sensitivity.speed\_test)@\spxentry{run\_timed()}\spxextra{in module src.sensitivity.speed\_test}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.sensitivity.speed_test:src.sensitivity.speed_test.run_timed}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{src.sensitivity.speed\_test.}}\sphinxbfcode{\sphinxupquote{run\_timed}}}
{\sphinxparam{\DUrole{n}{params}}\sphinxparamcomma \sphinxparam{\DUrole{n}{parameter\_name}}}
{}
\pysigstopsignatures\begin{description}
\sphinxlineitem{generates an instance of TestBabyModel with given parameters, sympifies it, and follows the sequence of steps}
\sphinxAtStartPar
to get the sensitivity matrix. Prints times for each step.

\end{description}
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{params}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} dictionary of parameter values for the TestBabyModel instance generated. These are set in the beginning of the script.
Values can be changed in the declaration statements.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{parameter\_name}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} the name of the scalar parameter to evaluate sensitivities with respect to.

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
tuple of model to be solved, the sympification of the model, the SensitivityMatrix, DifferentialMapping associated with parameter and model solve values

\sphinxlineitem{Return type}
\sphinxAtStartPar
tuple

\end{description}\end{quote}

\end{fulllineitems}

\index{speed\_accuracy\_test() (in module src.sensitivity.speed\_test)@\spxentry{speed\_accuracy\_test()}\spxextra{in module src.sensitivity.speed\_test}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src.sensitivity.speed_test:src.sensitivity.speed_test.speed_accuracy_test}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{src.sensitivity.speed\_test.}}\sphinxbfcode{\sphinxupquote{speed\_accuracy\_test}}}
{\sphinxparam{\DUrole{n}{params}}\sphinxparamcomma \sphinxparam{\DUrole{n}{parameter\_name}}\sphinxparamcomma \sphinxparam{\DUrole{n}{p}}}
{}
\pysigstopsignatures\begin{description}
\sphinxlineitem{performs a run\_timed execution with given parameters, takes the returned values, and measures the effect of increasing and}
\sphinxAtStartPar
decreasing the named parameter by p, and compares the result to resolving the model with that same perturbation.

\end{description}
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{params} (\sphinxstyleemphasis{dict}) \textendash{} dictionary of parameter values for the TestBabyModel instance generated. These are set in the beginning of the script.
Values can be changed in the declaration statements.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{parameter\_name} (\sphinxstyleemphasis{str}) \textendash{} the name of the scalar parameter to evaluate sensitivities with respect to.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{p} (\sphinxstyleemphasis{float}) \textendash{} percentage change up and down to be measured, as a decimal.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}



\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{s}
\item\relax\sphinxstyleindexentry{src}\sphinxstyleindexpageref{src:\detokenize{module-src}}
\item\relax\sphinxstyleindexentry{src.common}\sphinxstyleindexpageref{src.common:\detokenize{module-src.common}}
\item\relax\sphinxstyleindexentry{src.common.config\_setup}\sphinxstyleindexpageref{src.common.config_setup:\detokenize{module-src.common.config_setup}}
\item\relax\sphinxstyleindexentry{src.common.model}\sphinxstyleindexpageref{src.common.model:\detokenize{module-src.common.model}}
\item\relax\sphinxstyleindexentry{src.common.utilities}\sphinxstyleindexpageref{src.common.utilities:\detokenize{module-src.common.utilities}}
\item\relax\sphinxstyleindexentry{src.integrator}\sphinxstyleindexpageref{src.integrator:\detokenize{module-src.integrator}}
\item\relax\sphinxstyleindexentry{src.integrator.gaussseidel}\sphinxstyleindexpageref{src.integrator.gaussseidel:\detokenize{module-src.integrator.gaussseidel}}
\item\relax\sphinxstyleindexentry{src.integrator.progress\_plot}\sphinxstyleindexpageref{src.integrator.progress_plot:\detokenize{module-src.integrator.progress_plot}}
\item\relax\sphinxstyleindexentry{src.integrator.runner}\sphinxstyleindexpageref{src.integrator.runner:\detokenize{module-src.integrator.runner}}
\item\relax\sphinxstyleindexentry{src.integrator.unified}\sphinxstyleindexpageref{src.integrator.unified:\detokenize{module-src.integrator.unified}}
\item\relax\sphinxstyleindexentry{src.integrator.utilities}\sphinxstyleindexpageref{src.integrator.utilities:\detokenize{module-src.integrator.utilities}}
\item\relax\sphinxstyleindexentry{src.models}\sphinxstyleindexpageref{src.models:\detokenize{module-src.models}}
\item\relax\sphinxstyleindexentry{src.models.electricity}\sphinxstyleindexpageref{src.models.electricity:\detokenize{module-src.models.electricity}}
\item\relax\sphinxstyleindexentry{src.models.electricity.scripts}\sphinxstyleindexpageref{src.models.electricity.scripts:\detokenize{module-src.models.electricity.scripts}}
\item\relax\sphinxstyleindexentry{src.models.electricity.scripts.electricity\_model}\sphinxstyleindexpageref{src.models.electricity.scripts.electricity_model:\detokenize{module-src.models.electricity.scripts.electricity_model}}
\item\relax\sphinxstyleindexentry{src.models.electricity.scripts.postprocessor}\sphinxstyleindexpageref{src.models.electricity.scripts.postprocessor:\detokenize{module-src.models.electricity.scripts.postprocessor}}
\item\relax\sphinxstyleindexentry{src.models.electricity.scripts.preprocessor}\sphinxstyleindexpageref{src.models.electricity.scripts.preprocessor:\detokenize{module-src.models.electricity.scripts.preprocessor}}
\item\relax\sphinxstyleindexentry{src.models.electricity.scripts.runner}\sphinxstyleindexpageref{src.models.electricity.scripts.runner:\detokenize{module-src.models.electricity.scripts.runner}}
\item\relax\sphinxstyleindexentry{src.models.electricity.scripts.utilities}\sphinxstyleindexpageref{src.models.electricity.scripts.utilities:\detokenize{module-src.models.electricity.scripts.utilities}}
\item\relax\sphinxstyleindexentry{src.models.hydrogen}\sphinxstyleindexpageref{src.models.hydrogen:\detokenize{module-src.models.hydrogen}}
\item\relax\sphinxstyleindexentry{src.models.hydrogen.model}\sphinxstyleindexpageref{src.models.hydrogen.model:\detokenize{module-src.models.hydrogen.model}}
\item\relax\sphinxstyleindexentry{src.models.hydrogen.model.actions}\sphinxstyleindexpageref{src.models.hydrogen.model.actions:\detokenize{module-src.models.hydrogen.model.actions}}
\item\relax\sphinxstyleindexentry{src.models.hydrogen.model.h2\_model}\sphinxstyleindexpageref{src.models.hydrogen.model.h2_model:\detokenize{module-src.models.hydrogen.model.h2_model}}
\item\relax\sphinxstyleindexentry{src.models.hydrogen.model.validators}\sphinxstyleindexpageref{src.models.hydrogen.model.validators:\detokenize{module-src.models.hydrogen.model.validators}}
\item\relax\sphinxstyleindexentry{src.models.hydrogen.network}\sphinxstyleindexpageref{src.models.hydrogen.network:\detokenize{module-src.models.hydrogen.network}}
\item\relax\sphinxstyleindexentry{src.models.hydrogen.network.grid}\sphinxstyleindexpageref{src.models.hydrogen.network.grid:\detokenize{module-src.models.hydrogen.network.grid}}
\item\relax\sphinxstyleindexentry{src.models.hydrogen.network.grid\_data}\sphinxstyleindexpageref{src.models.hydrogen.network.grid_data:\detokenize{module-src.models.hydrogen.network.grid_data}}
\item\relax\sphinxstyleindexentry{src.models.hydrogen.network.hub}\sphinxstyleindexpageref{src.models.hydrogen.network.hub:\detokenize{module-src.models.hydrogen.network.hub}}
\item\relax\sphinxstyleindexentry{src.models.hydrogen.network.region}\sphinxstyleindexpageref{src.models.hydrogen.network.region:\detokenize{module-src.models.hydrogen.network.region}}
\item\relax\sphinxstyleindexentry{src.models.hydrogen.network.registry}\sphinxstyleindexpageref{src.models.hydrogen.network.registry:\detokenize{module-src.models.hydrogen.network.registry}}
\item\relax\sphinxstyleindexentry{src.models.hydrogen.network.transportation\_arc}\sphinxstyleindexpageref{src.models.hydrogen.network.transportation_arc:\detokenize{module-src.models.hydrogen.network.transportation_arc}}
\item\relax\sphinxstyleindexentry{src.models.hydrogen.utilities}\sphinxstyleindexpageref{src.models.hydrogen.utilities:\detokenize{module-src.models.hydrogen.utilities}}
\item\relax\sphinxstyleindexentry{src.models.hydrogen.utilities.h2\_functions}\sphinxstyleindexpageref{src.models.hydrogen.utilities.h2_functions:\detokenize{module-src.models.hydrogen.utilities.h2_functions}}
\item\relax\sphinxstyleindexentry{src.models.residential}\sphinxstyleindexpageref{src.models.residential:\detokenize{module-src.models.residential}}
\item\relax\sphinxstyleindexentry{src.models.residential.preprocessor}\sphinxstyleindexpageref{src.models.residential.preprocessor:\detokenize{module-src.models.residential.preprocessor}}
\item\relax\sphinxstyleindexentry{src.models.residential.preprocessor.generate\_inputs}\sphinxstyleindexpageref{src.models.residential.preprocessor.generate_inputs:\detokenize{module-src.models.residential.preprocessor.generate_inputs}}
\item\relax\sphinxstyleindexentry{src.models.residential.scripts}\sphinxstyleindexpageref{src.models.residential.scripts:\detokenize{module-src.models.residential.scripts}}
\item\relax\sphinxstyleindexentry{src.models.residential.scripts.residential}\sphinxstyleindexpageref{src.models.residential.scripts.residential:\detokenize{module-src.models.residential.scripts.residential}}
\item\relax\sphinxstyleindexentry{src.sensitivity}\sphinxstyleindexpageref{src.sensitivity:\detokenize{module-src.sensitivity}}
\item\relax\sphinxstyleindexentry{src.sensitivity.babymodel}\sphinxstyleindexpageref{src.sensitivity.babymodel:\detokenize{module-src.sensitivity.babymodel}}
\item\relax\sphinxstyleindexentry{src.sensitivity.faster\_sensitivity}\sphinxstyleindexpageref{src.sensitivity.faster_sensitivity:\detokenize{module-src.sensitivity.faster_sensitivity}}
\item\relax\sphinxstyleindexentry{src.sensitivity.sensitivity\_tools}\sphinxstyleindexpageref{src.sensitivity.sensitivity_tools:\detokenize{module-src.sensitivity.sensitivity_tools}}
\item\relax\sphinxstyleindexentry{src.sensitivity.speed\_test}\sphinxstyleindexpageref{src.sensitivity.speed_test:\detokenize{module-src.sensitivity.speed_test}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}